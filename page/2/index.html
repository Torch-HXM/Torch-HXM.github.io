<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="东拼西凑、杂七杂八">
<meta property="og:type" content="website">
<meta property="og:title" content="北国回忆录">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="北国回忆录">
<meta property="og:description" content="东拼西凑、杂七杂八">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="何先生">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>北国回忆录</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <script src="https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js"></script>
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">北国回忆录</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">北国的冬日尚有余温</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">何先生</p>
  <div class="site-description" itemprop="description">东拼西凑、杂七杂八</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Torch-HXM" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Torch-HXM" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hxm_htjt@163.com" title="E-Mail → mailto:hxm_htjt@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/21/linux/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何先生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="北国回忆录">
      <meta itemprop="description" content="东拼西凑、杂七杂八">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 北国回忆录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/21/linux/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/" class="post-title-link" itemprop="url">Linux多进程编程-守护进程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-21 13:20:18" itemprop="dateCreated datePublished" datetime="2023-09-21T13:20:18+08:00">2023-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-07-30 19:18:10" itemprop="dateModified" datetime="2024-07-30T19:18:10+08:00">2024-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="守护进程的特点"><a href="#守护进程的特点" class="headerlink" title="守护进程的特点"></a>守护进程的特点</h2><h4 id="具有超级用户权限"><a href="#具有超级用户权限" class="headerlink" title="具有超级用户权限"></a>具有超级用户权限</h4><h4 id="父进程是init进程"><a href="#父进程是init进程" class="headerlink" title="父进程是init进程"></a>父进程是init进程</h4><h4 id="不使用控制终端"><a href="#不使用控制终端" class="headerlink" title="不使用控制终端"></a>不使用控制终端</h4><h4 id="是各自进程组和会话过程的唯一进程"><a href="#是各自进程组和会话过程的唯一进程" class="headerlink" title="是各自进程组和会话过程的唯一进程"></a>是各自进程组和会话过程的唯一进程</h4><h2 id="编写守护进程的基本步骤"><a href="#编写守护进程的基本步骤" class="headerlink" title="编写守护进程的基本步骤"></a>编写守护进程的基本步骤</h2><h3 id="创建子进程，退出父进程"><a href="#创建子进程，退出父进程" class="headerlink" title="创建子进程，退出父进程"></a>创建子进程，退出父进程</h3><ul>
<li>父进程先于子进程退出会变为孤儿进程</li>
<li>孤儿进程会被init进程收养——<a href="#%E7%88%B6%E8%BF%9B%E7%A8%8B%E6%98%AFinit%E8%BF%9B%E7%A8%8B">父进程是init进程</a></li>
</ul>
<h3 id="在子进程中创建新对话"><a href="#在子进程中创建新对话" class="headerlink" title="在子进程中创建新对话"></a>在子进程中创建新对话</h3><ul>
<li>setsid函数用于创建新会话，并担任该会话的组长——<a href="#%E6%98%AF%E5%90%84%E8%87%AA%E8%BF%9B%E7%A8%8B%E7%BB%84%E5%92%8C%E4%BC%9A%E8%AF%9D%E8%BF%87%E7%A8%8B%E7%9A%84%E5%94%AF%E4%B8%80%E8%BF%9B%E7%A8%8B">是各自进程组和会话过程的唯一进程</a></li>
<li>setsid函数让进程摆脱原会话、原进程组和原控制终端的控制——<a href="#%E4%B8%8D%E4%BD%BF%E7%94%A8%E6%8E%A7%E5%88%B6%E7%BB%88%E7%AB%AF">不使用控制终端</a></li>
<li>setsid函数使进程完全独立出来</li>
</ul>
<h3 id="改变当前目录为根目录"><a href="#改变当前目录为根目录" class="headerlink" title="改变当前目录为根目录"></a>改变当前目录为根目录</h3><p>试想，如果我们的守护进程的工作目录是在一个U盘里，那当我们要弹出U盘时，由于守护进程的存在我们会失败。因此，守护进程的工作目录需要修改为非移动设备上，比如我们的根目录。</p>
<ul>
<li>chdir函数可以更改进程的工作路径</li>
</ul>
<h3 id="重新设置文件权限掩码"><a href="#重新设置文件权限掩码" class="headerlink" title="重新设置文件权限掩码"></a>重新设置文件权限掩码</h3><ul>
<li>子进程会继承原父进程的文件权限掩码</li>
<li>给子进程使用文件带来麻烦</li>
<li>函数umask(0)重设文件权限掩码</li>
</ul>
<blockquote>
<p>umask(0)所获得的权限是将0取反在与创建文件时的权限相与。相当于保留了文件的创建时权限。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">权限</th>
<th align="center">八进制值</th>
<th align="center">二进制值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">—</td>
<td align="center">0</td>
<td align="center">000</td>
<td align="center">没有权限</td>
</tr>
<tr>
<td align="center">–x</td>
<td align="center">1</td>
<td align="center">001</td>
<td align="center">只有执行权限</td>
</tr>
<tr>
<td align="center">-w-</td>
<td align="center">2</td>
<td align="center">010</td>
<td align="center">只有写权限</td>
</tr>
<tr>
<td align="center">-wx</td>
<td align="center">3</td>
<td align="center">011</td>
<td align="center">写入和执行权限</td>
</tr>
<tr>
<td align="center">r–</td>
<td align="center">4</td>
<td align="center">100</td>
<td align="center">只有阅读权限</td>
</tr>
<tr>
<td align="center">r-x</td>
<td align="center">5</td>
<td align="center">101</td>
<td align="center">读取和执行权限</td>
</tr>
<tr>
<td align="center">rw-</td>
<td align="center">6</td>
<td align="center">110</td>
<td align="center">读写权限</td>
</tr>
<tr>
<td align="center">rwx</td>
<td align="center">7</td>
<td align="center">111</td>
<td align="center">执行所有三项操作的权限，即读取、写入和执行</td>
</tr>
</tbody></table>
<h3 id="关闭文件描述符"><a href="#关闭文件描述符" class="headerlink" title="关闭文件描述符"></a>关闭文件描述符</h3><ul>
<li>子进程会继承父进程已打开的文件，但这些文件可能不再使用，但依旧占据系统资源</li>
<li>比如标准输入输出和错误文件0,1,2，守护进程永远无法输出内容到屏幕，这三个文件失去作用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MAXFILE;i++) <span class="built_in">close</span>(i);    <span class="comment">//关闭文件描述符, MAXFILE是系统能够提供的文件描述符的最大值</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>相关阅读：子进程能否访问父进程上锁的文件？<br>在操作系统中，Fork会创建一个与父进程几乎相同的子进程。这意味着子进程继承了父进程的许多属性，例如打开的文件描述符和虚拟内存。然而，在Fork后，子进程和父进程是两个完全独立的进程，它们共享的只有一个初始状态。因此，子进程不能继承父进程的锁。如果父进程在Fork之前持有一个锁，它会继续持有该锁，但是在子进程中，锁的状态将被重置。在子进程中，锁不再处于锁定状态，因此需要重新获取锁才能访问共享资源。此外，锁的互斥量被存储在内存中，子进程会得到它自己的内存副本，这意味着子进程和父进程中的锁不会是相同的锁。<br>因此，子进程需要重新获取锁才能访问共享资源。如果在父进程中的锁是一个进程之间共享的锁（例如POSIX 有名信号量），则可以再次打开该锁，使得父子进程都可以使用这个锁，但必须小心以避免锁的竞争条件。</p>
</blockquote>
<h3 id="让守护进程能够被退出"><a href="#让守护进程能够被退出" class="headerlink" title="让守护进程能够被退出"></a>让守护进程能够被退出</h3><ul>
<li>使用kill命令来终止守护进程</li>
<li>kill命令会向进程发送signal信号，我们需要让守护进程能够接收信号<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">signal</span>(SIGTERM, sigterm_handler);   <span class="comment">// SIGTERM是kill命令发出的信号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigterm_handler</span><span class="params">(<span class="type">int</span> arg)</span></span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>相关阅读：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_55752775/article/details/130853402">Linux中的信号</a></p>
</blockquote>
<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>         <span class="comment">// 包含 exit</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>         <span class="comment">// 包含 strlen</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>          <span class="comment">// 包含 open</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>      <span class="comment">// 包含 pid_t</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>         <span class="comment">// 包含 read, write, close, usleep, setsid, chdir</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span>         <span class="comment">// 包含 signal, SIGTERM</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>       <span class="comment">// 包含 umask</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILE 1024        <span class="comment">// 使用ulimit -n命令查看</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> _running = <span class="number">1</span>;     <span class="comment">// volatile告诉编译器，_running随时可能被更改。_running标志着我们守护进程的运行状态，1代表在运行，0代表需要终止。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigterm_handler</span><span class="params">(<span class="type">int</span> arg)</span></span>&#123;</span><br><span class="line">    _running = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pc;</span><br><span class="line">    <span class="type">int</span> fd, len;</span><br><span class="line">    <span class="type">char</span>* buf = <span class="string">&quot;This is a Dameon.\n&quot;</span>;</span><br><span class="line">    len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    pc = fork();                        <span class="comment">// **创建子进程**</span></span><br><span class="line">    <span class="keyword">if</span>(pc&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;ERROR: create process failed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pc&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;PID: %d\n&quot;</span>, pc);        <span class="comment">// 输出子进程PID</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);                        <span class="comment">// **退出父进程**</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setsid</span>();                           <span class="comment">// **创建新会话**</span></span><br><span class="line">    <span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>);                         <span class="comment">// **将工作目录转移到根目录**</span></span><br><span class="line">    <span class="built_in">umask</span>(<span class="number">0</span>);                           <span class="comment">// **重置文件权限掩码**</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;MAXFILE;i++) <span class="built_in">close</span>(i);<span class="comment">// **关闭所有文件描述符**   //这里没有关闭标准输入输出和错误，方便我们debug。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, sigterm_handler);   <span class="comment">// **处理kill事件**</span></span><br><span class="line">    <span class="keyword">while</span>(_running)&#123;</span><br><span class="line">        fd = <span class="built_in">open</span>(<span class="string">&quot;/home/torch/code/linux-c++/clion/dameon.log&quot;</span>, O_CREAT|O_WRONLY|O_APPEND);    <span class="comment">// 文件不存在时创建，仅写入，追加</span></span><br><span class="line">        <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);                                                <span class="comment">// 文件打开失败</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">write</span>(fd, buf, len);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">10</span>*<span class="number">1000</span>);                                            <span class="comment">// 10ms延时</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将代码编译后用sudo权限执行——<a href="#%E5%85%B7%E6%9C%89%E8%B6%85%E7%BA%A7%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90">具有超级用户权限</a></p>
<blockquote>
<p>PID: 9259</p>
</blockquote>
<p>可以通过ps axj命令查看守护进程，可以找到我们的进程就在其中。可以使用sudo kill 9259杀死我们的进程。使用管理员权限打开dameon.log文件，可以看到里面的内容。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/20/linux/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B-%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何先生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="北国回忆录">
      <meta itemprop="description" content="东拼西凑、杂七杂八">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 北国回忆录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/20/linux/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B-%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B/" class="post-title-link" itemprop="url">Linux多进程编程-创建进程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-20 15:31:11" itemprop="dateCreated datePublished" datetime="2023-09-20T15:31:11+08:00">2023-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-07-30 19:18:24" itemprop="dateModified" datetime="2024-07-30T19:18:24+08:00">2024-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="进程的基础操作"><a href="#进程的基础操作" class="headerlink" title="进程的基础操作"></a>进程的基础操作</h2><h3 id="获得当前进程的PID"><a href="#获得当前进程的PID" class="headerlink" title="获得当前进程的PID"></a>获得当前进程的PID</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程的PID是：%d\n&quot;</span>, pid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>进程的PID是：4830</p>
</blockquote>
<h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><ol>
<li>函数<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>该函数用于创建子进程，子进程被创建后复制父进程的程序内容和变量内容（但不共享变量内存，不继承文件锁），包括该fork函数。如果进程创建成功，在父进程中，fork函数的返回值为子进程的PID；在子进程中fork函数的返回值为0。看起来就像是fork有两个返回值一样。如果进程创建失败，子进程没有产生，父进程中的fork函数返回-1。</p>
<ol start="2">
<li>示例代码</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;                          <span class="comment">// 用以记录进程的PID</span></span><br><span class="line">    <span class="type">int</span> counter = <span class="number">0</span>;                    <span class="comment">// 用以证明子进程复制了父进程的程序，但并不是内存共享</span></span><br><span class="line"></span><br><span class="line">    pid = fork();                       <span class="comment">// 创建子进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;                          <span class="comment">// 进程创建失败</span></span><br><span class="line">        cerr&lt;&lt; <span class="string">&quot;进程创建失败！&quot;</span>&lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;                    <span class="comment">// 该进程为子进程</span></span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;我是子进程，PID：&quot;</span>&lt;&lt; <span class="built_in">getpid</span>()&lt;&lt; endl;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;                               <span class="comment">// 该进程为父进程</span></span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;我是父进程，PID：&quot;</span>&lt;&lt; <span class="built_in">getpid</span>()&lt;&lt; <span class="string">&quot;  我获得的子进程PID为：&quot;</span>&lt;&lt; pid&lt;&lt; endl;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;子进程中的counter：&quot;</span>&lt;&lt; counter&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;父进程中的counter：&quot;</span>&lt;&lt; counter&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我是父进程，PID：7825  我获得的子进程PID为：7826<br>父进程中的counter：1<br>我是子进程，PID：7826<br>子进程中的counter：1    </p>
</blockquote>
<ol start="3">
<li>分析</li>
</ol>
<p>可以看到，在父进程中我们所获得的子进程的PID和在子进程中所获得的PID是一致的(7826)。同时，子进程虽然在创建时拷贝了父进程的变量，但是，由于子进程与父进程之间不存在内存共享，所以在子进程和父进程中分别修改counter并不能互相影响。<strong>另外，子进程和父进程的执行并没有先后顺序，一切都取决于操作系统的调度策略。</strong></p>
<h3 id="如何控制父进程与子进程的时序关系？"><a href="#如何控制父进程与子进程的时序关系？" class="headerlink" title="如何控制父进程与子进程的时序关系？"></a>如何控制父进程与子进程的时序关系？</h3><p>很多时候，我们希望子进程先行结束，然后再结束父进程。这样做有三点好处：</p>
<ul>
<li>能够确保交给子进程的任务在父进程结束之前完满完成。</li>
<li>同时也可以避免父进程先行结束，子进程成为孤儿进程。</li>
<li>在父进程中回收子进程的task_struct，以免子进程成为僵尸进程。</li>
</ul>
<p>在C\C++中，我们通过wait()或waitpid()函数来实现这一目的。wait()和waitpid()函数都能够阻塞调用他们的进程，直到接收到子进程的状态才会结束阻塞。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description     阻塞父进程，等待任意一个子进程退出，停止阻塞并回收子进程资源</span></span><br><span class="line"><span class="comment"> * @param status    存放子进程的结束状态</span></span><br><span class="line"><span class="comment"> * @return          执行成功返回子进程的PID，失败返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span>* status)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description     高配版wait，函数的行为由pid和options参数决定</span></span><br><span class="line"><span class="comment"> * @param pid       子进程的PID号</span></span><br><span class="line"><span class="comment"> * @param status    存放子进程的结束状态</span></span><br><span class="line"><span class="comment"> * @param options   函数控制选项</span></span><br><span class="line"><span class="comment"> * @return          由options的设定决定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span>* status, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure>

<p>在waitpid()函数中，参数pid有以下几种状态：</p>
<table>
<thead>
<tr>
<th align="center">pid</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&gt;0</td>
<td align="center">需要等待的子进程的PID号</td>
</tr>
<tr>
<td align="center">&#x3D;0</td>
<td align="center">等待与当前进程相同组的任何子进程进程</td>
</tr>
<tr>
<td align="center">&#x3D;-1</td>
<td align="center">等待任何子进程，与 wait() 相似</td>
</tr>
<tr>
<td align="center">&lt;-1</td>
<td align="center">等待进程组识别码为-pid的任何子进程</td>
</tr>
</tbody></table>
<p>options参数设定与函数行为的对应关系如下：</p>
<table>
<thead>
<tr>
<th align="center">options</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">WNOHANG</td>
<td align="center"><strong>非阻塞</strong>形式：若pid表示的子进程没有结束，则不予等待，返回0；若结束，则返回该子进程进程PID。发生错误返回-1。</td>
</tr>
<tr>
<td align="center">WUNTRACED</td>
<td align="center">若pid表示的子进程进入暂停状态，则立即返回子进程PID；若子进程处于结束状态，则不予理会。发生错误返回-1。</td>
</tr>
</tbody></table>
<h3 id="替换进程"><a href="#替换进程" class="headerlink" title="替换进程"></a>替换进程</h3><ol>
<li>函数<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* arg, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">const</span> <span class="type">char</span>* arg, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* arg, ..., <span class="type">char</span>* <span class="type">const</span> envp[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">char</span>* <span class="type">const</span> arg[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">char</span>* <span class="type">const</span> arg[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">char</span>* <span class="type">const</span> arg[], <span class="type">char</span>* <span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>exec函数族同样可以创建进程，与fork不同的是，exec创建的进程会取代父进程，甚至会占有父进程的PID，实打实的进程界的“鬼上身”。exec函数族中常用的两个函数分别是execl和execlp，下面将通过实例详细介绍。</p>
<ul>
<li>execl</li>
</ul>
<p>execl的第一个参数是执行文件的路径，第二个参数是该执行文件所需的输入（执行文件传参），和我们main(int argc, char** argv)中的argv部分一样，执行文件传参的第一个参数argv[0]一般是文件名（可以是任何字符，一般设置为文件名或命令名）。从第二个参数argv[1]起才是真正能够在执行文件中发挥作用的参数。当argv中出现NULL时则认为传参结束。一般情况下，执行文件都需要一个argv[0]文件名参数，也就是说argv至少需要一个非null参数（就是我们说的文件名），否则不能正确执行。<br>函数执行成功时无返回值，执行失败时返回-1.</p>
<p><strong>$ 执行一个不需要传参的执行文件</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="built_in">execl</span>(<span class="string">&quot;/bin/pwd&quot;</span>, <span class="string">&quot;pwd&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;==========================&quot;</span>&lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x2F;home&#x2F;torch&#x2F;code&#x2F;linux-c++&#x2F;clion&#x2F;cmake-build-debug</p>
</blockquote>
<p>在这个例子中，我们执行了pwd命令，他是一个不需要参数的命令，因此我们的argv[0]为命令名，并没有实际作用，但必须要有；argv[1]为NULL，表示传参结束。另外，程序并没有输出一串”&#x3D;”号，说明程序被替换为了pwd命令，原来的程序已经不存在了。</p>
<p><strong>$ 执行一个需要传参的执行文件</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="built_in">execl</span>(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls -al&quot;</span>, <span class="string">&quot;-al&quot;</span>, <span class="string">&quot;/etc/passwd&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x2F;home&#x2F;torch&#x2F;code&#x2F;linux-c++&#x2F;clion&#x2F;cmake-build-debug</p>
</blockquote>
<p>在这个例子中，我们执行了ls -al &#x2F;etc&#x2F;passwd命令，所以我们的argv[0]为”ls -al”并没有实际作用，但必须要有；argv[1]为”-al”，argv[2]为”&#x2F;etc&#x2F;passwd”，argv[3]为NULL，表示传参结束。</p>
<p><strong>$ 如果argv没有任何参数会发生什么？</strong></p>
<p>我们首先写一个被执行程序，并把他编译为test.out，然后执行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * file name: test.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;argc: &quot;</span>&lt;&lt; argc&lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;argc;i++)&#123;</span><br><span class="line">        cout&lt;&lt; argv[i]&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>argc: 1<br>.&#x2F;test.out</p>
</blockquote>
<p>系统自动传递了一个文件名参数给我们的程序，因此检测到一个参数，参数为文件名。</p>
<p>我们再写一个程序通过execl函数执行我们的test.out</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="built_in">execl</span>(<span class="string">&quot;./test.out&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>argc：1    </p>
</blockquote>
<p>可以看到，当我们不传递任何参数给执行文件时，编译时会给我们警告，并且函数会自动传递一个空字符参数给我们的执行文件。我们对程序进行修改：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="built_in">execl</span>(<span class="string">&quot;./test.out&quot;</span>, <span class="string">&quot;test.out&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>argc：1<br>test.out</p>
</blockquote>
<p>此时编译器不再发出警告，test.out获得了我们传递给他的”test.out”字符串。</p>
<ul>
<li>execlp</li>
</ul>
<p>execlp的第一个参数是环境变量中的文件名，第二个参数和execl一致。相比于execl，execlp专门用来执行已经加入到环境变量中的程序。</p>
<p><strong>$ 示例</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="built_in">execlp</span>(<span class="string">&quot;pwd&quot;</span>, <span class="string">&quot;pwd&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>&#x2F;home&#x2F;torch&#x2F;code&#x2F;linux-c++&#x2F;clion&#x2F;cmake-build-debug</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/19/linux/linux%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/Linux%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B-C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何先生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="北国回忆录">
      <meta itemprop="description" content="东拼西凑、杂七杂八">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 北国回忆录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/19/linux/linux%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/Linux%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B-C++/" class="post-title-link" itemprop="url">Linux文件编程-C++</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-19 15:57:48" itemprop="dateCreated datePublished" datetime="2023-09-19T15:57:48+08:00">2023-09-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-07-30 19:20:21" itemprop="dateModified" datetime="2024-07-30T19:20:21+08:00">2024-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="流的概念"><a href="#流的概念" class="headerlink" title="流的概念"></a>流的概念</h2><p>在C++语言中，数据的输入和输出（I&#x2F;O）包括对标准输入设备（键盘）和标准输出设备（显示器）、外存磁盘文件、内存中指定字符串储存空间进行输入和输出三个方面，分别简称为标准I&#x2F;O，文件I&#x2F;O，串I&#x2F;O。C++将写入文件和读取文件抽象的说为<strong>文件流</strong>，三种I&#x2F;O对应着三种文件流，分别是标准I&#x2F;O流，文件I&#x2F;O流和字符串I&#x2F;O流。</p>
<table>
<thead>
<tr>
<th align="center">流</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">标准I&#x2F;O流</td>
<td align="center">内存与标准输入输出设备之间的信息传递</td>
</tr>
<tr>
<td align="center">文件I&#x2F;O流</td>
<td align="center">内存与外部文件之间的信息传递</td>
</tr>
<tr>
<td align="center">字符串I&#x2F;O流</td>
<td align="center">内存变量与表示字符串流的数组之间的传递</td>
</tr>
</tbody></table>
<h2 id="流的类库"><a href="#流的类库" class="headerlink" title="流的类库"></a>流的类库</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">头文件’&lt;fstream&gt;‘所提供的文件流</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ifstream</td>
<td align="center">输入文件流，用于从文件读取信息</td>
</tr>
<tr>
<td align="center">ofstream</td>
<td align="center">输出文件流，用于创建文件和向文件写入信息</td>
</tr>
<tr>
<td align="center">fstream</td>
<td align="center">文件流，包含输入文件流和输出文件流的功能</td>
</tr>
</tbody></table>
<blockquote>
<p>虽然fstream看起来很全能，但是实际应用中并不好用。ifstream和ofstream再打开文件时如果文件不存在则会创建文件，而fstream当文件不存在时虽然不报错，但是后续对文件的操作无法生效。</p>
</blockquote>
<h2 id="流操作"><a href="#流操作" class="headerlink" title="流操作"></a>流操作</h2><blockquote>
<p>所有代码都是示意代码，并不能运行。</p>
</blockquote>
<h3 id="基础文件I-O"><a href="#基础文件I-O" class="headerlink" title="基础文件I&#x2F;O"></a>基础文件I&#x2F;O</h3><p>这里我们以ifstream为例，ofstream具有相同的成员函数和操作方式。</p>
<ul>
<li><p>打开文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种打开文件的方式——构造函数</span></span><br><span class="line"><span class="function">ifstream <span class="title">infile</span><span class="params">(file_name, open_mode)</span></span>;</span><br><span class="line"><span class="comment">// 第二种打开文件的方式——成员函数</span></span><br><span class="line">ifstream infile;</span><br><span class="line">infile.<span class="built_in">open</span>(file_name, open_mode);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">open_mode[^1]</th>
<th align="center">速记</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ios::out</td>
<td align="center">output (输出)</td>
<td align="center">指定文件的打开方式为写入，一般为必要参数，但在使用 ofstream 对象时，为默认参数</td>
</tr>
<tr>
<td align="center">ios::app</td>
<td align="center">append (添加)</td>
<td align="center">当打开文件用于写入时，会在已有数据之后写入，不覆盖原有内容。使用此种打开方式，每次写入都会置于文件末尾，即便之前更改了位置。</td>
</tr>
<tr>
<td align="center">ios::trunc</td>
<td align="center">truncate (截断)</td>
<td align="center">当打开文件时，如果文件存在内容则清空文件内容</td>
</tr>
<tr>
<td align="center">ios::ate</td>
<td align="center">at end (在结束处)</td>
<td align="center">以写入方式打开文件，并将文件指针置于末尾。与 ios::app不同之处为，如果改变了指针位置，写入不一定会在文件末尾</td>
</tr>
</tbody></table>
</li>
<li><p>判断文件是否打开成功</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ifstream infile;</span><br><span class="line">infile.<span class="built_in">open</span>(file_name, open_mode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">if</span>(infile) &#123;<span class="comment">/*文件打开成功*/</span>&#125;;</span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">if</span>(infile.<span class="built_in">is_open</span>()) &#123;<span class="comment">/*文件打开成功*/</span>&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>关闭文件</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ifstream infile;</span><br><span class="line"></span><br><span class="line">infile.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>读取文件</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>       <span class="comment">// getline函数需要包含头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ifstream infile;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取一行内容，遇到\n停止，读取成功返回true，遇到文件结尾返回false</span></span><br><span class="line"><span class="built_in">getline</span>(infile, <span class="type">char</span>* c);</span><br><span class="line"><span class="comment">// 读取一个字符，读取成功返回true，遇到文件结尾返回false</span></span><br><span class="line">infile.<span class="built_in">get</span>(<span class="type">char</span> c);</span><br><span class="line"><span class="comment">// 读取内容直到分隔符（空格、换行...）</span></span><br><span class="line">infile&gt;&gt; <span class="type">char</span>* c;</span><br></pre></td></tr></table></figure>

<ul>
<li>写入文件</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ofstream outfile;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入字符串c中的全部内容</span></span><br><span class="line">outfile&lt;&lt; <span class="type">char</span>* c;</span><br><span class="line"><span class="comment">// 写入一个字符</span></span><br><span class="line">outfile.<span class="built_in">put</span>(<span class="type">char</span> c);</span><br></pre></td></tr></table></figure>

<ul>
<li>获取文件偏移量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ofstream outfile;</span><br><span class="line">ifstream infile;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ofstream和ifstream的获取文件偏移的方法不可混用</span></span><br><span class="line"><span class="comment">// 两个函数都返回所处位置处的字符在文件中的编号位置</span></span><br><span class="line">outfile.<span class="built_in">tellp</span>();</span><br><span class="line">infile.<span class="built_in">tellg</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>设置文件偏移量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ofstream outfile;</span><br><span class="line">ifstream infile;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ofstream和ifstream的设置文件偏移的方法不可混用</span></span><br><span class="line">outfile.<span class="built_in">seekp</span>(streampos pos);                       <span class="comment">// pos为字符在文件中的编号位置</span></span><br><span class="line">outfile.<span class="built_in">seekp</span>(streamoff off, ios::seek_dir dir);    <span class="comment">// dir为起始搜索位置，off为相对于dir向文件末尾的偏移量</span></span><br><span class="line"></span><br><span class="line">outfile.<span class="built_in">seekp</span>(streampos pos);                       <span class="comment">// pos为字符在文件中的编号位置</span></span><br><span class="line">outfile.<span class="built_in">seekp</span>(streamoff off, ios::seek_dir dir);    <span class="comment">// dir为起始搜索位置，off为相对于dir向文件末尾的偏移量</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">dir</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ios::beg</td>
<td align="center">文件流的起始位置（默认值）</td>
</tr>
<tr>
<td align="center">ios::cur</td>
<td align="center">文件流的当前位置</td>
</tr>
<tr>
<td align="center">ios::end</td>
<td align="center">文件流的结束位置</td>
</tr>
</tbody></table>
<blockquote>
<p>由于ios是ifstream和ofstream的一个父类，所以也可以使用ifstream::beg等来使用这些枚举</p>
</blockquote>
<ul>
<li>文件状态判断</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ifstream infile;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写的过程中出错则返回true</span></span><br><span class="line">infile.<span class="built_in">bad</span>();</span><br><span class="line"><span class="comment">// 包含bad的情况，另外，读入的数据与容器格式不符时也会报错，例如想读入一个整数却得到一个字母</span></span><br><span class="line">infile.<span class="built_in">fail</span>();</span><br><span class="line"><span class="comment">// 文件达到末尾时返回true</span></span><br><span class="line">infile.<span class="built_in">eof</span>();</span><br><span class="line"><span class="comment">// 文件没有读写和格式不符错误，且没有达到文件末尾。即fail和eof都是false时，该函数为true</span></span><br><span class="line">infile.<span class="built_in">good</span>();</span><br></pre></td></tr></table></figure>

<h3 id="更精细的文件I-O"><a href="#更精细的文件I-O" class="headerlink" title="更精细的文件I&#x2F;O"></a>更精细的文件I&#x2F;O</h3><ul>
<li>获得文件的大小</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ifstream infile;</span><br><span class="line"></span><br><span class="line">infile.<span class="built_in">seekg</span>(<span class="number">0</span>, infile.end);</span><br><span class="line"><span class="type">int</span> file_length = infile.<span class="built_in">tellg</span>();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如若想获得某一部分的大小，则可以该部分内容的起始位置和终止位置的序号相减。</p>
</blockquote>
<ul>
<li>将文件读入内存</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ifstream infile;</span><br><span class="line"></span><br><span class="line">infile.<span class="built_in">seekg</span>(<span class="number">0</span>, infile.end);</span><br><span class="line"><span class="type">int</span> file_length = infile.<span class="built_in">tellg</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[file_length];</span><br><span class="line">infile.<span class="built_in">read</span>(buffer, file_length);</span><br><span class="line"><span class="keyword">delete</span>[] buffer;</span><br></pre></td></tr></table></figure>

<ul>
<li>将内存写入文件</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先将内容读入到内存中</span></span><br><span class="line">ifstream infile;</span><br><span class="line"></span><br><span class="line">infile.<span class="built_in">seekg</span>(<span class="number">0</span>, infile.end);</span><br><span class="line"><span class="type">int</span> file_length = infile.<span class="built_in">tellg</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[file_length];</span><br><span class="line">infile.<span class="built_in">read</span>(buffer, file_length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再将内容写入到文件中</span></span><br><span class="line">ofstream outfile;</span><br><span class="line">outfile.<span class="built_in">write</span>(buffer, file_length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] buffer;</span><br></pre></td></tr></table></figure>


<p>[^1]:<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44488341/article/details/131466397">【C++】标准库 - 文件的读写 ifstream, ofstream, fstream</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/19/linux/linux%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/Linux%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84(mmap)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何先生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="北国回忆录">
      <meta itemprop="description" content="东拼西凑、杂七杂八">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 北国回忆录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/19/linux/linux%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/Linux%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84(mmap)/" class="post-title-link" itemprop="url">Linux文件编程-文件的内存映射(mmap)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-19 14:17:46" itemprop="dateCreated datePublished" datetime="2023-09-19T14:17:46+08:00">2023-09-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-07-30 19:20:12" itemprop="dateModified" datetime="2024-07-30T19:20:12+08:00">2024-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="文件的内存映射"><a href="#文件的内存映射" class="headerlink" title="文件的内存映射"></a>文件的内存映射</h2><h3 id="为什么要将文件映射到内存？"><a href="#为什么要将文件映射到内存？" class="headerlink" title="为什么要将文件映射到内存？"></a>为什么要将文件映射到内存？</h3><p>频繁地读取和写入文件十分耗时，如果能将文件加载到内存中，则读取和写入的主体就变成了程序和内存而不是程序和文件，大大减小时间开销。另外，将文件映射到内存中并由多个进程访问，能够实现进程之间共享内存。</p>
<h3 id="函数和主要参数"><a href="#函数和主要参数" class="headerlink" title="函数和主要参数"></a>函数和主要参数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param start     映射内存的起始地址，通常设为NULL或0，表示由系统自动分配</span></span><br><span class="line"><span class="comment"> * @param length    写入数据的长度</span></span><br><span class="line"><span class="comment"> * @param prot      映射区的保护方式</span></span><br><span class="line"><span class="comment"> * @param flags     映射区类型以及是否共享</span></span><br><span class="line"><span class="comment"> * @param fd        文件描述符</span></span><br><span class="line"><span class="comment"> * @param offset    映射数据在文件中的起点 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* start, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">prot</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PROT_EXEC</td>
<td align="center">映射区可被执行</td>
</tr>
<tr>
<td align="center">PROT_READ</td>
<td align="center">映射区可被读取</td>
</tr>
<tr>
<td align="center">PROT_WRITE</td>
<td align="center">映射区可被写入</td>
</tr>
<tr>
<td align="center">PROT_NONE</td>
<td align="center">映射区不可访问</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">flags</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">MAP_FIXED</td>
<td align="center">在指定参数start时使用，若无法映射到start区域，则映射失败</td>
</tr>
<tr>
<td align="center">MAP_SHARED</td>
<td align="center">共享映射区域，对映射区域写入将会写入到原文件中</td>
</tr>
<tr>
<td align="center">MAP_PRIVATE</td>
<td align="center">为进程创建一个独享映射，修改映射区域不会保存到原文件中</td>
</tr>
<tr>
<td align="center">MAP_ANONYMOUS</td>
<td align="center">建立匿名映射。映射区不与任何文件关联，无法共享</td>
</tr>
<tr>
<td align="center">MAP_DENYWRITE</td>
<td align="center">对文件的写入操作将被禁止</td>
</tr>
<tr>
<td align="center">MAP_LOCKED</td>
<td align="center">锁定映射区，防止映射区的内存被交换</td>
</tr>
</tbody></table>
<p>flag必须为<strong>MAP_SHARED</strong>或<strong>MAP_PRIVATE</strong>二者之一，其他类型需与此二者搭配使用。</p>
<h3 id="通过内存映射读取文件"><a href="#通过内存映射读取文件" class="headerlink" title="通过内存映射读取文件"></a>通过内存映射读取文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDWR|O_CREAT, S_IRUSR|S_IWUSR);</span><br><span class="line">    <span class="type">char</span>* mappedMem, * p;</span><br><span class="line">    <span class="type">int</span> flength = <span class="number">1024</span>;</span><br><span class="line">    <span class="type">void</span>* startAddr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        flength = <span class="built_in">lseek</span>(fd, <span class="number">1</span>, SEEK_END);</span><br><span class="line">        <span class="built_in">write</span>(fd, <span class="string">&quot;\0&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">lseek</span>(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">        mappedMem = (<span class="type">char</span>*)<span class="built_in">mmap</span>(startAddr, flength, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, mappedMem);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="built_in">munmap</span>(mappedMem, flength);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>I have an apple.</p>
</blockquote>
<p>先向文件中追加了一个字符’\0’，来满足<strong>printf</strong>打印所需。在<strong>mmap</strong>函数中，我们设置prot参数为<strong>PROT_READ</strong>，表示这块内存映射可以读取；设置flags参数为<strong>MAP_PRIVATE</strong>，表示进程独享该内存映射，并且不将内存映射中的修改写入原文件（时间上此处由于prot参数的问题也无法修改）。</p>
<p>执行后成功将文件内容打印。</p>
<h3 id="通过内存映射修改文件"><a href="#通过内存映射修改文件" class="headerlink" title="通过内存映射修改文件"></a>通过内存映射修改文件</h3><p>此处只需要修改<a href="#%E9%80%9A%E8%BF%87%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6">通过内存映射读取文件</a>中的prot和flag参数，就可以让我们具有权限去实现修改内存映射，并将内存映射保存到原文件中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDWR|O_CREAT, S_IRUSR|S_IWUSR);</span><br><span class="line">    <span class="type">char</span>* mappedMem, * p;</span><br><span class="line">    <span class="type">int</span> flength = <span class="number">1024</span>;</span><br><span class="line">    <span class="type">void</span>* startAddr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        flength = <span class="built_in">lseek</span>(fd, <span class="number">1</span>, SEEK_END);</span><br><span class="line">        <span class="built_in">write</span>(fd, <span class="string">&quot;\0&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">lseek</span>(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">        mappedMem = (<span class="type">char</span>*)<span class="built_in">mmap</span>(startAddr, flength, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, mappedMem);</span><br><span class="line"></span><br><span class="line">        p = <span class="built_in">strstr</span>(mappedMem, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(p, <span class="string">&quot;linux&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="built_in">munmap</span>(mappedMem, flength);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>I have an apple.</p>
</blockquote>
<p>之后在终端中执行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> myFile.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>I have an linux.</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/19/linux/linux%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/Linux%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6%E9%94%81%E5%AE%9A(fcntl)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何先生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="北国回忆录">
      <meta itemprop="description" content="东拼西凑、杂七杂八">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 北国回忆录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/19/linux/linux%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/Linux%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6%E9%94%81%E5%AE%9A(fcntl)/" class="post-title-link" itemprop="url">Linux文件编程-文件锁定(fcntl)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-19 12:15:20" itemprop="dateCreated datePublished" datetime="2023-09-19T12:15:20+08:00">2023-09-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-07-30 19:20:11" itemprop="dateModified" datetime="2024-07-30T19:20:11+08:00">2024-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="文件锁定"><a href="#文件锁定" class="headerlink" title="文件锁定"></a>文件锁定</h2><p>当多个用户同时操作同一个文件时，为了避免共享资源产生<strong>竞争状态</strong>，我们可以给文件上锁。文件锁分为<strong>建议性锁</strong>和<strong>强制性锁</strong>。建议性锁会给文件设置一个标志位，但是，如果对文件操作之前不对该标志位进行检测，那么建议性锁就会形同虚设，其他进程依旧可以对文件进行操作。而强制性锁会让上锁的进程“霸占”这个文件的一些权限，比如一个进程A对文件F设置了一个只允许读操作的强制性锁（读取锁），那么进程B就只能对文件F进行读取，而不能写入或执行，这种锁定状态会一直持续到进程A给文件F解锁。强制性锁可以避免对文件的破坏性操作。当我们使用open、read、write等函数操作文件时，内核都会检测该文件是否被加了强制性锁，如果是，则会导致操作失败。除了锁定文件，文件的某一个状态记录也可以被上锁，称为<strong>记录锁</strong>。</p>
<h3 id="函数和参数"><a href="#函数和参数" class="headerlink" title="函数和参数"></a>函数和参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 默认建议性锁，开启强制性锁需要对系统进行设置</span></span><br><span class="line"><span class="comment"> * @param fd    文件描述符</span></span><br><span class="line"><span class="comment"> * @param cmd   上锁的方式</span></span><br><span class="line"><span class="comment"> * @param lock  上各种锁，锁住哪里</span></span><br><span class="line"><span class="comment"> * @return int  执行成功返回0，执行失败返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, <span class="keyword">struct</span> flock* lock)</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">cmd</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">F_GETLK</td>
<td align="center">根据lock描述，决定是否上锁</td>
</tr>
<tr>
<td align="center">F_SETLK</td>
<td align="center">根据lock描述，设置锁</td>
</tr>
</tbody></table>
<p>结构体<strong>flock</strong>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flock</span>&#123;</span></span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> l_type;   <span class="comment">// 锁定状态</span></span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> l_whence; <span class="comment">// 锁定的起始位置</span></span><br><span class="line">    <span class="type">off_t</span>     l_start;  <span class="comment">// 起始位置相对于l_whence的偏移量</span></span><br><span class="line">    <span class="type">off_t</span>     l_len;    <span class="comment">// 锁定区域的大小</span></span><br><span class="line">    <span class="type">pid_t</span>     l_pid;    <span class="comment">// 执行锁定动作的进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">l_type</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">F_RDLCK</td>
<td align="center">读取锁，多个进程可以同时建立读取锁</td>
</tr>
<tr>
<td align="center">F_WRLCK</td>
<td align="center">写入锁，任何时刻只有一个进程可以建立写入锁</td>
</tr>
<tr>
<td align="center">F_UNLCK</td>
<td align="center">解除锁定</td>
</tr>
</tbody></table>
<h3 id="建议性锁"><a href="#建议性锁" class="headerlink" title="建议性锁"></a>建议性锁</h3><p>为了测试建议性锁，我们需要两个程序，程序”lockFile.cpp”负责给文件上锁，并持续占用文件；程序”writeFile.cpp”负责检测建议锁，并向文件中写入内容。由于linux默认建议性锁，所以不需要对系统进行额外配置。<br>“lockFile.cpp”的内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * file name:   lockFile.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="type">int</span> res, fd = open(<span class="string">&quot;myFile.txt&quot;</span>, O_RDWR|O_CREAT, S_IRWXU);</span><br><span class="line">    <span class="keyword">if</span>(fd &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        lock.l_type     = F_WRLCK;          <span class="comment">// 写入锁</span></span><br><span class="line">        lock.l_whence   = SEEK_SET;         <span class="comment">// 文件起始位置</span></span><br><span class="line">        lock.l_start    = <span class="number">0</span>;                <span class="comment">// 不偏移</span></span><br><span class="line">        lock.l_len      = <span class="number">0</span>;                <span class="comment">// 当len=0时代表锁定到文件的末尾；len=非零正整数时代表锁定的字符数</span></span><br><span class="line">        lock.l_pid      = getpid();         <span class="comment">// 获得当前进程pid号</span></span><br><span class="line"></span><br><span class="line">        res = fcntl(fd, F_SETLK, &amp;lock);    <span class="comment">// 设置写入锁，不允许其他进程写入</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(res==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;file has been locked. pid:%d\n&quot;</span>, getpid());</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>);                    <span class="comment">// 保持锁定占用状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序后，终端会陷入<strong>while</strong>函数中，同时输出该进程的<strong>PID值为1078</strong>。<br>我们打开另一个终端，键入命令，查看该进程是否对文件加锁：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">cat</span> /proc/locks | grep 1078</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2: POSIX  ADVISORY  WRITE 1078 08:20:3446 0 EOF</p>
</blockquote>
<p>从输出中可以看出，该进程加了一个写入锁。</p>
<p>而后，我们通过”writeFile.cpp”文件向”myFile.txt”中写入内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="type">int</span> res, fd = open(<span class="string">&quot;myFile.txt&quot;</span>, O_RDWR|O_CREAT, S_IRWXU);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">char</span> buf[] = <span class="string">&quot;I have an apple.&quot;</span>;</span><br><span class="line">        <span class="type">int</span> count  = <span class="built_in">strlen</span>(buf);</span><br><span class="line">        <span class="type">int</span> size   = write(fd, buf, count);</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;写入失败.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;写入成功.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后发现，可以向”myFile.txt”中写入内容。这就证明了，虽然我们给文件加了写入锁，但由于该锁的性质是建议锁，所以其他进程仍然可以向文件中写入内容。</p>
<h3 id="强制性锁"><a href="#强制性锁" class="headerlink" title="强制性锁"></a>强制性锁</h3><p>若要使用强制性锁，需要在root权限下通过mount命令，用-o mand选项来打开该机制。</p>
<p>我们先将”lockFile.cpp”程序终止掉，然后在终端中执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mount -o remount,mand /</span><br></pre></td></tr></table></figure>

<p>然后重复<a href="#%E5%BB%BA%E8%AE%AE%E6%80%A7%E9%94%81">建议性锁</a>的步骤，发现”writeFile.cpp”无法向”myFile.txt”中写入内容。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/18/linux/linux%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/Linux%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何先生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="北国回忆录">
      <meta itemprop="description" content="东拼西凑、杂七杂八">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 北国回忆录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/18/linux/linux%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/Linux%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81/" class="post-title-link" itemprop="url">Linux文件编程-文件状态</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-18 16:42:32" itemprop="dateCreated datePublished" datetime="2023-09-18T16:42:32+08:00">2023-09-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-07-30 19:20:10" itemprop="dateModified" datetime="2024-07-30T19:20:10+08:00">2024-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>文件的状态被储存在一个<strong>stat结构体</strong>中，它所包含的内容如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stat</span>&#123;</span><br><span class="line">    <span class="type">mdoe_t</span>    st_mode;    <span class="comment">// 文件对应的模式、文件、目录等</span></span><br><span class="line">    <span class="type">ino_t</span>     st_ino;     <span class="comment">// inode节点号</span></span><br><span class="line">    <span class="type">dev_t</span>     st_dev;     <span class="comment">// 设备号码</span></span><br><span class="line">    <span class="type">dev_t</span>     st_rdev;    <span class="comment">// 特殊设备号码</span></span><br><span class="line">    <span class="type">nlink_t</span>   st_nlink;   <span class="comment">// 文件的连接数</span></span><br><span class="line">    <span class="type">uid_t</span>     st_uid;     <span class="comment">// 文件所有者</span></span><br><span class="line">    <span class="type">gid_t</span>     st_git;     <span class="comment">// 文件所有者对应的组</span></span><br><span class="line">    <span class="type">off_t</span>     st_size;    <span class="comment">// 文件的大小字节数</span></span><br><span class="line">    <span class="type">time_t</span>    st_atime;   <span class="comment">// 文件最后被访问的时间</span></span><br><span class="line">    <span class="type">time_t</span>    st_mtime;   <span class="comment">// 文件内容最后被修改的时间</span></span><br><span class="line">    <span class="type">time_t</span>    st_ctime;   <span class="comment">// 文件状态改变的时间</span></span><br><span class="line">    <span class="type">blksize_t</span> st_blksize; <span class="comment">// 文件内容对应的块大小</span></span><br><span class="line">    <span class="type">blkcnt_t</span>  st_blocks;  <span class="comment">// 文件内容对应的块数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们有三种方法来获取文件状态，他们分别是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @description 若文件路径是一个链接的路径，链接所指向文件的信息</span></span><br><span class="line"><span class="comment">* @param path  文件路径</span></span><br><span class="line"><span class="comment">* @param buf   文件状态结构体指针</span></span><br><span class="line"><span class="comment">* @return int  执行成功返回0，执行失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> stat *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @param fd    文件描述符</span></span><br><span class="line"><span class="comment">* @param buf   文件状态结构体指针</span></span><br><span class="line"><span class="comment">* @return int  执行成功返回0，执行失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @description 若文件路径是一个链接的路径，则获得该链接本身的信息</span></span><br><span class="line"><span class="comment">* @param path  文件路径</span></span><br><span class="line"><span class="comment">* @param buf   文件状态结构体指针</span></span><br><span class="line"><span class="comment">* @return int  执行成功返回0，执行失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> stat *buf)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>为了说明stat和lstat在链接文件上的不同表现，我们在演示目录下创建了”1.txt”和他的链接文件”1.txt.link”，目录结构如下：</p>
<blockquote>
<p>.<br>├── 1.txt<br>├── 1.txt.link -&gt; 1.txt<br>└── example.cpp<br>0 directories, 3 files  </p>
</blockquote>
<p>其中”example.cpp”是我们的示例程序，内容如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printFileStat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filePath, <span class="type">const</span> <span class="type">char</span>* linkPath)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printFileLstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filePath, <span class="type">const</span> <span class="type">char</span>* linkPath)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printFileFstat</span><span class="params">(<span class="type">const</span> <span class="type">int</span> fdf, <span class="type">const</span> <span class="type">int</span> fdl)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> linkPath[] = <span class="string">&quot;./1.txt.link&quot;</span>;</span><br><span class="line">    <span class="type">char</span> filePath[] = <span class="string">&quot;./1.txt&quot;</span>;</span><br><span class="line">    <span class="type">int</span> fdf = <span class="built_in">open</span>(filePath, O_RDONLY);</span><br><span class="line">    <span class="type">int</span> fdl = <span class="built_in">open</span>(linkPath, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fdf==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fail to get file fd.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fdl==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fail to get link fd.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;file fd:%d, link fd:%d.\n&quot;</span>, fdf, fdl);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=====stat=====\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printFileStat</span>(filePath, linkPath);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=====lstat=====\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printFileLstat</span>(filePath, linkPath);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=====fstat=====\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printFileFstat</span>(fdf, fdl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">close</span>(fdf)==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fail to close file %s.\n&quot;</span>, filePath);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">close</span>(fdl)==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fail to close file %s.\n&quot;</span>, linkPath);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printFileStat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filePath, <span class="type">const</span> <span class="type">char</span>* linkPath)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> st_file;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> st_link;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">stat</span>(filePath, &amp;st_file)==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fail to get the state of file %s\n&quot;</span>, filePath);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;==&gt;file:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file length:%ld\nmod time:%ld\nnode:%ld\nmode:%d\n&quot;</span>, st_file.st_size, st_file.st_mtime, st_file.st_ino, st_file.st_mode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">stat</span>(linkPath, &amp;st_link)==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fail to get the state of file %s\n&quot;</span>, linkPath);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;==&gt;link:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file length:%ld\nmod time:%ld\nnode:%ld\nmode:%d\n&quot;</span>, st_link.st_size, st_link.st_mtime, st_link.st_ino, st_link.st_mode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printFileLstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filePath, <span class="type">const</span> <span class="type">char</span>* linkPath)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> st_file;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> st_link;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">lstat</span>(filePath, &amp;st_file)==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fail to get the state of file %s\n&quot;</span>, filePath);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;==&gt;file:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file length:%ld\nmod time:%ld\nnode:%ld\nmode:%d\n&quot;</span>, st_file.st_size, st_file.st_mtime, st_file.st_ino, st_file.st_mode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">lstat</span>(linkPath, &amp;st_link)==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fail to get the state of file %s\n&quot;</span>, linkPath);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;==&gt;link:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file length:%ld\nmod time:%ld\nnode:%ld\nmode:%d\n&quot;</span>, st_link.st_size, st_link.st_mtime, st_link.st_ino, st_link.st_mode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printFileFstat</span><span class="params">(<span class="type">const</span> <span class="type">int</span> fdf, <span class="type">const</span> <span class="type">int</span> fdl)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> st_file;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> st_link;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fstat</span>(fdf, &amp;st_file)==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fail to get the state of file, fdf:%d\n&quot;</span>, fdf);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;==&gt;file:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file length:%ld\nmod time:%ld\nnode:%ld\nmode:%d\n&quot;</span>, st_file.st_size, st_file.st_mtime, st_file.st_ino, st_file.st_mode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fstat</span>(fdl, &amp;st_link)==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fail to get the state of file, fdl:%d\n&quot;</span>, fdl);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;==&gt;link:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file length:%ld\nmod time:%ld\nnode:%ld\nmode:%d\n&quot;</span>, st_link.st_size, st_link.st_mtime, st_link.st_ino, st_link.st_mode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译执行后的输出如下：</p>
<blockquote>
<p>file fd:3, link fd:4.<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;stat&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>&#x3D;&#x3D;&gt;file:<br>file length:0<br>mod time:1695094117<br>node:444<br>mode:33188<br>&#x3D;&#x3D;&gt;link:<br>file length:0<br>mod time:1695094117<br>node:444<br>mode:33188<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;lstat&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>&#x3D;&#x3D;&gt;file:<br>file length:0<br>mod time:1695094117<br>node:444<br>mode:33188<br>&#x3D;&#x3D;&gt;link:<br>file length:5<br>mod time:1695094150<br>node:456<br>mode:41471<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;fstat&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>&#x3D;&#x3D;&gt;file:<br>file length:0<br>mod time:1695094117<br>node:444<br>mode:33188<br>&#x3D;&#x3D;&gt;link:<br>file length:0<br>mod time:1695094117<br>node:444<br>mode:33188  </p>
</blockquote>
<p>可以看到</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>stat</strong></td>
<td align="center">当输入为链接路径时，输出为链接所指向的文件的状态。</td>
</tr>
<tr>
<td align="center"><strong>lstat</strong></td>
<td align="center">当输入为链接路径时，输出为链接文件本身的状态。</td>
</tr>
<tr>
<td align="center"><strong>fstat</strong></td>
<td align="center">当输入为链接文件描述符时，输出为链接所指向的文件的状态。</td>
</tr>
</tbody></table>
<p>另外，基于三个函数执行成功返回0，执行失败返回-1的特点，可以用来判断文件是否存在。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/16/linux/linux%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/Linux%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何先生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="北国回忆录">
      <meta itemprop="description" content="东拼西凑、杂七杂八">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 北国回忆录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/16/linux/linux%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/Linux%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80IO/" class="post-title-link" itemprop="url">Linux文件编程-基础IO</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-16 16:27:32" itemprop="dateCreated datePublished" datetime="2023-09-16T16:27:32+08:00">2023-09-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-07-30 19:19:25" itemprop="dateModified" datetime="2024-07-30T19:19:25+08:00">2024-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>文件描述符是计算机操作文件时所用的符号，上文中所提到的i节点是计算机查找文件时所用的符号。那么，既然已经有i节点号可以唯一确定文件，为什么呢还要用文件描述符呢？一个文件可以被同一个用户或者不同用户同时打开一次或多次，这就造成文件需要有一个结构能够分别记录每一次打开后的操作，比如光标位置。因此，linux系统使用了文件描述符来解决这个问题。当打开或者创建一个文件的时候，内核就会向进程返回一个文件描述符（非负整数），所有对文件的后续操作都通过该文件描述符来完成。一个i节点可以对应多个文件描述符，每一个文件描述符都代表了一次对该文件的打开操作。系统的文件描述符是有限的，打开文件后一定要记得关闭，及时将文件描述符释放。</p>
<h2 id="文件的基础IO"><a href="#文件的基础IO" class="headerlink" title="文件的基础IO"></a>文件的基础IO</h2><h3 id="文件的创建与打开"><a href="#文件的创建与打开" class="headerlink" title="文件的创建与打开"></a>文件的创建与打开</h3><ol>
<li><p>函数</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @param pathname  文件的路径</span></span><br><span class="line"><span class="comment">* @param flags     打开方式</span></span><br><span class="line"><span class="comment">* @param mode      创建文件时，设置文件的权限 </span></span><br><span class="line"><span class="comment">* @return int      打开/创建成功时返回文件描述符，否则返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span></span>;   <span class="comment">// 创建文件</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span></span>;                <span class="comment">// 打开文件</span></span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">flags|意义</span><br><span class="line">|:---:|:---:|</span><br><span class="line">O_RDONLY|只读</span><br><span class="line">O_WRONLY|只写</span><br><span class="line">O_RDWR|读写</span><br><span class="line">O_APPEND|追加</span><br><span class="line">O_CREAT|如果文件不存在则创建</span><br><span class="line">O_EXCL|如果使用O_CREAT时文件已经存在，则强制open失败</span><br><span class="line">O_TRUNC|打开文件时清空文件内容</span><br><span class="line">O_DSYNC|每次写入时等待数据写到磁盘上</span><br><span class="line">O_RSYNC|每次读取时，等到相同部分先写到磁盘上</span><br><span class="line">O_SYNC|以同步方式写入文件，强制刷新内核缓冲区到输出文件</span><br><span class="line"></span><br><span class="line">mode|意义</span><br><span class="line">|:---:|:---:|</span><br><span class="line">S_IRUSR|文件所有者的读权限|</span><br><span class="line">S_IWUSR|文件所有者的写权限</span><br><span class="line">S_IXUSR|文件所有者的执行权限</span><br><span class="line">S_IRWXU|文件所有者的读写和执行权限</span><br><span class="line">S_IRGRP|文件用户组的读权限</span><br><span class="line">S_IWGRP|文件用户组的写权限</span><br><span class="line">S_IXGRP|文件用户组的执行权限</span><br><span class="line">S_IRWXG|文件用户组的读写执行权限</span><br><span class="line">S_IROTH|文件其他用户组的读权限</span><br><span class="line">S_IWOTH|文件其他用户组的写权限</span><br><span class="line">S_IXOTH|文件其他用户组的执行权限</span><br><span class="line">S_IRWXO|文件其他用户组的读写和执行权限</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flags的选项可以通过 | 联合使用，例如:</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span>             <span class="comment">// mode宏的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>               <span class="comment">// flags宏的头文件</span></span></span><br><span class="line"><span class="type">int</span> flags = O_CREAT | O_RDONLY;  <span class="comment">// 如果文件不存在则创建文件，并以只读的方式打开文件</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>演示</p>
</li>
</ol>
<ul>
<li><p>创建文件时不配置mode权限会发生什么</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* name:     20230918_1.cpp</span></span><br><span class="line"><span class="comment">* funtion:  无权限文件创建</span></span><br><span class="line"><span class="comment">* Date:     2023-09-18</span></span><br><span class="line"><span class="comment">* Author:   Torch-HXM</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">char</span> filePath[] = <span class="string">&quot;./20230918_1.txt&quot;</span>;</span><br><span class="line"><span class="type">int</span> flags = O_CREAT | O_RDWR;</span><br><span class="line"><span class="type">int</span> fd = <span class="built_in">open</span>(filePath, flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(fd)&#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;create file successfully.&quot;</span>&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;file created failed.&quot;</span>&lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  在上面的代码中，由于我们没有文件”.&#x2F;20230918_1.txt”，故而<strong>flags</strong>的O_CREAT部分会让系统创建这个文件，O_RDWR让系统以读写的方式打开文件。我们将代码编译并执行</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ g++ 20230918_1.cpp</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">20230918_1.cpp  a.out</span><br><span class="line">$ ./a.out</span><br><span class="line">create file successfully.</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">20230918_1.cpp  20230918_1.txt  a.out</span><br></pre></td></tr></table></figure>

<p>  可以看到文件被成功的创建，接下来我们查看文件内容：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> 20230918_1.txt</span><br><span class="line"><span class="built_in">cat</span>: 20230918_1.txt: Permission denied</span><br><span class="line">$ <span class="built_in">ls</span> -l</span><br><span class="line">total 16</span><br><span class="line">-rw-r--r-- 1 torch torch  415 Sep 18 14:49 20230918_1.cpp</span><br><span class="line">---x------ 1 torch torch    0 Sep 18 14:51 20230918_1.txt</span><br><span class="line">-rwxr-xr-x 1 torch torch 9024 Sep 18 14:51 a.out</span><br></pre></td></tr></table></figure>

<p>  可以看到，当我们使用cat命令输出文件内容时，系统提示我们没有查看文件的权限。我们使用ls -l查看文件的权限信息，发现，文件所有者仅仅拥有对文件的执行权限。经过测试这个执行权限，仅允许我们在执行代码时打开文件，而不能够读取和写入文件内容。</p>
</li>
<li><p>创建一个有权限的文件</p>
<p>  接下来我们修改代码，删除生成的a.out和20230918_1.txt文件。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* name:    20230918_1.cpp</span></span><br><span class="line"><span class="comment">* funtion: 有权限文件创建</span></span><br><span class="line"><span class="comment">* Date:    2023-09-18</span></span><br><span class="line"><span class="comment">* Author:  Torch-HXM</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">char</span> filePath[] = <span class="string">&quot;./20230918_1.txt&quot;</span>;</span><br><span class="line"><span class="type">int</span> flags = O_CREAT | O_RDWR;</span><br><span class="line"><span class="type">mode_t</span> mode = S_IRWXU;                  <span class="comment">// 给文件所有者读写和执行权限</span></span><br><span class="line"><span class="type">int</span> fd = <span class="built_in">open</span>(filePath, flags, mode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(fd)&#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;create file successfully.&quot;</span>&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;file created failed.&quot;</span>&lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  编译并执行代码后，使用cat命令查看20230918_1.txt文件,不再出现权限问题，查看文件权限：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l</span><br><span class="line">total 16</span><br><span class="line">-rw-r--r-- 1 torch torch  521 Sep 18 15:06 20230918_1.cpp</span><br><span class="line">-rwx------ 1 torch torch    0 Sep 18 15:03 20230918_1.txt</span><br><span class="line">-rwxr-xr-x 1 torch torch 9024 Sep 18 15:03 a.out</span><br></pre></td></tr></table></figure>

<p>  20230918_1.txt文件的所有者已经具有读写和执行权限。所以，在创建文件时，一定要设置权限，不然，即使创建成功，即使flags中规定以读写的方式打开，即使程序不报错，也会因为权限问题无法读写成功。</p>
</li>
<li><p>打开文件</p>
<ul>
<li>如果打开文件时使用了mode参数会发生什么?<br>  我们在已经拥有文件”.&#x2F;20230918_1.txt”的情况下再次执行程序，发现程序没有报错。我们修改程序中赋予的权限mode为读权限，编译后执行程序，发现”.&#x2F;20230918_1.txt”文件的权限仍然是读写和执行，并没有变为读，因此判定当文件存在时，mode参数失去作用，加上该参数不会报错也不会对文件的权限进行修改。</li>
<li>使用不带mode参数的open函数打开文件和带mode参数的open函数打开文件的效果一致。</li>
</ul>
</li>
<li><p>文件的关闭<br> 系统的文件描述符数量是有限的，在程序中打开文件后一定要记得关闭。我们在<strong>文件的创建与打开</strong>中的示例在打开文件后并没有关闭文件的步骤，这样会使得内核分配给我们的文件描述符无法被释放（重启后自动释放）。</p>
<ul>
<li><p>函数</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param fd   要关闭文件的文件描述符</span></span><br><span class="line"><span class="comment"> * @return int 成功关闭时返回0，否则返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>演示</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * name:    20230918_1.cpp</span></span><br><span class="line"><span class="comment"> * funtion: 关闭文件</span></span><br><span class="line"><span class="comment"> * Date:    2023-09-18</span></span><br><span class="line"><span class="comment"> * Author:  Torch-HXM</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> filePath[] = <span class="string">&quot;./20230918_1.txt&quot;</span>;</span><br><span class="line">    <span class="type">int</span> flags = O_CREAT | O_RDWR;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(filePath, flags);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;文件描述符为:&quot;</span>&lt;&lt; fd&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd)&#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;open file successfully.&quot;</span>&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;open file failed.&quot;</span>&lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;close file successfully.&quot;</span>&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;close file failed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>写入和读取文件</p>
<ul>
<li><p>函数</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param fd      文件描述符</span></span><br><span class="line"><span class="comment"> * @param buf     字符缓冲区，储存着即将写入到文件中的字符</span></span><br><span class="line"><span class="comment"> * @param count   写入数量，从buf中写入count个字符到文件中</span></span><br><span class="line"><span class="comment"> * @return int    执行成功则返回写入的字节数，否则返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span>* buf, <span class="type">size_t</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param fd      文件描述符</span></span><br><span class="line"><span class="comment"> * @param buf     字符缓冲区，用来储存读取到的字符</span></span><br><span class="line"><span class="comment"> * @param count   读取数量，从文件中读取count个字符到buf中</span></span><br><span class="line"><span class="comment"> * @return int    执行成功时返回读取到的字节数，失败时返回-1，错误代码存入errno中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* buf, <span class="type">size_t</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param fd      文件描述符</span></span><br><span class="line"><span class="comment"> * @param offset  相对于whence的偏移量</span></span><br><span class="line"><span class="comment"> * @param whence  位置宏</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">off_t</span> <span class="title">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure>

<p> read储存在errno中常见的错误代码</p>
<table>
<thead>
<tr>
<th align="left">错误代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">EINTR</td>
<td align="left">此调用被信号中断</td>
</tr>
<tr>
<td align="left">EAGAIN</td>
<td align="left">当使用不可阻断IO时，若无数据可读取，则返回此值</td>
</tr>
<tr>
<td align="left">EBADF</td>
<td align="left">参数FD为非有效文件描述符或当前文件已关闭</td>
</tr>
</tbody></table>
<p> lseek中的whence</p>
<table>
<thead>
<tr>
<th align="center">宏</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SEEK_SET</td>
<td align="center">移动光标到文件起始位置</td>
</tr>
<tr>
<td align="center">SEEK_CUR</td>
<td align="center">保持当前光标位置不变</td>
</tr>
<tr>
<td align="center">SEEK_END</td>
<td align="center">移动光标到文件结尾位置</td>
</tr>
</tbody></table>
<p> lseek函数通过调整文件偏移量（光标位置）可以设置我们从文件的何处开始读取或写入。</p>
</li>
<li><p>演示</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * name:        20230918_1.cpp</span></span><br><span class="line"><span class="comment"> * funtion: 关闭文件</span></span><br><span class="line"><span class="comment"> * Date:        2023-09-18</span></span><br><span class="line"><span class="comment"> * Author:      Torch-HXM</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 打开文件</span></span><br><span class="line">        <span class="type">char</span> filePath[] = <span class="string">&quot;./20230918_1.txt&quot;</span>;</span><br><span class="line">        <span class="type">int</span> flags = O_CREAT | O_RDWR;</span><br><span class="line">        <span class="type">int</span> fd = <span class="built_in">open</span>(filePath, flags);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fd)&#123;</span><br><span class="line">                cout&lt;&lt; <span class="string">&quot;成功打开文件 &quot;</span>&lt;&lt; filePath&lt;&lt; <span class="string">&quot; 文件描述符为：&quot;</span>&lt;&lt; fd&lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt; <span class="string">&quot;open file failed.&quot;</span>&lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时文件的内容为空</span></span><br><span class="line">        <span class="type">char</span> writeBuf[] = <span class="string">&quot;Tody is September 28th, 2023.&quot;</span>;</span><br><span class="line">        <span class="type">int</span> writeCount =  <span class="built_in">strlen</span>(writeBuf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入内容</span></span><br><span class="line">        <span class="type">int</span> getSize = <span class="built_in">write</span>(fd, writeBuf, writeCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(getSize==<span class="number">-1</span>)&#123;</span><br><span class="line">                cout&lt;&lt; <span class="string">&quot;写入内容失败！&quot;</span>&lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt; <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;writeCount;i++)&#123;</span><br><span class="line">                        cout&lt;&lt; writeBuf[i];</span><br><span class="line">                &#125;</span><br><span class="line">                cout&lt;&lt; <span class="string">&quot;&#x27;&quot;</span>&lt;&lt; <span class="string">&quot;写入成功！&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调整文件偏移量至文件开头</span></span><br><span class="line">        <span class="type">off_t</span> offset = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> whence = SEEK_SET;</span><br><span class="line">        <span class="type">int</span> where = <span class="built_in">lseek</span>(fd, offset, whence);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(where==<span class="number">-1</span>)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;文件偏移量调整失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;文件偏移量已调整至：&quot;</span>&lt;&lt; where&lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取文件内容</span></span><br><span class="line">        <span class="type">char</span> readBuf[<span class="number">100</span>];</span><br><span class="line">        <span class="type">int</span> readCount = <span class="built_in">strlen</span>(writeBuf);</span><br><span class="line">        getSize = <span class="built_in">read</span>(fd, readBuf, readCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(getSize == <span class="number">-1</span>)&#123;</span><br><span class="line">                cout&lt;&lt; <span class="string">&quot;读取文件失败！&quot;</span>&lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt; <span class="string">&quot;已读取内容：&quot;</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;getSize;i++)&#123;</span><br><span class="line">                        cout&lt;&lt; readBuf[i];</span><br><span class="line">                &#125;</span><br><span class="line">                cout&lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭文件</span></span><br><span class="line">        fd = <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fd==<span class="number">0</span>)&#123;</span><br><span class="line">                cout&lt;&lt; <span class="string">&quot;close file successfully.&quot;</span>&lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt; <span class="string">&quot;close file failed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 执行结果：</p>
<blockquote>
<p>成功打开文件 .&#x2F;20230918_1.txt 文件描述符为：3<br>    ‘Tody is September 28th, 2023.’写入成功！<br>    文件偏移量已调整至：0<br>    已读取内容：Tody is September 28th, 2023.<br>    close file successfully.</p>
</blockquote>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何先生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="北国回忆录">
      <meta itemprop="description" content="东拼西凑、杂七杂八">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 北国回忆录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">数据结构与算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-16 12:39:50" itemprop="dateCreated datePublished" datetime="2023-09-16T12:39:50+08:00">2023-09-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-07-30 19:26:37" itemprop="dateModified" datetime="2024-07-30T19:26:37+08:00">2024-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9B%9B%E5%A4%A7%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">四大件</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="复杂度的渐进表示"><a href="#复杂度的渐进表示" class="headerlink" title="复杂度的渐进表示"></a>复杂度的渐进表示</h1><ul>
<li>最小上界复杂度：$T(n) &#x3D; O(f(n))$ 表示存在常数 $C&gt;0, n_0&gt;0$ 使得当 $n \ge n_0$ 时有 $T(n) \le C \cdot f(n)$</li>
<li>最大下界复杂度：$T(n) &#x3D; \Omega(g(n))$ 表示存在常数 $C&gt;0, n_0&gt;0$ 使得当 $n \ge n_0$ 时有 $T(n) \ge C \cdot g(n)$</li>
<li>等价复杂度：$T(n) &#x3D; \Theta(h(n))$ 表示同时满足 $T(n) &#x3D; O(h(n))$ 和 $T(n) &#x3D; \Omega(h(n))$</li>
</ul>
<p>各种常见时间复杂度函数的比较：</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image.png" alt="各种常见时间复杂度函数的比较"></p>
<p>当数据规模达到一定程度时，各类时间复杂度有如下关系：</p>
<p>$1 &lt; log^n &lt; n &lt; n \cdot log^n &lt; n^2 &lt; 2^n &lt; n!$</p>
<p>如果两个程序块的复杂度分别是 $T_1(n)&#x3D;O(f_1(n))$、$T_2(n)&#x3D;O(f_2(n))$，则：</p>
<ul>
<li>当两个程序前后拼接执行时：时间复杂度 $T(n) &#x3D; max(T_1(n), T_2(n))$</li>
<li>当两个程序包含嵌套执行时：时间复杂度 $T(n) &#x3D; T_1(n) \cdot T_2(n)$</li>
</ul>
<p>注意事项：</p>
<ul>
<li>当 $T(n)$ 是一个 k 阶多项式时，$T(n)&#x3D;\Theta(n^k)$</li>
<li>一个 for 循环的时间复杂度等于循环次数乘以循环体的时间复杂度</li>
<li>if-else 的时间复杂度，取各个判断分支中时间复杂度最大的一个</li>
</ul>
<h2 id="示例：递归的时间复杂度如何去算"><a href="#示例：递归的时间复杂度如何去算" class="headerlink" title="示例：递归的时间复杂度如何去算"></a>示例：递归的时间复杂度如何去算</h2><p>问题：寻找一串数字的最大子列和？</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-1.png" alt="数字的最大子列和"></p>
<p>将一个问题分为两半，原本的时间复杂度时是 $T(n)$，分为两半后，数据规模减半，两边的时间复杂度都是 $T(\frac{n}{2})$。另外，当综合两边的结果时，需要把全部元素“看一遍”，因此，综合两个 $T(n)$ 时的时间复杂度是 $O(n)$。因此有式子：</p>
<p>$T(n) &#x3D; 2 \cdot T(\frac{n}{2}) + O(n)$</p>
<p>而 $O(n) &#x3D; c \cdot n$，因此，公式变为：</p>
<p>$T(n) &#x3D; 2 \cdot T(\frac{n}{2}) + c \cdot n$</p>
<p>将 $n&#x3D;\frac{n}{2}$ 递推地带入公式即可推导出时间复杂度。</p>
<h2 id="各种操作时间复杂度比较"><a href="#各种操作时间复杂度比较" class="headerlink" title="各种操作时间复杂度比较"></a>各种操作时间复杂度比较</h2><table>
<thead>
<tr>
<th align="center">结构</th>
<th align="center">操作</th>
<th align="center">平均时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数组</td>
<td align="center">求表长</td>
<td align="center">$\Theta(1)$</td>
</tr>
<tr>
<td align="center">–</td>
<td align="center">按序号查找</td>
<td align="center">$\Theta(1)$</td>
</tr>
<tr>
<td align="center">–</td>
<td align="center">按值查找</td>
<td align="center">$\Theta(\frac{N}{2})$</td>
</tr>
<tr>
<td align="center">–</td>
<td align="center">插入指定位置</td>
<td align="center">$\Theta(\frac{N}{2})$</td>
</tr>
<tr>
<td align="center">–</td>
<td align="center">删除指定位置</td>
<td align="center">$\Theta(\frac{N}{2})$</td>
</tr>
<tr>
<td align="center">链表</td>
<td align="center">求表长</td>
<td align="center">$\Theta(N)$</td>
</tr>
<tr>
<td align="center">–</td>
<td align="center">按序号查找</td>
<td align="center">$\Theta(\frac{N}{2})$</td>
</tr>
<tr>
<td align="center">–</td>
<td align="center">按值查找</td>
<td align="center">$\Theta(\frac{N}{2})$</td>
</tr>
<tr>
<td align="center">–</td>
<td align="center">插入指定位置</td>
<td align="center">$\Theta(\frac{N}{2})$</td>
</tr>
<tr>
<td align="center">–</td>
<td align="center">删除指定位置</td>
<td align="center">$\Theta(\frac{N}{2})$</td>
</tr>
</tbody></table>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>线性表的两种储存结构：</p>
<ul>
<li>顺序储存结构：数组</li>
<li>链式储存结构：链表</li>
</ul>
<h1 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> GNode* GList;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GNode</span>&#123;</span><br><span class="line">  <span class="type">int</span> Tag;</span><br><span class="line">  <span class="keyword">union</span>&#123;</span><br><span class="line">      ElementType Data;</span><br><span class="line">      Glist SubList;</span><br><span class="line">  &#125;URegion;</span><br><span class="line">  GList Next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>广义表的数据项有可能是数据，也有可能是表，因此，使用联合体来表示数据域，使用 Tag 标签来表示该节点储存的是哪一种数据。</p>
<h1 id="多重链表"><a href="#多重链表" class="headerlink" title="多重链表"></a>多重链表</h1><p>有多个指针域的链表。但注意，双向链表有两个指针域，分别指向前一个节点和后一个节点，但它不是多重链表。</p>
<p>多重链表可以用来表示稀疏矩阵，相比于使用二维数组能够节省更多空间。</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-3.png" alt="Alt text"></p>
<p>图像中， Term 是矩阵的入口节点，4 和 5 代表矩阵拥有四行五列，7 代表矩阵拥有 7 个元素。Term 中包含两个指针域，分别指向右侧和下方。Head 节点是矩阵各行各列的头节点，Head 中包含两个指针域和一个值域，两个指针域与 Term 的指针域相同，值域中保存着指向下一个 Head 节点的指针，所以实际上 Head 节点中包含的是三个指针域。</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-2.png" alt="Alt text"></p>
<h1 id="堆栈-Stack"><a href="#堆栈-Stack" class="headerlink" title="堆栈(Stack)"></a>堆栈(Stack)</h1><p>后入先出</p>
<h1 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h1><p>先入先出</p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>儿子兄弟表示法，避免空指针浪费空间<br><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-4.png" alt="Alt text"><br>将任意的树通过这种方法表示后旋转45°<br><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-5.png" alt="Alt text"><br>可以得到二叉树，因此，任何一个树都可以表示为二叉树。</p>
<h2 id="二叉树分类"><a href="#二叉树分类" class="headerlink" title="二叉树分类"></a>二叉树分类</h2><p>斜二叉树</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-6.png" alt="斜二叉树"></p>
<p>完美二叉树（满二叉树）</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-7.png" alt="完美二叉树"></p>
<p>完全二叉树</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-8.png" alt="完全二叉树"></p>
<p>二叉树的特点：</p>
<ul>
<li>第 i 层最大节点数 $2^{i-1}$</li>
<li>深度为 k 的二叉树最大节点数 $2^k-1$</li>
<li>对于任何二叉树，若 $n_0$ 表示叶节点个数、$n_2$是度为 2 的非叶节点个数，那么两者满足关系式$n_0&#x3D;n_2+1$</li>
</ul>
<p>对于最后一点，我们可以从二叉树边的个数来考虑。我们设度为 2 的节点个数为 $n_2$，度为 1 的节点个数为 $n_1$ 度为 0 的节点个数为 $n_0$。那么，整个二叉树拥有的边的个数为 $n_0+n_1 +n_2-1$，同时，通过度来计算边的个数为 $0 \cdot n_0 + 1 \cdot n_1 + 2 \cdot n_2$，两侧相等得到$n_0&#x3D;n_2+1$</p>
<h2 id="二叉树的储存"><a href="#二叉树的储存" class="headerlink" title="二叉树的储存"></a>二叉树的储存</h2><p>完全二叉树可以使用数组储存<br><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-9.png" alt="Alt text"><br>一般的二叉树，通过将其补全为完全二叉树，也可以使用数组储存，但是会浪费空间。</p>
<p>所有类型的二叉树都可以使用链表来储存<br><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-10.png" alt="Alt text"></p>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>先序遍历<br><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-11.png" alt="Alt text"><br>中序遍历<br><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-12.png" alt="Alt text"><br>后序遍历<br><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-13.png" alt="Alt text"></p>
<p>无论先序、中序还是后序，同一个节点我们都会经历三次<br><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-14.png" alt="Alt text"><br>先序是在第一次经历节点时就使用节点值、中序是第二次经历节点时就使用节点值、后续是第三次经历节点时就使用节点值。</p>
<p>递归的算法都可以使用堆栈来实现。</p>
<p>层序遍历</p>
<p>使用队列遍历二叉树，压入父节点，弹出节点时再压入其左右儿子节点，如此反复，直到所有的节点全部被访问。<br><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-15.png" alt="Alt text"></p>
<h2 id="二叉树遍历应用"><a href="#二叉树遍历应用" class="headerlink" title="二叉树遍历应用"></a>二叉树遍历应用</h2><p>先序遍历：查找所有叶节点<br><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-16.png" alt="查找所有叶节点"><br>后序遍历：求二叉树的高度<br><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-17.png" alt="Alt text"><br>构造运算树<br><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-18.png" alt="Alt text"><br>虽然直接构造的中缀表达式会收到运算优先级的影响，但是可以通过每次遍历到父节点就为前面的式子加括号来解决问题。</p>
<p>另外，只通过先序和后序遍历结果不能够唯一确定一个二叉树。<br><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-19.png" alt="Alt text"><br>可以看到，我们无法根据先序和后序遍历结果对子树是左子树还是右子树进行判断。因此必须有两种遍历结果并且其中必须包含中序遍历结果才能判断。</p>
<h2 id="静态链表是结构体数组"><a href="#静态链表是结构体数组" class="headerlink" title="静态链表是结构体数组"></a>静态链表是结构体数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    Tree Left;</span><br><span class="line">    Tree Right;</span><br><span class="line">&#125;T1[MaxTree], T2[MaxTree];</span><br></pre></td></tr></table></figure>

<p>其中的 T1 和 T2 就是静态链表。</p>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>一种二叉树，可以为空，当不为空时需要满足以下条件：</p>
<ul>
<li>左儿子小于根节点</li>
<li>右儿子大于根节点</li>
<li>左右子树都是二叉搜索树</li>
</ul>
<p>查找指定元素：查找效率取决于树的高度。</p>
<p>查找最大值：最大值一定在树的最右边</p>
<p>查找最小值：最小值一定在树的最左边</p>
<p>尾递归可以用循环来实现，尾递归是指在返回时调用递归</p>
<p>插入元素：从根部向下一直比较，元素最终插入到树的最下面。</p>
<p>删除元素：删除元素后，用右子树的最小值或左子树的最大值替代被删除元素。由于右子树的最小值和左子树的最大值最多只有一个儿子节点，因此，删除任意元素的问题转变为删除一个没有儿子节点或者只有一个儿子节点的元素问题。当删除没有儿子节点的元素时，直接删除即可；当删除有一个儿子节点的元素时，用儿子节点替代被删除元素即可。</p>
<h2 id="平衡二叉树（AVL树）"><a href="#平衡二叉树（AVL树）" class="headerlink" title="平衡二叉树（AVL树）"></a>平衡二叉树（AVL树）</h2><p>平衡因子：$BF(T)&#x3D;h_L-h_R$，左子树高度减去右子树高度。</p>
<p>平衡二叉树：对于任意一个子树而言$|BF(T)|\le1$。</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-21.png" alt="Alt text"></p>
<p>高度为 h 的平衡二叉树和其最少节点数 n 之间满足关系式：$h&#x3D;O(log_2^n)$。所以，一个平衡二叉树（AVL树）的查找时间复杂度为 $O(log_2^n)$。</p>
<h3 id="平衡二叉树的调整"><a href="#平衡二叉树的调整" class="headerlink" title="平衡二叉树的调整"></a>平衡二叉树的调整</h3><p>右旋调整：RR 旋转</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-22.png" alt="RR 旋转"></p>
<p>左旋调整：LL 旋转</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-23.png" alt="Alt text"></p>
<p>LR 旋转</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-24.png" alt="Alt text"></p>
<p>RL 旋转</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-25.png" alt="Alt text"></p>
<p>上述旋转的命名方法：如果插入的节点在左子树的右子树上，则调整方式命名为 LR 旋转；如果插入节点在右子树的左子树上，则调整方式命名为 RL 旋转。</p>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>堆是一个具有优先级的特殊队列。</p>
<p>堆的实现方式：</p>
<ul>
<li>数组<ul>
<li>插入：插入到尾部，$\Theta(1)$</li>
<li>删除：查找最大（后最小）优先级 $\Theta(n)$，删除元素后移动后面的元素 $O(n)$</li>
</ul>
</li>
<li>链表<ul>
<li>插入：总是插入到链表的头部 $\Theta(1)$</li>
<li>删除：查找最大关键字后删除节点 $\Theta(n)$</li>
</ul>
</li>
<li>有序数组（按优先级排序）<ul>
<li>插入：找到合适的位置 $O(n)$ 或 $O(log_2^n)$，移动元素并插入 $O(n)$</li>
<li>删除：删除最后一个元素 $\Theta(1)$</li>
</ul>
</li>
<li>有序链表<ul>
<li>插入：找到合适的元素位置插入元素 $O(n)$</li>
<li>删除：删除首元或最后元素 $\Theta(1)$</li>
</ul>
</li>
</ul>
<p>实际的堆是通过完全二叉树实现的，这样插入和删除的时间复杂度都是 $O(log_2^n)$。为了减少删除操作的难度，对于该完全二叉树的所有子树而言，我们将最大或最小的元素放在根部，以满足我们对删除的需求。将最大元素放在根部，我们将获得最大堆；将最小元素放在根部，我们将获得最小堆。</p>
<p>插入操作：先将元素插入到堆（完全二叉树）的最后，然后逐步和自己的父节点进行优先级比较，以安放到合适的位置。时间复杂度为 $O(log_2^n)$</p>
<p>删除操作：删除堆（完全二叉树）的根，然后将完全二叉树的最后一个元素放到根部，然后逐步和子节点进行比较，以安放到合适位置。时间复杂度为 $O(log_2^n)$</p>
<p>最大堆的建立：</p>
<ul>
<li>方案一：将元素一个一个的插入到空堆中。时间复杂度为 $O(n \cdot log_2^n)$</li>
<li>方案二：先构造完全二叉树，然后调整大小构成堆。$O(n)$</li>
</ul>
<h1 id="哈夫曼树（最优二叉树）"><a href="#哈夫曼树（最优二叉树）" class="headerlink" title="哈夫曼树（最优二叉树）"></a>哈夫曼树（最优二叉树）</h1><p>带权路径长度（WPL）：每一个叶子结点的权重乘以其到根节点的路径长度之和。</p>
<p>哈夫曼树：WPL 最小的二叉树。</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-26.png" alt="Alt text"></p>
<p>图中第一个 WPL：$1 \cdot 4 + 2 \cdot 4 + 3 \cdot 3 + 4 \cdot 2 + 5 \cdot 1 &#x3D; 34$</p>
<p>图中第二个 WPL：$5 \cdot 4 + 4 \cdot 4 + 3 \cdot 3 + 2 \cdot 2 + 1 \cdot 1 &#x3D; 50$</p>
<p>图中第三个 WPL：$1 \cdot 3 + 2 \cdot 3 + 3 \cdot 2 + 4 \cdot 2 + 5 \cdot 2 &#x3D; 33$</p>
<h2 id="构造一个哈夫曼树"><a href="#构造一个哈夫曼树" class="headerlink" title="构造一个哈夫曼树"></a>构造一个哈夫曼树</h2><ul>
<li><p>给定一个列表 [1, 2, 3, 4, 5]，将它们看作 5 个树的根节点。</p>
</li>
<li><p>在它们之中找到两个最小根节点的树进行合并。此处将 [1, 2] 进行合并，变为以 3 为根，1、2 为叶节点的树。此时根节点列表变为[3, 3, 4, 5]。</p>
</li>
<li><p>重复第二步，直到根节点列表中只有一个根节点。此时，原给定列表中的所有数值变成了所构建的树的叶节点，所构建的树是哈夫曼树。</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-27.png" alt="森特佩"></p>
<p>$\downarrow$</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-28.png" alt="Alt text"></p>
<p>$\downarrow$</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-29.png" alt="Alt text"></p>
<p>$\downarrow$</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-30.png" alt="Alt text"></p>
<p>$\downarrow$</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-31.png" alt="Alt text"></p>
</li>
</ul>
<p>哈夫曼树的特点：</p>
<ul>
<li>从哈夫曼树的构造过程可知，哈夫曼树中不存在度为一的节点。由公式 $n_0&#x3D;n_2+1$ 可得，叶节点数为 n 的哈夫曼树的总节点数为 $2 \cdot n-1$</li>
<li>哈夫曼树交换左右子树仍然是哈夫曼树</li>
<li>同一组权值可能出现两个不同构的哈夫曼树，但他们的 WPL 相同</li>
</ul>
<h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p>为了避免编码的二义性，应当避免一个字符的编码是另一个字符编码的前缀。使用二叉树的叶节点来构造这种编码可以避免二义性：</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-32.png" alt="Alt text"></p>
<p>其中，a 的编码是 00，u 的编码是 01，x 的编码是 10，z 的编码是 11。这个例子可能有点特殊，其实，即使编码不是等长码也可以。但编码的节点必须是二叉树的叶节点。</p>
<p>这样的编码方式似乎很不错。但是，由于每一个字符出现的频率不相同，因此，这样的编码并不是效率最高的。我们假设我们要对下面的字符序列进行编码：[aaaxuaxz]，那么，a、u、x、z 使用上面的二叉树编码后的结果所包含的总位数为：$2 \cdot 4 + 2 \cdot 1 + 2 \cdot 2 + 2 \cdot 1 &#x3D; 16$。而，如果我们将字符出现的频率作为该字符的权重，并使用哈夫曼树构造这样的编码，则可以最小化编码后的位数，同时，因为哈夫曼树也是二叉树，且编码后的字符都位于哈夫曼树的叶结点上，所以得到的编码也具有唯一性。上面的例子写成哈夫曼树如下：</p>
<table>
<thead>
<tr>
<th align="center">a</th>
<th align="center">u</th>
<th align="center">x</th>
<th align="center">z</th>
</tr>
</thead>
<tbody><tr>
<td align="center">4</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-33.png" alt="Alt text"></p>
<p>所以字符应编码如下：</p>
<table>
<thead>
<tr>
<th align="center">a</th>
<th align="center">u</th>
<th align="center">x</th>
<th align="center">z</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">110</td>
<td align="center">10</td>
<td align="center">111</td>
</tr>
</tbody></table>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>只执行两个操作：</p>
<ul>
<li>将两个元素连线：通过将两个元素所在集合合并实现</li>
<li>查询两个元素是否联通</li>
</ul>
<p>每一个集合可以用树来储存。通过合并两个树实现集合的合并；通过查找两个元素的根节点，并比较根节点是否相同，来判断两个元素是否在同一集合（联通）。这里的树是多叉树。</p>
<p>用结构数组可以储存这样的树：</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-34.png" alt="Alt text"></p>
<p>合并两个树（集合）的过程如下：</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-35.png" alt="Alt text"></p>
<p>$\downarrow$</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-36.png" alt="Alt text"></p>
<p>在合并的过程中，由于树越来越高会降低查找的效率，因此，我们尽量将小的树拼到高的树上。</p>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>无向图的深度优先搜索 DFS 的时间复杂度：</p>
<p>当图拥有 N 个节点 E 条边时</p>
<ul>
<li>用邻接表储存图：$O(N+E)$</li>
<li>邻接矩阵储存图：$O(N^2)$</li>
</ul>
<p>无向图的广度优先搜索 BFS 的时间复杂度：</p>
<p>当图拥有 N 个节点 E 条边时</p>
<ul>
<li>用邻接表储存图：$O(N+E)$</li>
<li>邻接矩阵储存图：$O(N^2)$</li>
</ul>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>从头开始两两比较，保证较大的数字在数字比较对的后一位。每一次遍历，整个序列最大的数字将被排到数列最后。</p>
<p>时间复杂度：</p>
<ul>
<li>最好情况：$T&#x3D;O(N)$</li>
<li>最坏情况：$T&#x3D;O(N^2)$</li>
</ul>
<p>由于只需要对相邻的两个元素进行操作，因此，它天然的适用于数组和链表。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>一个数字一个数字的拿进来，然后和已经存在的有序序列进行比较插入。</p>
<p>时间复杂度：</p>
<ul>
<li>最好情况：$T&#x3D;O(N)$</li>
<li>最坏情况：$T&#x3D;O(N^2)$</li>
</ul>
<p>由于 N 个不同元素组成的序列平均有 N(N-1)&#x2F;4 个逆序对。<br>所以，任何以交换相邻两个元素来排序的算法，其平均时间复杂度为 $\Omega(N^2)$<br>因此，为了减小排序的平均时间复杂度，我们应该努力的让每一次基本操作消去不止一个逆序对。</p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>首先设定一组间隔数，例如 5、3、1 ，这组间隔的最后一个数字必须是 1.而后对需要被排序的数组做如下操作：</p>
<ul>
<li>将数组的第 1、6、11、… 每隔 5 个元素选取一个，进行插入排序</li>
<li>将数组的第 1、4、7、 … 每隔 3 个元素选取一个，进行插入排序</li>
<li>将数组的第 1、2、3、 … 每隔 1 个元素选取一个，进行插入排序</li>
</ul>
<p>执行完上述操作后得到有序数组。</p>
<p>在执行完间隔为 3 的排序后，间隔为 5 的序列仍然是有序的。</p>
<p>需要注意的是，所选的间隔数最好互质，不然各个间隔的排序很可能不起作用，白白的增加时间复杂度。这一个原因也造成了原始的希尔排序的最坏时间复杂度为 $\Theta(N^2)$。因此，对于希尔排序间隔数的选择有以下方法：</p>
<ul>
<li>Hibbard 增量序列：间隔数选取 $2^k-1$，最坏时间复杂度 $\Theta(N^{\frac{3}{2}})$，猜想的平均时间复杂度 $\Omega(N^{\frac{5}{4}})$</li>
<li>Sedgewick 增量序列：间隔选取 $9 \times 4^i - 9 \times 2^i + 1$ 或 $4^i - 3 \times 2^i +1$，猜想平均时间复杂度 $T_{avg}&#x3D;O(N^{\frac{7}{6}})$，最坏时间复杂度 $T_{worst}&#x3D;O(N^{\frac{4}{3}})$</li>
</ul>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>每次找序列的最小元素，移动到序列的最后。</p>
<p>由于无论如何都要一遍一遍的便利未排序的数组，所以时间复杂度：$T&#x3D;\Theta(N^2)$</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法一</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Heap_Sort</span><span class="params">(ElementType A[], <span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    BuildMinHeap(A);               <span class="comment">// 时间复杂度为 O(N)</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)  </span><br><span class="line">        TmpA[i] = DeleteMin(A); <span class="comment">// 时间复杂度为 O(logN)</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        A[i] = TmpA[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法一的步骤如下：</p>
<ol>
<li>建立一个最小堆</li>
<li>将最小堆中的根逐步弹出，放入暂存数组中</li>
<li>将原数组替换为排序后的数组</li>
</ol>
<p>算法一的时间复杂度为：$T(N)&#x3D;O(N \cdot logN)$</p>
<p>该算法的时间复杂度还能够接受，唯一的问题是，该算法需要开辟一个和待排序数组同等大小的数组。因此我们提出了算法，算法二更加节省空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法二</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Heap_Sort</span><span class="params">(ElementType A[], <span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    BuildMaxHeap(A);            <span class="comment">// 时间复杂度为 O(N)</span></span><br><span class="line">    <span class="keyword">for</span>(i=N<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)  </span><br><span class="line">        Swap(&amp;A[<span class="number">0</span>], &amp;A[i]);     <span class="comment">// 将最大堆的根和该堆的最后一个元素交换位置</span></span><br><span class="line">        AdjustMaxHeep(A, i)     <span class="comment">// 将最后一个元素排除在外，将剩余部分调整为最大堆</span></span><br><span class="line">                                <span class="comment">// 该步的时间复杂度是 O(logN) 树高</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法二的步骤如下：</p>
<ol>
<li>建立一个最大堆</li>
<li>将当前堆的根与堆的最后一个元素交换</li>
<li>将被交换的根排除在堆外，将剩余元素重新调整为最大堆。</li>
<li>如果堆只剩下一个元素，则终止</li>
<li>回到 2</li>
</ol>
<p>算法二的时间复杂度为：$T(N)&#x3D;O(N \cdot logN)$</p>
<p>算法二相比于算法一不需要开辟额外的空间。</p>
<p>另外，虽然堆排序的时间复杂度小于希尔排序，但是在实际应用中不如使用：希尔排序+Sedgewick增量</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="有序子序列的归并"><a href="#有序子序列的归并" class="headerlink" title="有序子序列的归并"></a>有序子序列的归并</h3><p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-42.png" alt="Alt text"></p>
<p>开三个指针，分别指向序列一元素、序列二元素、储存空间元素。然后比较序列一元素和序列二元素，将较小的存入储存空间，然后较小的序列指针加 1 、储存空间的指针加 1。</p>
<p>由于需要把两个子序列都看一遍，所以时间复杂度是 $O(N)$</p>
<p>后面的归并排序，将使用该算法合并两个有序序列。</p>
<h3 id="归并排序的递归实现"><a href="#归并排序的递归实现" class="headerlink" title="归并排序的递归实现"></a>归并排序的递归实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序的递归实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MSort</span><span class="params">(ElementType A[], ElementType TmpA[], <span class="type">int</span> L, <span class="type">int</span> RightEnd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Center;</span><br><span class="line">    <span class="keyword">if</span>(RightEnd-L&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        Center = (L+RightEnd)/<span class="number">2</span>;</span><br><span class="line">        MSort(A, Tmp, L, Center);</span><br><span class="line">        MSort(A, Tmp, Center+<span class="number">1</span>, RightEnd);</span><br><span class="line">        Merge(A, TmpA, L, Center+<span class="number">1</span>, RightEnd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将无序数组一分为二，分别对左侧数组和右侧数组排序，然后使用<a href="#%E6%9C%89%E5%BA%8F%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%BD%92%E5%B9%B6">有序子序列的归并</a>合并他们。递归的解决这个问题。</p>
<p>最好、最坏、平均时间复杂度是 $O(Nlog^N)$</p>
<h3 id="归并排序的非递归算法"><a href="#归并排序的非递归算法" class="headerlink" title="归并排序的非递归算法"></a>归并排序的非递归算法</h3><p>将无序数组切分为单个元素，我们将单个元素看作有序序列，然后两两元素（有序序列）使用<a href="#%E6%9C%89%E5%BA%8F%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%BD%92%E5%B9%B6">有序子序列的归并</a>合并，重复执行，直到合并所有序列为止。</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-45.png" alt="Alt text"></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Quicksort</span><span class="params">(ElementType A[], <span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(N&lt;<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    pivot = 从 A 中选择主元;</span><br><span class="line">    将 S = &#123; A[]\pivot &#125; 分为两个独立子集:</span><br><span class="line">        A1 = &#123; a 在 S 中，且 a 小于等于 pivot &#125;</span><br><span class="line">        A2 = &#123; a 在 S 中，且 a 大于 pivot &#125;</span><br><span class="line">    A[] = Quicksort(A1, N1) 并 &#123;pivot&#125; 并 Quicksort(A2, N2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>选择一个主元</li>
<li>将小于主元的数构成一个集合，大于主元的数构成一个集合，分别对这两个集合进行快速排序</li>
<li>然后再将小于主元的有序集合、主元、大于主元的有序集合合并在一起，完成排序</li>
</ul>
<p>快速排序有两个主要工作分别是：</p>
<ul>
<li>选主元：取头、中、尾三个元素的中位数作为主元</li>
<li>子集划分：选好主元后，在数组的头尾分别定义两个指针，将指针中的内容与主元比较大小。当左侧指针找到比主元大的元素时，左侧指针停止移动，等待右侧指针找到比主元小的元素。当右侧指针找到比主元小的元素后，两个指针交换内容。如果直到两个指针相遇，右侧指针都没找到比主元小的元素，则交换右侧指针所指元素和主元。此时，以主元为界，将数组划分为大于主元的部分和小于主元的部分。</li>
</ul>
<p>时间复杂度分析：$T(N)&#x3D;O(N \cdot logN)$</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202002091953256.gif" alt="image"></p>
<h2 id="对大数据元素排序"><a href="#对大数据元素排序" class="headerlink" title="对大数据元素排序"></a>对大数据元素排序</h2><ol>
<li>表排序（间接排序）</li>
</ol>
<p>有时，需要被排序的数据元素很大，不方便被频繁的移动，因此，我们定义一个表记录各个元素的原始位置，然后对元素排序时只移动表中的记录。最后表中的序列标示着各个数据元素的正确位置。</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-46.png" alt="Alt text"></p>
<ol start="2">
<li>物理排序</li>
</ol>
<p>在获得表排序的结果后，我们需要对元素进行移动，我们希望移动的次数越少越好。</p>
<p>因此引入了“环”的概念，他表示一组需要交换位置的元素的集合。对每一个环进行排序后，总体上的时间复杂度是 $O(mN)$，其中 m 是元素移动的时间。</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-47.png" alt="Alt text"></p>
<p>图中，不同的元素代表不同的环。</p>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>为所有可能的数值创建一个空位置，然后将需要排序的数组中的元素插入到对应的位置，最后从头到尾，将所有位置中的元素输出，即可得到排序。</p>
<p>若需要被排序的元素个数为 N，可能出现的数值个数为 M，则整个排序过程，需要插入 N 次，最后输出结果时需要读取 M 次，因此，时间复杂度是 $O(M+N)$</p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>有时，可能出现的数值数量要远远大于我们需要排序的元素个数，这个时候，用桶排序就不划算了。因此提出了基数排序。</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-48.png" alt="Alt text"></p>
<p>上述基数排序的流程如下：</p>
<ol>
<li><p>首先基于个位数进行排序</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-49.png" alt="Alt text"></p>
</li>
<li><p>将排序后的序列作为新的需要排序的序列</p>
</li>
<li><p>基于十位数进行排序</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-50.png" alt="Alt text"></p>
<p>由于 0、1、8 的十位都是 0 ，所以他们都按照顺序排在了 0 下面。其他数字也按照这样的规则进行排序。</p>
</li>
<li><p>将排序后的序列作为新的需要排序的序列<br>这里的新序列是 [0, 1, 8, 512, 216, 125, 27, 729, 343, 64]</p>
</li>
<li><p>基于百位数进行排序</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-51.png" alt="Alt text"></p>
</li>
<li><p>读出排序后的序列</p>
</li>
</ol>
<p>时间复杂度：$O(P(N+B))$，P 为排序的次数，B 为桶的个数，N 为元素个数。当桶的个数（基数）足够少时，近似于线性时间复杂度。</p>
<h2 id="各种排序的比较"><a href="#各种排序的比较" class="headerlink" title="各种排序的比较"></a>各种排序的比较</h2><p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-43.png" alt="Alt text"></p>
<h1 id="散列表（哈希表）"><a href="#散列表（哈希表）" class="headerlink" title="散列表（哈希表）"></a>散列表（哈希表）</h1><p>有一组元素，元素个数为 N ，还有一个可以存放元素的空表，表的长度为 M。设计一种函数，能够将待查找的元素映射到空表的一个位置。这个函数称为<strong>哈希函数</strong>。元素的长度与空表的长度之比 $\frac{N}{M}$ 称为<strong>装填因子</strong>。</p>
<h2 id="哈希函数的选取方法"><a href="#哈希函数的选取方法" class="headerlink" title="哈希函数的选取方法"></a>哈希函数的选取方法</h2><h3 id="数字关键词"><a href="#数字关键词" class="headerlink" title="数字关键词"></a>数字关键词</h3><ul>
<li>直接定值法：待查找元素统一减去某个元素</li>
<li>除留余数法：将关键词进行求余运算，将被除数取为一个素数，能够让映射更为均匀</li>
<li>数字分析法：分析元素的关键位。当数字的关键位存在明显差异时，就可以将关键位取出，然后使用一些方法映射到哈希表。</li>
<li>折叠法：把关键词拆分成几个部分，然后叠加</li>
<li>平方取中法：对关键词平方，然后取中间的几位数</li>
</ul>
<h3 id="字符关键词"><a href="#字符关键词" class="headerlink" title="字符关键词"></a>字符关键词</h3><ul>
<li>考虑字符串的前三个字符，分别作为百位、十位、个位，然后分别乘以 32，字符可以通过左移五位实现乘以 32。</li>
</ul>
<h2 id="解决冲突的方法"><a href="#解决冲突的方法" class="headerlink" title="解决冲突的方法"></a>解决冲突的方法</h2><h3 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h3><p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-52.png" alt="Alt text"></p>
<p>如果位置发生冲突，就按照一定规则找下一个位置。</p>
<ul>
<li><p>线性探测法</p>
<ul>
<li>原理：插入位置发生冲突时，逐次向下 $+i^2$ 寻找能够储存的位置。超出散列表范围则求余，回到散列表的开始。</li>
<li>问题线性探测的问题是，当某一个位置发生冲突后，该位置的冲突会越来越多，产生聚集现象。</li>
</ul>
</li>
<li><p>平方探测</p>
<ul>
<li>原理：插入位置发生冲突时，逐次向下 $\pm i^2$ 寻找能够储存的位置，加和减交替出现。超出散列表范围则求余，回到散列表的开始。</li>
<li>问题：平方探测的问题是，由于它是跳跃着查找的，所以当冲突发生时，某一个可能的空位可能始终无法被探测到。</li>
<li>解决方案：解决方法是，将散列表的长度设计为 $4k+3$，这样可以保证在探测的过程中，每一个位置都可以被找到。</li>
</ul>
</li>
<li><p>双散列探测</p>
<ul>
<li>原理：设置两个<strong>散列函数</strong>，第一个散列函数用来第一次插入的位置计算。当位置发生冲突时，则使用第二个散列函数计算平移量，然后原始插入位置与平移量相加得到最终位置。</li>
</ul>
</li>
</ul>
<h3 id="分离链接法"><a href="#分离链接法" class="headerlink" title="分离链接法"></a>分离链接法</h3><p>将发生冲突的元素通过链表串在一起。</p>
<p>分离链表法的装载因子可以大于 1.</p>
<h2 id="散列表查找的效率评估"><a href="#散列表查找的效率评估" class="headerlink" title="散列表查找的效率评估"></a>散列表查找的效率评估</h2><p>影响散列表的查找效率的主要因素是<strong>冲突</strong>，而产生冲突的多少主要由下列三个方面决定：</p>
<ul>
<li>散列函数是否均匀</li>
<li>处理冲突的方法</li>
<li>散列表的装填因子 $\alpha$</li>
</ul>
<h3 id="效率的计算平均查找长度"><a href="#效率的计算平均查找长度" class="headerlink" title="效率的计算平均查找长度"></a>效率的计算平均查找长度</h3><ul>
<li>成功平均查找长度(ASLs)<ul>
<li>定义：查找散列表中存在的元素所需要的平均时间。</li>
<li>计算：对所有的存在的元素的查找次数求平均。</li>
</ul>
</li>
<li>不成功平均查找长度(ASLu)<ul>
<li>定义：查找散列表中不存在的元素，所需要的平均时间。</li>
<li>计算：将哈希表中不存在的所有数值情况，按照哈希函数映射的结果进行分类。每一个类别的查找次数是相同的。将所有类别的查找次数相加求平均即可。</li>
</ul>
</li>
</ul>
<h3 id="各种探测方法的查找性能"><a href="#各种探测方法的查找性能" class="headerlink" title="各种探测方法的查找性能"></a>各种探测方法的查找性能</h3><ul>
<li><p>线性探测法的查找性能</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-53.png" alt="Alt text"></p>
<p>反应一般情况下的查找次数，可能与真实次数存在差异。</p>
</li>
<li><p>平方探测法和双散列探测法的查找性能</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-54.png" alt="Alt text"></p>
</li>
<li><p>分离链接发的查找性能</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-56.png" alt="Alt text"></p>
</li>
</ul>
<h3 id="期望探测次数与装在因子的关系"><a href="#期望探测次数与装在因子的关系" class="headerlink" title="期望探测次数与装在因子的关系"></a>期望探测次数与装在因子的关系</h3><p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-55.png" alt="Alt text"></p>
<p>可以看到，双散列探测法 和 平方探测法 优于 线性探测法。</p>
<h1 id="KMP-算法（串匹配）"><a href="#KMP-算法（串匹配）" class="headerlink" title="KMP 算法（串匹配）"></a>KMP 算法（串匹配）</h1><ol>
<li><p>什么是串</p>
<ul>
<li>线性储存的一组数据（默认是字符）</li>
</ul>
</li>
<li><p>串的模式匹配</p>
<ul>
<li>给定一个字符串，给定一个模式，查找这个模式在字符串中出现的位置。</li>
</ul>
</li>
</ol>
<h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h2><p><img src="/.%5C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%5Cimage57.png" alt="Alt text"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何先生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="北国回忆录">
      <meta itemprop="description" content="东拼西凑、杂七杂八">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 北国回忆录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">计算机组成原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-16 12:39:50" itemprop="dateCreated datePublished" datetime="2023-09-16T12:39:50+08:00">2023-09-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-07-30 19:26:19" itemprop="dateModified" datetime="2024-07-30T19:26:19+08:00">2024-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9B%9B%E5%A4%A7%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">四大件</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="计算机系统概论"><a href="#计算机系统概论" class="headerlink" title="计算机系统概论"></a>计算机系统概论</h1><h2 id="计算机系统简介"><a href="#计算机系统简介" class="headerlink" title="计算机系统简介"></a>计算机系统简介</h2><p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20231112083855806.png" alt="image-20231112083855806"></p>
<h2 id="计算机系统的层级结构"><a href="#计算机系统的层级结构" class="headerlink" title="计算机系统的层级结构"></a>计算机系统的层级结构</h2><p>从物理构成的角度，计算机系统可被抽象为九层：</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20231112084618549.png" alt="image-20231112084618549"></p>
<p>其中，逻辑层和微体系结构层，是我们这门课的主要研究内容。</p>
<p>从程序员的角度，计算机系统可以被抽象为五层：</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20231112092021618.png" alt="image-20231112092021618"></p>
<p>其中，微指令系统是对机器语言运行状态的细分。机器语言在运行时，一条机器语言指令需要按照一定的步骤和顺序完成，每一个步骤是一个微指令。</p>
<ul>
<li>计算机体系结构：程序许愿见到的计算机系统的属性，概念性结构与功能特性。（指令系统、数据类型、寻址技术、IO机理）</li>
<li>计算机组成：实现计算机体系结构所体现的属性。（具体指令的实现）</li>
</ul>
<h2 id="计算机的基本组成"><a href="#计算机的基本组成" class="headerlink" title="计算机的基本组成"></a>计算机的基本组成</h2><h3 id="冯诺依曼计算机的特点"><a href="#冯诺依曼计算机的特点" class="headerlink" title="冯诺依曼计算机的特点"></a>冯诺依曼计算机的特点</h3><ul>
<li>计算机由五大部件组成</li>
<li>指令和数据以同等地位存于存储器，可按地址寻访</li>
<li>指令和数据用二进制表示</li>
<li>指令由操作码和地址组成</li>
<li><strong>存储程序</strong></li>
<li>以运算器为中心</li>
</ul>
<p>冯诺依曼计算机的六大特点中，核心是<strong>存储程序</strong>，所有包含存储程序的计算机1都是冯诺依曼计算机。</p>
<h3 id="计算机的五大部件"><a href="#计算机的五大部件" class="headerlink" title="计算机的五大部件"></a>计算机的五大部件</h3><p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20231112095518942.png" alt="image-20231112095518942"></p>
<ul>
<li>运算器 ALU：是计算机的核心，负责逻辑运算和算术运算。</li>
<li>存储器 ：储存指令和数据。</li>
<li>控制器 CU：控制指令的执行，指挥程序的运行。</li>
<li>输出设备：将结果转换为人们能够接受的形式。</li>
<li>输入设备：采集输入数据。</li>
</ul>
<h4 id="以运算器为核心的计算机硬件框图"><a href="#以运算器为核心的计算机硬件框图" class="headerlink" title="以运算器为核心的计算机硬件框图"></a>以运算器为核心的计算机硬件框图</h4><p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20231112093752308.png" alt="image-20231112093752308"></p>
<p>问题：由于所有的数据和操作都需要经过运算器（数据的输入输出、数据的运算），所以运算器是所有部件中最繁忙的部分。</p>
<h4 id="以存储器为核心的计算机硬件框图"><a href="#以存储器为核心的计算机硬件框图" class="headerlink" title="以存储器为核心的计算机硬件框图"></a>以存储器为核心的计算机硬件框图</h4><p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20231112094841293.png" alt="image-20231112094841293"></p>
<h4 id="计算机硬件的层次化结构"><a href="#计算机硬件的层次化结构" class="headerlink" title="计算机硬件的层次化结构"></a>计算机硬件的层次化结构</h4><p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20231112095758531.png" alt="image-20231112095758531"></p>
<ul>
<li>指令分为操作码和地址码两个部分</li>
</ul>
<h4 id="存储器的基本组成"><a href="#存储器的基本组成" class="headerlink" title="存储器的基本组成"></a>存储器的基本组成</h4><p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20231112133029606.png" alt="image-20231112133029606"></p>
<h5 id="存储体"><a href="#存储体" class="headerlink" title="存储体"></a>存储体</h5><p><strong>储存器</strong>包含一个一个的<strong>储存体</strong>，存储体中包含多个<strong>存储单元</strong>，每一个存储单元包含存储字长个<strong>存储元件</strong>。</p>
<p><strong>存储单元</strong>存放着指令和数据，它存放的内容成为<strong>存储字</strong>，存储字的长度称为<strong>存储字长</strong>。</p>
<p>在实际存储器中，每一个存储单元会被赋予一个地址（保存在MAR中），我们通过这个地址来访问存储字（保存在MAR中）。</p>
<h5 id="MAR-和-MDR"><a href="#MAR-和-MDR" class="headerlink" title="MAR 和 MDR"></a>MAR 和 MDR</h5><ul>
<li>MAR：存储器<strong>地址</strong>寄存器。反映了存储单元的个数。用于存放储存单元的索引地址。</li>
<li>MDR：存储器<strong>数据</strong>寄存器。反映了储存字长。</li>
</ul>
<p>两个寄存器位于CPU内部。</p>
<p>对于一个存储体而言，假设MAR&#x3D;4位，MDR&#x3D;8位，由于4位的MAR可以保存16个不同的地址，因此储存体中包含的存储单元个数为$2^4&#x3D;16$，每一个储存单元的字长为8。</p>
<h4 id="运算器的基本组成"><a href="#运算器的基本组成" class="headerlink" title="运算器的基本组成"></a>运算器的基本组成</h4><p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20231112120638463.png" alt="image-20231112120638463"></p>
<p>其中，ACC、MQ、X是三个寄存器。右侧表图中展示了不同运算中，相应的运算数是储存在哪一个寄存器中的。</p>
<p>其中MQ寄存器参与计算乘法和除法。因为乘法和除法会大幅度的改变数据的长度，可能造成一个寄存器无法保存完整的结果。因此引入了MQ寄存器。</p>
<h5 id="加法运算的过程"><a href="#加法运算的过程" class="headerlink" title="加法运算的过程"></a>加法运算的过程</h5><ul>
<li>指令：加法操作码 加数地址</li>
<li>在执行指令之前，需要把被加数取到ACC中</li>
</ul>
<ol>
<li>将加数取到寄存器X之中</li>
<li>进行加法运算，并将结果写入到ACC中</li>
</ol>
<h5 id="减法操作"><a href="#减法操作" class="headerlink" title="减法操作"></a>减法操作</h5><ul>
<li>指令：减法操作码 减数地址</li>
<li>在执行指令之前，需要把被减数取到ACC中</li>
</ul>
<ol>
<li>将减数取到寄存器X中</li>
<li>进行减法运算，并将结果写入到ACC中</li>
</ol>
<h5 id="乘法操作"><a href="#乘法操作" class="headerlink" title="乘法操作"></a>乘法操作</h5><ul>
<li>指令：乘法操作码 乘数地址</li>
<li>在执行指令之前，需要把被乘数取到ACC中</li>
</ul>
<ol>
<li>将乘数取到MQ寄存器中</li>
<li>将ACC的内容复制到X寄存器中</li>
<li>将ACC清零</li>
<li>进行乘法运算，将高位结果保存在ACC中，低位结果保存在MQ当中</li>
</ol>
<h5 id="除法操作"><a href="#除法操作" class="headerlink" title="除法操作"></a>除法操作</h5><ul>
<li>指令：除法操作码 除数地址</li>
<li>在执行指令之前，需要把被除数取到ACC中</li>
</ul>
<ol>
<li>将除数取到寄存器X中</li>
<li>进行除法运算，将商保存在MQ中，余数保存在ACC中</li>
</ol>
<h4 id="控制器的基本组成"><a href="#控制器的基本组成" class="headerlink" title="控制器的基本组成"></a>控制器的基本组成</h4><ul>
<li>CU：控制单元，负责控制操作的执行顺序。</li>
<li>PC：存放下一条指令的地址，能够自增。</li>
<li>IR：是一个寄存器，存放当前正在执行的指令。</li>
</ul>
<h2 id="主机完成一条指令的过程"><a href="#主机完成一条指令的过程" class="headerlink" title="主机完成一条指令的过程"></a>主机完成一条指令的过程</h2><h3 id="取数操作"><a href="#取数操作" class="headerlink" title="取数操作"></a>取数操作</h3><h4 id="取指令部分"><a href="#取指令部分" class="headerlink" title="取指令部分"></a>取指令部分</h4><ol>
<li>将PC中的地址送入MAR。</li>
<li>MAR将地址送给存储体。</li>
<li>存储体在控制器的控制下将对应地址的存储字节（指令）取出。</li>
<li>将指令送入MDR。</li>
<li>MDR将指令送入IR。控制单元能处理指令中的操作码，指令中的数据地址需要继续进行寻址取值操作。</li>
<li>PC++</li>
</ol>
<h4 id="取操作数部分"><a href="#取操作数部分" class="headerlink" title="取操作数部分"></a>取操作数部分</h4><ol>
<li>IR将操作数地址送入MAR。</li>
<li>MAR将地址送入存储体。</li>
<li>存储体在控制器的控制下将对应地址的存储字节（指令）取出。</li>
<li>将操作数送入MDR。</li>
<li>将操作数送入ACC</li>
</ol>
<h3 id="存数操作"><a href="#存数操作" class="headerlink" title="存数操作"></a>存数操作</h3><h4 id="取指令部分-1"><a href="#取指令部分-1" class="headerlink" title="取指令部分"></a><a href="#%E5%8F%96%E6%8C%87%E4%BB%A4%E9%83%A8%E5%88%86">取指令部分</a></h4><h4 id="存数部分"><a href="#存数部分" class="headerlink" title="存数部分"></a>存数部分</h4><ol>
<li>IR将待存入单元的地址送入MAR。</li>
<li>MAR将地址送入存储体。</li>
<li>将ACC的内容送入到MDR。</li>
<li>存储体在控制器的控制下将MDR的内容保存到对应位置。</li>
</ol>
<h2 id="计算机硬件的主要技术指标"><a href="#计算机硬件的主要技术指标" class="headerlink" title="计算机硬件的主要技术指标"></a>计算机硬件的主要技术指标</h2><h3 id="机器字长"><a href="#机器字长" class="headerlink" title="机器字长"></a>机器字长</h3><p>定义：CPU一次能处理的数据的位数。通常情况下与寄存器的位数相等。</p>
<h3 id="运算速度"><a href="#运算速度" class="headerlink" title="运算速度"></a>运算速度</h3><ul>
<li>主频</li>
<li>核数，每个核所支持的线程数。</li>
<li>吉普森法：$T_M&#x3D;\sum_{i&#x3D;1}^nf_it_i$，其中$f_i$为$i$指令出现的频率，$t_i$为一条$i$指令的执行时间。</li>
<li>CPI：执行一条指令所需的时钟周期数。</li>
<li>IPC：一个时钟周期能执行多少条指令。</li>
<li>MIPS：每秒能执行几百万指令。</li>
<li>FLOPS：每秒浮点运算次数。</li>
</ul>
<h3 id="存储容量"><a href="#存储容量" class="headerlink" title="存储容量"></a>存储容量</h3><h4 id="主存容量"><a href="#主存容量" class="headerlink" title="主存容量"></a>主存容量</h4><ul>
<li>存储单元个数 $\times$ 存储字长 $\rightarrow$ $2^{len(MAR)} \times len(MDR)$</li>
<li>字节数</li>
</ul>
<h1 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="传送方式"><a href="#传送方式" class="headerlink" title="传送方式"></a>传送方式</h3><ul>
<li>串行传送：通过一根总线传输。可以长距离传输。</li>
<li>并行传送：通过一排并在一起的总线传输。由于所传输的信号之间可能存在干扰。因此，并行总线一般比较短。</li>
</ul>
<h3 id="采用何种总线方式？"><a href="#采用何种总线方式？" class="headerlink" title="采用何种总线方式？"></a>采用何种总线方式？</h3><h4 id="单总线结构及其存在的问题"><a href="#单总线结构及其存在的问题" class="headerlink" title="单总线结构及其存在的问题"></a>单总线结构及其存在的问题</h4><p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20231112144052697.png" alt="image-20231112144052697"></p>
<p>问题：由于单总线同一时间只能处理一个需求，所以，当总线读取或写入IO设备时，CPU无法进行取址运算操作。</p>
<h4 id="以CPU为中心的双总线结构及其存在的问题"><a href="#以CPU为中心的双总线结构及其存在的问题" class="headerlink" title="以CPU为中心的双总线结构及其存在的问题"></a>以CPU为中心的双总线结构及其存在的问题</h4><p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20231112144301566.png" alt="image-20231112144301566"></p>
<p>单独为CPU和主存之间设立总线，让读写IO进行的同时，CPU可以进行取址运算。</p>
<p>问题：IO设备无法直接链接主存，IO设备和主存之间无法直接进行信息传输。</p>
<h4 id="以主存为中心的双总线结构"><a href="#以主存为中心的双总线结构" class="headerlink" title="以主存为中心的双总线结构"></a>以主存为中心的双总线结构</h4><p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20231112144848031.png" alt="image-20231112144848031"></p>
<h2 id="总线分类"><a href="#总线分类" class="headerlink" title="总线分类"></a>总线分类</h2><ul>
<li><p>片内总线：芯片内部总线</p>
</li>
<li><p>系统总线：计算机各部件之间的信息传输线，也是CPU与主存的通信线。</p>
<ul>
<li>数据总线：传输数据，双向，与机器字长、存储字长有关</li>
<li>地址总线：由CPU发出，单向，与储存地址、IO地址有关</li>
<li>控制总线：有出有入</li>
</ul>
</li>
<li><p>通信总线：与其它系统进行通信</p>
<ul>
<li>串行通信总线</li>
<li>并行通信总线</li>
</ul>
</li>
</ul>
<h2 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h2><p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20231112150836741.png" alt="image-20231112150836741"></p>
<h2 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h2><h3 id="单总线结构"><a href="#单总线结构" class="headerlink" title="单总线结构"></a><a href="#%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98">单总线结构</a></h3><h3 id="多总线结构"><a href="#多总线结构" class="headerlink" title="多总线结构"></a>多总线结构</h3><h4 id="双总线结构"><a href="#双总线结构" class="headerlink" title="双总线结构"></a>双总线结构</h4><h5 id="以CPU为中心的双总线结构"><a href="#以CPU为中心的双总线结构" class="headerlink" title="以CPU为中心的双总线结构"></a><a href="#%E4%BB%A5CPU%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84%E5%8F%8C%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98">以CPU为中心的双总线结构</a></h5><h5 id="以主存为中心的双总线结构-1"><a href="#以主存为中心的双总线结构-1" class="headerlink" title="以主存为中心的双总线结构"></a><a href="%E4%BB%A5%E4%B8%BB%E5%AD%98%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84%E5%8F%8C%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84">以主存为中心的双总线结构</a></h5><h5 id="主存总线与IO总线分离的双总线结构"><a href="#主存总线与IO总线分离的双总线结构" class="headerlink" title="主存总线与IO总线分离的双总线结构"></a>主存总线与IO总线分离的双总线结构</h5><p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20231112151953664.png" alt="image-20231112151953664"></p>
<p>通道是一个具有特殊功能的处理器，由通道对IO进行统一管理。</p>
<h4 id="三总线结构"><a href="#三总线结构" class="headerlink" title="三总线结构"></a>三总线结构</h4><h5 id="将以主存为中心的双总线结构扩展为三总线结构"><a href="#将以主存为中心的双总线结构扩展为三总线结构" class="headerlink" title="将以主存为中心的双总线结构扩展为三总线结构"></a>将以主存为中心的双总线结构扩展为三总线结构</h5><p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20231112152505519.png" alt="image-20231112152505519"></p>
<h5 id="局部总线、系统总线、扩展总线，三总线结构"><a href="#局部总线、系统总线、扩展总线，三总线结构" class="headerlink" title="局部总线、系统总线、扩展总线，三总线结构"></a>局部总线、系统总线、扩展总线，三总线结构</h5><p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20231112152710883.png" alt="image-20231112152710883"></p>
<p>问题：由于所有的外设全部连接到扩展总线上，因此会影响外设的工作速度。</p>
<h4 id="四总线结构"><a href="#四总线结构" class="headerlink" title="四总线结构"></a>四总线结构</h4><p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20231112152913094.png" alt="image-20231112152913094"></p>
<h2 id="总线的控制"><a href="#总线的控制" class="headerlink" title="总线的控制"></a>总线的控制</h2><ul>
<li>总线的判优控制：多个设备竞争总线，应该如何分配总线？</li>
<li>如何完成总线通信：当设备占用总线后，如何完成通信，保证正确性？</li>
</ul>
<h3 id="总线的判优控制"><a href="#总线的判优控制" class="headerlink" title="总线的判优控制"></a>总线的判优控制</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>主设备（主模块）：对总线有控制权。</li>
<li>从设备（从模块）：相应从主设备发来的命令。</li>
</ul>
<h4 id="控制类型"><a href="#控制类型" class="headerlink" title="控制类型"></a>控制类型</h4><ul>
<li><p>集中式</p>
</li>
<li><p>链式查询</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20231112153925516.png" alt="image-20231112153925516"></p>
<p>流程：</p>
<ol>
<li>外设通过BR向总线控制部件发出总线占用请求</li>
<li>在总线空闲时，BG按顺序寻找第一个发出占用请求的外设</li>
<li>外设收到BG信号，占用总线，并将BS设置为”忙“</li>
</ol>
<p>优先级：和外设的连接顺序有关</p>
<p>对电路故障敏感，如果有一个外设出现故障，会造成BG的断裂，则判优过程无法继续。</p>
</li>
<li><p>计数器定时查询</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20231112154543139.png" alt="image-20231112154543139"></p>
<p>流程：</p>
<ol>
<li>外设通过BR向总线控制部件发出总线占用请求</li>
<li>在总线空闲时，设备地址线按地址寻找发出占用请求的外设。（从0到n依次查找）</li>
<li>外设收到设备地址线信号，占用总线，并将BS设置为”忙“</li>
</ol>
<p>优先级：和计数器计数方式有关，可以通过设置初始值和递增策略改变优先级。</p>
<p>缺点：设备地址线需要传输$log_2^N$个字节来确定使用哪个设备，其中$N$是设备个数。</p>
</li>
<li><p>独立请求方式</p>
<p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20231112155418399.png" alt="image-20231112155418399"></p>
<p>流程：</p>
<ol>
<li>外设通过BR向总线控制部件发出总线占用请求</li>
<li>在总线空闲时，BG按地排队器寻找发出占用请求的外设。</li>
<li>外设收到设备地址线信号，占用总线</li>
</ol>
<p>优先级：和排队器的排队方式有关。</p>
<p>缺点：每一个设备都需要一个单独的BR线和一个单独的BG线。</p>
</li>
<li><p>分布式</p>
</li>
</ul>
<h3 id="总线的通信控制"><a href="#总线的通信控制" class="headerlink" title="总线的通信控制"></a>总线的通信控制</h3><ul>
<li>目的：解决通信双方协调配合问题。</li>
<li>总线传输周期：主设备和从设备形成一次完整的可靠的通信所需要的时间。</li>
</ul>
<p>总线的通信控制分为以下四步：</p>
<ol>
<li>申请分配阶段：主设备申请总线的使用权。</li>
<li>寻址阶段：主设备向从设备发出地址和命令。主设备需要找到从设备。</li>
<li>传数阶段：主设备和从设备交换数据。</li>
<li>结束阶段：主设备和从设备撤销相关的信息。</li>
</ol>
<p>总线通信的四种方式：</p>
<ul>
<li>同步通信：由统一时标控制数据传送。</li>
<li>异步通信：采用应答模式，没有统一的始终标准。</li>
<li>半同步通信：同步和异步相结合。</li>
<li>分离式通信：充分挖掘系统总线的潜力。</li>
</ul>
<h3 id="总线通信的四种方式"><a href="#总线通信的四种方式" class="headerlink" title="总线通信的四种方式"></a>总线通信的四种方式</h3><h4 id="同步通信"><a href="#同步通信" class="headerlink" title="同步通信"></a>同步通信</h4><table>
<thead>
<tr>
<th align="center">时钟信号</th>
<th align="center">同步读取动作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1$\uparrow$</td>
<td align="center">主设备将从设备的地址发布到地址总线上</td>
</tr>
<tr>
<td align="center">2$\uparrow$</td>
<td align="center">主设备给出读命令</td>
</tr>
<tr>
<td align="center">3$\uparrow$</td>
<td align="center">在第三个时钟周期到达之前，从设备必须将数据发布到数据总线上</td>
</tr>
<tr>
<td align="center">4$\uparrow$</td>
<td align="center">这设备撤销数据，撤销读命令</td>
</tr>
<tr>
<td align="center">4$\downarrow$</td>
<td align="center">撤销地址信息</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">时钟信号</th>
<th align="center">同步写入动作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1$\uparrow$</td>
<td align="center">主设备将从设备的地址发布到地址总线上</td>
</tr>
<tr>
<td align="center">1$\downarrow$</td>
<td align="center">主设备将数据发布到数据总线上</td>
</tr>
<tr>
<td align="center">2$\uparrow$</td>
<td align="center">主设备给出写命令</td>
</tr>
<tr>
<td align="center">3$\uparrow$</td>
<td align="center">执行写入操作</td>
</tr>
<tr>
<td align="center">4$\uparrow$</td>
<td align="center">主设备撤销数据，撤销写命令</td>
</tr>
<tr>
<td align="center">4$\downarrow$</td>
<td align="center">撤销地址信息</td>
</tr>
</tbody></table>
<p>由于强制不同的设备使用统一时钟，所以，我们必须使用较慢的设备的时钟，才能完成通信。</p>
<h4 id="异步通信"><a href="#异步通信" class="headerlink" title="异步通信"></a>异步通信</h4><ul>
<li>不互锁：主设备发送一次请求，从设备就收请求，开环无反馈。</li>
<li>半互锁：主设备持续发出请求，从设备接收到请求后发送一次应答信号给主设备，主设备接收到应答信号后撤销请求。</li>
<li>全互锁： 主设备持续发出请求，从设备接收到请求后持续发送应答信号给主设备，主设备接收到应答信号后撤销请求，只有当主设备撤销请求后，从设备才停止发送应答信号。</li>
</ul>
<h4 id="半同步通信"><a href="#半同步通信" class="headerlink" title="半同步通信"></a>半同步通信</h4><p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20231112190652585.png" alt="image-20231112190652585"></p>
<p>允许不同速度的主从设备之间进行信息交换。</p>
<h4 id="分离式通信"><a href="#分离式通信" class="headerlink" title="分离式通信"></a>分离式通信</h4><p>同步和异步通信的过程中并不是一直占用总线，为了充分利用总线，提出了分离式通信方法。</p>
<p>在从设备准备数据时让出总线，当数据准备好后，从设备再申请占用总线。这样，总线空出时可以供别的通信使用。</p>
<h1 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h3><ol>
<li>按存储介质进行分类<ul>
<li>半导体存储器：TTL、MOS</li>
<li>磁表面的存储器：磁头、磁载体</li>
<li>磁心存储器：硬磁材料、环状元件</li>
<li>光盘存储器：激光、磁光材料</li>
</ul>
</li>
<li>按存储方式分类<ul>
<li>存储方式与物理地址无关（随机访问）</li>
<li>存储方式与物理地址有关（串行访问）</li>
</ul>
</li>
<li>按存储器在计算机中的作用<ul>
<li>主存储器<ul>
<li>RAM<ul>
<li>静态RAM</li>
<li>动态RAM</li>
</ul>
</li>
<li>ROM<ul>
<li>MROM</li>
<li>PROM</li>
<li>EPROM</li>
<li>EEPROM</li>
</ul>
</li>
</ul>
</li>
<li>Flash Memory：作为主存和辅存之间的缓冲区</li>
<li>辅助存储器</li>
<li>高速缓冲存储器</li>
</ul>
</li>
</ol>
<h3 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h3><p><img src="/2023/09/16/%E5%9B%9B%E5%A4%A7%E4%BB%B6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20231112193520483.png" alt="image-20231112193520483"></p>
<p>缓存一部分在CPU中，一部分在CPU外。</p>
<h2 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h2><p><img src="/.%5Cassets%5Cimage.png" alt="Alt text"></p>
<ol>
<li>MAR中的地址经过译码器和驱动器后到存储体中寻址。</li>
<li>控制电路负责控制当前的寻址操作是为了读还是为了写。</li>
<li>如果为了读，则取出地址对应的数据交给MDR。</li>
<li>如果为了写，则读出MDR的数据存入对应的地址。</li>
<li>MAR与MDR分别与地址总线和数据总线相连接。</li>
</ol>
<h2 id="主存和CPU之间的联系"><a href="#主存和CPU之间的联系" class="headerlink" title="主存和CPU之间的联系"></a>主存和CPU之间的联系</h2><p><img src="/.%5Cassets%5Cimage-1.png" alt="Alt text"></p>
<ol>
<li>MAR和MDR是CPU中的地址寄存器和数据寄存器。</li>
<li>MDR直接链接数据总线。数据可以进行双向传输。</li>
<li>MAR直接连接地址总线。地址总线只能从CPU发出，是单向的。</li>
<li>CPU与主存之间还连接着控制总线，用于控制读、写操作。</li>
</ol>
<h2 id="主存中内存单元地址的分配"><a href="#主存中内存单元地址的分配" class="headerlink" title="主存中内存单元地址的分配"></a>主存中内存单元地址的分配</h2><p><img src="/.%5Cassets%5Cimage-2.png" alt="Alt text"></p>
<p><em>图注释：一个字节的长度永远是8位，一个字的长度却决于计算机主存的存储单元长度。一个字需要使用多个字节来存储。每个字节有自己的地址，每个字也有自己的地址。图片展示了字和字节在内存大小和地址上的关系。字的地址，是储存它的内存单元的低位字节的地址。而字的存储是采用大端存储还是小端存储决定了字的高位是储存在储存单元的高位还是低位。直接决定了字的寻址方式。一个字节可以储存8位2进制数，也就是2位16进制数。</em></p>
<ul>
<li><p>大尾方式</p>
<p>将字的高位字节保存在存储字的低位，并将高位字节的地址作为字地址。</p>
</li>
<li><p>小尾方式</p>
<p>将字的低位字节保存在储存字的低位，并将低位字节的地址作为字地址。</p>
</li>
</ul>
<p>若地址线有 24 根，则按 字节 寻址：$2^{24}&#x3D;16MB$</p>
<p>若字长为 16 位，则按 字长 寻址：$8MW$。（W是字）</p>
<p>若字长为 32 位，则按 子长 寻址：$4MW$。</p>
<h2 id="主存的技术指标"><a href="#主存的技术指标" class="headerlink" title="主存的技术指标"></a>主存的技术指标</h2><ul>
<li>存储容量</li>
<li>存储速度<ul>
<li>存取时间&#x3D;存储器的访问时间+读出时间&#x2F;写入时间</li>
<li>存取周期&#x3D;连续两次独立的读&#x2F;写操作的时间间隔</li>
</ul>
</li>
<li>存储器的带宽</li>
</ul>
<h2 id="半导体芯片的简介"><a href="#半导体芯片的简介" class="headerlink" title="半导体芯片的简介"></a>半导体芯片的简介</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p><img src="/.%5Cassets%5Cimage-3.png" alt="Alt text"></p>
<p><em>图解释：片选线能够让计算机访问指定的存储体来获得数据。</em></p>
<p>地址线的数量和数据线的数量实际上说明了该存储体的容量大小。例如：</p>
<table>
<thead>
<tr>
<th align="center">地址线（单向）</th>
<th align="center">数据线（双向）</th>
<th align="center">芯片容量（bit）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10</td>
<td align="center">4</td>
<td align="center">$2^{10} \cdot 4 bit$</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">1</td>
<td align="center">$2^{14} \cdot 1 bit$</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">8</td>
<td align="center">$2^{13} \cdot 8 bit$</td>
</tr>
</tbody></table>
<p>半导体芯片的 片选线 一般有两种，分别是 $\overline{CS}$ 和 $\overline{CE}$。上横线代表低电平有效。</p>
<p>读写控制线可以用一根信号线 $\overline{WE}$，低电平写，高电平读；也可以用两根线 $\overline{OE}$ 和 $\overline{WE}$ 分别代表读操作和写操作。</p>
<h3 id="半导体芯片的译码驱动方式"><a href="#半导体芯片的译码驱动方式" class="headerlink" title="半导体芯片的译码驱动方式"></a>半导体芯片的译码驱动方式</h3><ul>
<li>线选法</li>
</ul>
<p><img src="/.%5Cassets%5Cimage-4.png" alt="Alt text"></p>
<p>问题：假设我们存储单元的容量是 $1M \cdot 8bit$，那么需要地址线 20 条，经过译码器后，字选择线变成了 1M 条。太密集了。</p>
<ul>
<li>重合法</li>
</ul>
<p><img src="/assets%5Cimage-5.png" alt="Alt text"></p>
<p>行列地址结合译码</p>
<h3 id="随机存取存储器（RAM）"><a href="#随机存取存储器（RAM）" class="headerlink" title="随机存取存储器（RAM）"></a>随机存取存储器（RAM）</h3><h4 id="动态RAM的刷新"><a href="#动态RAM的刷新" class="headerlink" title="动态RAM的刷新"></a>动态RAM的刷新</h4><ul>
<li>集中刷新：会产生一个刷新时间死区，这个时间内不能够进行读写操作。</li>
<li>分散刷新：无死区但是延长了存取周期。</li>
<li>异步刷新：将刷新安排在指令译码阶段。</li>
</ul>
<h4 id="动态RAM和静态RAM比较"><a href="#动态RAM和静态RAM比较" class="headerlink" title="动态RAM和静态RAM比较"></a>动态RAM和静态RAM比较</h4><table>
<thead>
<tr>
<th align="center">-</th>
<th align="center">DRAM</th>
<th align="center">SRAM</th>
</tr>
</thead>
<tbody><tr>
<td align="center">储存原理</td>
<td align="center">电容</td>
<td align="center">触发器</td>
</tr>
<tr>
<td align="center">集成度</td>
<td align="center">高</td>
<td align="center">低</td>
</tr>
<tr>
<td align="center">芯片引脚</td>
<td align="center">少</td>
<td align="center">多</td>
</tr>
<tr>
<td align="center">功耗</td>
<td align="center">小</td>
<td align="center">大</td>
</tr>
<tr>
<td align="center">价格</td>
<td align="center">低</td>
<td align="center">高</td>
</tr>
<tr>
<td align="center">速度</td>
<td align="center">慢</td>
<td align="center">快</td>
</tr>
<tr>
<td align="center">刷新</td>
<td align="center">有</td>
<td align="center">无</td>
</tr>
</tbody></table>
<p>DRAM会把行地址和列地址分开，属于重合法译码，所以线少。</p>
<p>SRAM由于需要保证高速性，因此拒绝使用行列地址结合译码的方式和，而是采用线选法。所以线多。</p>
<p>DRAM由于是采用电容来存储01数据的，所以需要定时刷新。而SRAM采用触发器保存01数据，不需要刷新。</p>
<h3 id="只读存储器ROM"><a href="#只读存储器ROM" class="headerlink" title="只读存储器ROM"></a>只读存储器ROM</h3><p><img src="/assets%5Cimage-6.png" alt="Alt text"></p>
<p><img src="/assets%5Cimage-7.png" alt="Alt text"></p>
<p><img src="/assets%5Cimage-8.png" alt="Alt text"></p>
<h2 id="CPU和主存储器的连接"><a href="#CPU和主存储器的连接" class="headerlink" title="CPU和主存储器的连接"></a>CPU和主存储器的连接</h2><h3 id="存储器容量扩展"><a href="#存储器容量扩展" class="headerlink" title="存储器容量扩展"></a>存储器容量扩展</h3><ul>
<li><p>位扩展（储存字长扩展）</p>
<p>例如：将一个 $1K \cdot 4 bit$ 的存储器扩展为 $1K \cdot 8 bit$。</p>
<p>用两个 $1K \cdot 4 bit$ 的存储器连接在一起，两个芯片的各自的存储单元共享相同的地址，这样，一个地址就可以取出 8 bit。另外，两个存储体的片选线一定要连接在一起，使两个芯片能同时进行工作。</p>
<p><img src="/assets%5Cimage-10.png" alt="Alt text"></p>
</li>
<li><p>字扩展（增加存储字的数量）</p>
<p>增加存储字的数量实际上是增加储存体可寻址的范围。</p>
<p>例如：将一个 $1K \cdot 4 bit$ 的存储器扩展为 $2K \cdot 4 bit$。</p>
<p><img src="/assets%5Cimage-11.png" alt="Alt text"></p>
<p>核心思想为，通过片选线，让两个存储器不能同时工作。</p>
</li>
<li><p>字和位的扩展</p>
<p>例如：将一个 $1K \cdot 4 bit$ 的存储器扩展为 $4K \cdot 8 bit$。</p>
<p>结合字扩展和位扩展完成。</p>
</li>
</ul>
<h2 id="储存器的校验"><a href="#储存器的校验" class="headerlink" title="储存器的校验"></a>储存器的校验</h2><h3 id="编码的最小距离"><a href="#编码的最小距离" class="headerlink" title="编码的最小距离"></a>编码的最小距离</h3><ul>
<li>定义：任意两组合法代码之间的 二进制位数 的 最少差异。</li>
<li>编码的最小距离越大，纠错能力越强。</li>
</ul>
<p>$L-1&#x3D;D+C,(D \ge C )$</p>
<p>式中：</p>
<ul>
<li>L——编码的最小距离</li>
<li>D——检测错误的位数</li>
<li>C——纠正错误的位数</li>
</ul>
<p>在计算过程中，我们首先算出$L$，然后算出$D$，最后推出$C$.</p>
<p><img src="/assets%5Cimage-12.png" alt="Alt text"></p>
<p>其中$D$的计算方式如下：<br>比如，合法代码集合位 {00000， 11111}，我们获得的代码串为 11100，对于这个代码串的出现，可能有两种情况，分别是 00000 变了三位，或者 11111 变了两位，但是，改变三位相比于改变两位的概率更低，因此我们认为 11100 是 11111 改变了两位。于是可以得到，对于这个合法代码集，我们最多只能够推断出2位错误，因此$D&#x3D;2$。</p>
<h3 id="汉明码的组成"><a href="#汉明码的组成" class="headerlink" title="汉明码的组成"></a>汉明码的组成</h3><h4 id="大致过程"><a href="#大致过程" class="headerlink" title="大致过程"></a>大致过程</h4><ul>
<li>汉明码采用奇偶校验：在一组代码前加入一位，来确保该组代码的1有偶数个。</li>
<li>汉明码采用非划分方式的分组校验</li>
</ul>
<p>汉明码的校验流程如下：</p>
<ul>
<li><p>我们有一串数据，我们对这串数据的位置进行标号 {1, 2, 3, 4, 5, 6 ,7}</p>
</li>
<li><p>将该串数据分为三组，我们将标号填写到圆圈中，每个圆圈代表一组，如下：</p>
<p><img src="/assets%5Cimage-13.png" alt="Alt text"></p>
<p><em>图解释：图中的数字代表代码的为指标号。圆圈代表不同的组。可以看到， {1, 2, 3, 4, 5, 6, 7} 这一串数据被分为三组，分别是 {1, 3, 5, 7}，{2, 3, 6, 7} 和 {4, 5, 6, 7}。每一组中有特有的元素，也有共有的元素。</em></p>
<p><strong>分组的规则</strong>是，将该代码串位置编码写为2进制数，满足 xx1 的分为第一组，即 {1, 3, 5, 7}；满足 x1x 的分为第二组，即 {2, 3, 6, 7}；满足 1xx 的分为第三组，即 {4, 5, 6, 7}。</p>
</li>
<li><p>对每一组数据进行奇偶校验。我们将对第一组、第二组、第三组的奇偶校验结果记为 $P_1, P_2, P_3$，并规定，通过奇偶校验时 $P_i&#x3D;0$，未通过时 $P_i&#x3D;1$。校验可能出现的结果如下（我们假设只有一位代码出错）：</p>
<table>
<thead>
<tr>
<th align="center">$P_3$</th>
<th align="center">$P_2$</th>
<th align="center">$P_1$</th>
<th align="center">出错的代码位置</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">7</td>
</tr>
</tbody></table>
<p>可以看出，校验结果，按照一定顺序排列好后，所组成的二进制数的数值就是出错代码的位置。</p>
</li>
</ul>
<h4 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h4><ul>
<li><p>更多细节</p>
<ul>
<li><p>校验位插入到什么位置？</p>
<p>$2^k$</p>
</li>
<li><p>需要多少位校验码？需要分为多少组？</p>
<p>$2^k \ge n+k+1$</p>
<p>其中 k 是需要插入的校验位的数量，n为代码穿长度。</p>
<p>因为我们需要依靠校验位得到代码串出错的位置，因此，校验位能够编码的长度 $2^k$ 必须大于等于 加入校验位后整个代码串的长度加1。之所以加1，是因为要包含不出错的情况。</p>
<p>分组数量等于校验码的位数。</p>
</li>
<li><p>校验位如何取值？</p>
<p>加入校验位后需要让其组内的1为偶数个。</p>
</li>
</ul>
</li>
<li><p>示例：求0101按“偶校验”配置汉明编码：</p>
<ol>
<li><p>计算需要的校验位&#x2F;需要分为几组？</p>
<p>$n&#x3D;4$ 需要满足 $2^k \ge n+k+1$，求得 $k&#x3D;3$。</p>
</li>
<li><p>插入校验位</p>
<p>校验位的位置为 $2^i$，因此插入后的数据（汉明码）为：$?_1 ?_2 0 ?_4 101$。</p>
<p>其中 $?_i$ 是占位符，因为我们暂时还不知道该位应该是0还是1。</p>
</li>
<li><p>对插入校验位的代码分组，并确定校验位的值</p>
<p>第一组 xx1：$?_1 011 \rightarrow 0011$</p>
<p>第二组 x1x：$?_2 0 01 \rightarrow 1001$</p>
<p>第三组 1xx：$?_4 1 0 1 \rightarrow 0101$</p>
<p>因此，汉明码的值为：0100101</p>
</li>
</ol>
</li>
</ul>
<h3 id="汉明码的纠错"><a href="#汉明码的纠错" class="headerlink" title="汉明码的纠错"></a>汉明码的纠错</h3><ol>
<li><p>首先，通信的两个设备有共同的协议，即他们知晓编码方式为汉明码，并且知晓数据的校验方式。</p>
</li>
<li><p>根据代码的长度推算出分组数。</p>
</li>
<li><p>将代码分组并进行校验。</p>
<p>$P_1&#x3D;C_1 \bigoplus C_3 \bigoplus C_5 \bigoplus C_7$</p>
<p>$P_2&#x3D;C_2 \bigoplus C_3 \bigoplus C_6 \bigoplus C_7$</p>
<p>$P_1&#x3D;C_4 \bigoplus C_5 \bigoplus C_6 \bigoplus C_7$</p>
<p>其中，$C_i$为汉明码第 i 个位置的值。</p>
</li>
<li><p>纠错</p>
</li>
</ol>
<h2 id="提高访存速度"><a href="#提高访存速度" class="headerlink" title="提高访存速度"></a>提高访存速度</h2><ul>
<li>采用高速器件</li>
<li>采用层次结构 cache-主存</li>
<li>调整主存结构</li>
</ul>
<h3 id="如何调整主存结构"><a href="#如何调整主存结构" class="headerlink" title="如何调整主存结构"></a>如何调整主存结构</h3><ul>
<li><p>单体多字系统</p>
<p>方案：为了加快主存访问速度，我们一次性从主存中取出更多数据，所取出的数据长度是机器字长的倍数。这样，存储器的一次读写操作可供cpu使用多次。在使用时，我们将存储体中的数据存入到数据寄存器中，然后通过单字长寄存器逐步读入数据寄存器中的内容，并由单字长寄存器将一条指令交给cpu。</p>
<p>问题：指令可能存在跳转，在这种情况下，多读入的数据变得没有意义；另外，在写入数据时，我们需要写入与取出的数据等量的数据，因此，虽然我们只想写入一个机器字长的数据，但是也会覆盖多余长度的数据，可能造成错误。</p>
<p><img src="/assets%5Cimage-14.png" alt="Alt text"></p>
</li>
<li><p>多体并行系统</p>
<ul>
<li><p>高位交叉（储存器字长扩展）</p>
<p>方案：我们将10个字节存入一个存储体，他需要写入十次。但是如果我们将10个存储体并列，每个存储体就只需写入一次，可以缩短读写时间。高位交叉是纵向存储地址。</p>
<p>问题：如果每次只写入一个字节，那么除了第一个存储体以外，其他的存储体就处于围观状态。</p>
<p><img src="/assets%5Cimage-15.png" alt="Alt text"></p>
</li>
<li><p>低位交叉</p>
<p><img src="/assets%5Cimage-16.png" alt="Alt text"></p>
<p><em>图解释：相比于高位交叉，低位交叉是横向顺序地址，有效防止了其他存储器旁观。</em></p>
</li>
</ul>
</li>
</ul>
<h2 id="高速缓冲处理器"><a href="#高速缓冲处理器" class="headerlink" title="高速缓冲处理器"></a>高速缓冲处理器</h2><h3 id="程序的局部性原理"><a href="#程序的局部性原理" class="headerlink" title="程序的局部性原理"></a>程序的局部性原理</h3><ul>
<li><p>时间局部性</p>
<p>当前被使用的数据，在不久的将来还会被使用</p>
</li>
<li><p>空间局部性</p>
<p>当前正在使用的数据，其相邻的数据会在不久的将来被使用</p>
</li>
</ul>
<h3 id="cache的工作原理"><a href="#cache的工作原理" class="headerlink" title="cache的工作原理"></a>cache的工作原理</h3><p>由于程序的局部性原理，我们将当前使用的数据和其所在的块放入cache，以加速cpu对数据的访问。</p>
<h4 id="命中与未命中"><a href="#命中与未命中" class="headerlink" title="命中与未命中"></a>命中与未命中</h4><p>缓存共有C块，主存共有M块。且 M&gt;&gt;C。</p>
<p>命中是指，缓存已经与主存的块之间建立了对应关系。此时的主存已经调入缓存块。</p>
<p>未命中是指，主存块未调入缓存，主存块与缓存块没有建立对应关系。</p>
<h4 id="Cache的命中率"><a href="#Cache的命中率" class="headerlink" title="Cache的命中率"></a>Cache的命中率</h4><p>CPU访问主存，如果有$n_1$次可以从缓存中读入数据，有$n_2$次从主存中读入数据，则命中率为$\frac{n_1}{n_2}$。</p>
<p>命中率和cache容量和块长有关。</p>
<p>容量越大越好。块适中较好。</p>
<p>一般情况下，一个块的大小为 4~8 个字。</p>
<h4 id="cache-主存系统的效率"><a href="#cache-主存系统的效率" class="headerlink" title="cache-主存系统的效率"></a>cache-主存系统的效率</h4><p>效率e与命中率有关 $e&#x3D;\frac{访问cache的时间}{平均访问时间}$</p>
<p>设访问cache的时间是$t_c$，访问主存的时间为$t_m$，cache的命中率为h，则 $e&#x3D;\frac{t_c}{h \times t_c + (1-h) \times t_m}$</p>
<h4 id="cache-的基本结构"><a href="#cache-的基本结构" class="headerlink" title="cache 的基本结构"></a>cache 的基本结构</h4><p><img src="/assets%5Cimage-17.png" alt="Alt text"></p>
<ol>
<li>cpu给出地址，该地址包括内存块的块号和块内地址。</li>
<li>内存块号在cache的地址映射和变换机构下确定，该块内存是否发生命中。内存块的块内地址和cache块的快内地址相同。<ul>
<li>如果发生命中，需要给出当前的内存块保存在哪一个cache块中。即将内存块号转换为cache块号。</li>
<li>如果没有命中，需要查询cache中是否有空间装入该块内存。<ul>
<li>如果有，则访问主存，将主存块装入cache块。</li>
<li>如果没有，则启用cache的替换机构。cache根据替换算法，决定哪一个cache块要从内存中退出。并将需要使用的内存块写入到cache块中。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>在这个过程中，地址映射决定了主存的块存在于cache块的哪些位置。变换机构，将主存的块号对应到cache的块号。</p>
<h4 id="cache-的读写操作"><a href="#cache-的读写操作" class="headerlink" title="cache 的读写操作"></a>cache 的读写操作</h4><ul>
<li><p>cache的读操作</p>
<p><img src="/assets%5Cimage-18.png" alt="Alt text"></p>
</li>
<li><p>cache的写操作</p>
<p>问题：写入cache后，会导致cache和主存的不一致。</p>
<ul>
<li>写直达法<ul>
<li>原理：同时写入cache块和主存块</li>
<li>问题：写入主存块的次数过多，会导致速度慢</li>
</ul>
</li>
<li>写回法<ul>
<li>原理：写入时只写入cache，当内存块要从cache块中退出时再写入主存。</li>
<li>问题：不同的设备的cache都有内存块的副本，会引发副本之间的一致性问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="cache的改进"><a href="#cache的改进" class="headerlink" title="cache的改进"></a>cache的改进</h4><ul>
<li>增加cache的级数</li>
<li>统一缓存和分立缓存<ul>
<li>统一缓存：指令和数据都放在同一个cache里</li>
<li>分立缓存：将指令和数据放在不同的cache中</li>
</ul>
</li>
</ul>
<h3 id="cache-主存的地址映射"><a href="#cache-主存的地址映射" class="headerlink" title="cache-主存的地址映射"></a>cache-主存的地址映射</h3><ul>
<li><p>直接映射</p>
<ul>
<li>方案：主存的某一个内存块，只能映射到某一个指定的cache块中。将主存分成若干个cache大小的区域，每一个区域的第一块内存只能放到cache的第一块中，每一个区域的第n块内存，只能放到cache的第n块中。cache的n块区域，可以来自不同的内存块。</li>
<li>问题：当cache块的第一个块的位置被占用时，其他主存区域的第一个块就无法被载入cache，即使cache的其他块区域有空闲。</li>
<li>特点：一个缓存块对应多个主存块；一个主存块对应一个cache块。</li>
<li>有点：速度快</li>
</ul>
</li>
<li><p>全相联映射</p>
<ul>
<li>方案：主存的任何一个字块可以存放在cache的任何一个块中。</li>
<li>问题：在cache中寻找对应的地址的块时，需要比对全部的cache块。</li>
<li>有点：cache的利用率高</li>
</ul>
</li>
<li><p>组相联映射</p>
<ul>
<li>方案：cache自身被分为若干个组。主存被分为若干个区，每个区的字块数量与cache的组数相同。主存每个区的第n个字块可以放入cache的第n组内。</li>
</ul>
</li>
</ul>
<h3 id="cache-主存的替换算法"><a href="#cache-主存的替换算法" class="headerlink" title="cache-主存的替换算法"></a>cache-主存的替换算法</h3><ul>
<li>先进先出算法</li>
<li>近期最少使用算法</li>
</ul>
<h1 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h1><h2 id="接口的功能和组成"><a href="#接口的功能和组成" class="headerlink" title="接口的功能和组成"></a>接口的功能和组成</h2><h3 id="IO接口电路"><a href="#IO接口电路" class="headerlink" title="IO接口电路"></a>IO接口电路</h3><ul>
<li><p>总线连接方式</p>
<ul>
<li>设备选择线：IO设备的地址线</li>
<li>数据线：完成数据的输入输出</li>
<li>命令线：控制设备的输入输出</li>
<li>状态线：从IO接口送入主机，让主机了解IO接口的工作状态。</li>
</ul>
<p><img src="/assets%5Cimage-19.png" alt="Alt text"></p>
</li>
</ul>
<h3 id="接口的功能和组成-1"><a href="#接口的功能和组成-1" class="headerlink" title="接口的功能和组成"></a>接口的功能和组成</h3><table>
<thead>
<tr>
<th align="center">功能</th>
<th align="center">组成</th>
</tr>
</thead>
<tbody><tr>
<td align="center">选址功能</td>
<td align="center">设备选择电路</td>
</tr>
<tr>
<td align="center">传送命令的功能</td>
<td align="center">命令寄存器、命令译码器</td>
</tr>
<tr>
<td align="center">传送数据的功能</td>
<td align="center">数据缓冲寄存器</td>
</tr>
<tr>
<td align="center">反应设备状态</td>
<td align="center">设备状态标记</td>
</tr>
</tbody></table>
<p>设备的状态包括：</p>
<ul>
<li>完成触发器：标志着设备是否准备好</li>
<li>工作触发器：标志外部设备工作状态，是否忙</li>
<li>中断请求触发器：触发中断，主动告诉主机，设备准备好</li>
<li>屏蔽触发器：屏蔽IO口的中断</li>
</ul>
<p><img src="/assets%5Cimage-20.png" alt="Alt text"></p>
<h3 id="接口的响应"><a href="#接口的响应" class="headerlink" title="接口的响应"></a>接口的响应</h3><h4 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h4><h5 id="程序查询的流程"><a href="#程序查询的流程" class="headerlink" title="程序查询的流程"></a>程序查询的流程</h5><ul>
<li>单设备情况<ol>
<li>cpu执行输入输出指令</li>
<li>输入输出指令发出启动设备的命令<ul>
<li>发出启动命令后cpu端：重复的检查状态标记，检查设备的数据是否准备好。<ul>
<li>如果准备就绪则进行数据交换</li>
<li>检查状态标记</li>
</ul>
</li>
<li>IO设备端<ul>
<li>IO设备接收到启动命令后就开始进行数据准备</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>多个设备的情况<ul>
<li>将参与数据传输的设备进行优先级排队<ul>
<li>cpu将按照优先级顺序进行查询</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="程序查询中数据传输的过程"><a href="#程序查询中数据传输的过程" class="headerlink" title="程序查询中数据传输的过程"></a>程序查询中数据传输的过程</h5><p>IO设备要想和内存单元进行数据交换，需要借助cpu中的寄存器。所以在进行数据交换之前，首先要将特定寄存器的内容进行暂存。然后才能开始数据传输。数据传输的逻辑如下：</p>
<p><img src="/assets%5Cimage-22.png" alt="Alt text"></p>
<p>图解：</p>
<ul>
<li>计数值：记录了当前需要传输的数据量。每传输一个字，计数值都发生相应的变化。</li>
<li>主存缓冲区首址：读入和写入的数据应当存放的位置。</li>
<li></li>
</ul>
<h4 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h4><p>中断：cpu接收到中断信号后，需要暂停当前程序的执行，保存中断现场，然后去执行中断服务程序。当终端服务执行完毕后，将返回到原程序中继续执行。</p>
<p>中断源：能够引发cpu发生中断的因素。</p>
<p>中断的部件组成：</p>
<ul>
<li>中断请求触发器、中断屏蔽触发器<ul>
<li>IO设置一个中断标志</li>
<li>cpu根据当前cpu执行的任务的重要性和重负服务程序的重要性设置终端屏蔽触发器</li>
<li>如果中断标志没有被屏蔽则会转变为中断请求，发送给cpu</li>
<li>如果被屏蔽了，则中断标志不会变为中断请求</li>
</ul>
</li>
<li>排队器<ul>
<li>cpu可能接收到很多中断，需要对这些中断按照重要性排序。比如高速设备的数据丢失得快，所以可能具有更高的中断优先级。</li>
</ul>
</li>
<li>中断向量地址形成部件<ul>
<li>中断服务程序在内存中的起始地址</li>
</ul>
</li>
</ul>
<p>排队器经过变换会得到向量地址。根据向量地址可以找到中断服务程序的地址。或者能够跳转到中断服务程序的指令。</p>
<p>排队器输出与向量地址的关系如下：</p>
<p><img src="/assets%5Cimage-23.png" alt="Alt text"></p>
<h3 id="IO中断的处理过程"><a href="#IO中断的处理过程" class="headerlink" title="IO中断的处理过程"></a>IO中断的处理过程</h3><ul>
<li><p>cpu 响应中断的条件和时间</p>
<ul>
<li>条件：cpu的内部有一个中断允许触发器，中断允许触发器决定了cpu是否可以处理中断。</li>
<li>时间：每条指令结束后，cpu会查询中断。</li>
</ul>
</li>
<li><p>IO中断的处理过程（以输入数据为例）</p>
<ul>
<li>cpu执行到输入指令，在地址线上给出输入设备的地址。</li>
<li>设备选择电路接收到设备地址后，对设备和设备的端口进行选择。被选择的设备 SEL 信号有效。</li>
<li>cpu发送启动命令</li>
<li>触发器B被设置为1，该信号用于启动设备；触发器D被设置为0</li>
<li>设备工作结束后<ul>
<li>将数据送入到接口当中的数据缓冲器。</li>
<li>触发器B被置为0，触发器D被置为1</li>
</ul>
</li>
<li>如果设备的中断没有被屏蔽，则 MASK 触发器的值为1，与触发器 D 的值一起经过与非门和非门激活中断触发器。</li>
<li>cpu 发出终端查询信号</li>
<li>中断触发器发出中断请求，并进入排队器</li>
<li>cpu发出中断相应信号，与排队器的结果共同形成向量地址。</li>
<li>向量地址被传给cpu，cpu利用地址解析出中断服务程序的入口地址或跳转指令地址。</li>
<li>中断服务程序将数据缓冲器中的数据取走。</li>
</ul>
<p><img src="/assets%5Cimage-24.png" alt="Alt text"></p>
</li>
</ul>
<h4 id="中断服务程序的流程"><a href="#中断服务程序的流程" class="headerlink" title="中断服务程序的流程"></a>中断服务程序的流程</h4><ol>
<li>保护现场</li>
</ol>
<ul>
<li>程序断点保护</li>
<li>寄存器内容保护</li>
</ul>
<ol start="2">
<li>执行中断程序</li>
<li>恢复现场</li>
<li>中断返回：返回到原来被中断的程序中</li>
</ol>
<h4 id="单重中断与多重中断"><a href="#单重中断与多重中断" class="headerlink" title="单重中断与多重中断"></a>单重中断与多重中断</h4><ul>
<li>单重中断：中断服务程序不能套娃</li>
<li>多重终端：允许中断优先级更高的中断，中断当前的中断</li>
</ul>
<p><img src="/assets%5Cimage-25.png" alt="Alt text"></p>
<p>其中，开中断是指允许其他中断发生。</p>
<p>中断隐指令是通过硬件实现的，不是程序上的指令。</p>
<h4 id="中断与程序查询的区别"><a href="#中断与程序查询的区别" class="headerlink" title="中断与程序查询的区别"></a>中断与程序查询的区别</h4><p>程序查询时，由于cpu需要循环的查询设备是否准备好，所以在等待设备数据时，cpu不能进行其他工作。</p>
<p>程序中断允许cpu在设备准备数据时执行其他工作。</p>
<h3 id="DMA-方式"><a href="#DMA-方式" class="headerlink" title="DMA 方式"></a>DMA 方式</h3><h4 id="DMA的特点"><a href="#DMA的特点" class="headerlink" title="DMA的特点"></a>DMA的特点</h4><p>程序查询和程序中断在与内存进行数据交换时，都需要cpu的参与。因此需要使用cpu内的寄存器。</p>
<p>DMA接口允许外设直接通过DMA接口与内存进行数据交换，不需要cpu的参与。</p>
<h4 id="DMA与主存交换数据的三种方式"><a href="#DMA与主存交换数据的三种方式" class="headerlink" title="DMA与主存交换数据的三种方式"></a>DMA与主存交换数据的三种方式</h4><ul>
<li>cpu放弃总线控制权，放弃内存访问，将总线控制权交予DMA。<ul>
<li>控制简单</li>
<li>但降低了CPU的利用率</li>
</ul>
</li>
<li>周期挪用&#x2F;周期窃取<ul>
<li>如果DMA接口准备好访问内存了，则发送申请，建立总线使用权，占用几个内存的访问周期。</li>
<li>在DMA的准备阶段，放弃内存的占用。</li>
<li>当DMA与cpu同时访存时，DMA具有优先性。</li>
</ul>
</li>
<li>DMA与CPU交替访问内存<ul>
<li>将内存的工作时间分割给DMA和CPU</li>
<li>这种方式不需要申请、建立、归还总线的访问权。访问权由时序控制。</li>
</ul>
</li>
</ul>
<h4 id="DMA的接口和组成"><a href="#DMA的接口和组成" class="headerlink" title="DMA的接口和组成"></a>DMA的接口和组成</h4><p>DMA的功能：</p>
<ul>
<li>向CPU发送占用总线的申请。</li>
<li>处理总线控制权的转交</li>
<li>管理控制总线，控制数据传送或读取</li>
<li>确定传送的地址和长度</li>
<li>给出操作完成的信号</li>
</ul>
<h1 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h1><h2 id="无符号数和有符号数"><a href="#无符号数和有符号数" class="headerlink" title="无符号数和有符号数"></a>无符号数和有符号数</h2><h3 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h3><p>寄存器的位数反应无符号数的取值范围</p>
<h3 id="有符号数"><a href="#有符号数" class="headerlink" title="有符号数"></a>有符号数</h3><ul>
<li>机器数：保存在计算机中的数，看不到正负号。</li>
<li>真值：我们用的值，表现形式为带有正负号。</li>
</ul>
<p>对于带有小数点的数值，在机器中储存时，机器中没有专门的硬件用以标识小数点的位置。对于小数点的位置，我们需要进行约定。有这样约定的机器成为定点机。定点机的约定方式有两种，我们可以按照约定方式将定点机分为两类：</p>
<ul>
<li>小数定点机：将小数点约定在符号位之后。</li>
<li>整数定点机：将小数点约定在整数位之后。</li>
</ul>
<p>下面对于小数的运算，我们都选取小数定点机的表示方法。</p>
<h4 id="源码表示法"><a href="#源码表示法" class="headerlink" title="源码表示法"></a>源码表示法</h4><ol>
<li>整数</li>
</ol>
<ul>
<li>正数：0, x。例如：真值 +10 的机器值表示为 0, 10。机器值中的 ‘,’ 是助记符，并不出现在真实的内存中。</li>
<li>负数：$2^{n}-x$。例如：真值 -10 的机器值表示为 1, 10。机器值中的 ‘,’ 是助记符，并不出现在真实的内存中。另外，负数的机器值表示相当于在真值绝对值前面一位加符号位1.相当于 机器数&#x3D;$2^n$ - 真值。其中n为真值绝对值的位数。</li>
</ul>
<ol>
<li>纯小数</li>
</ol>
<ul>
<li>正数：x。例如：真值 +0.1101 的机器值表示为 0. 1101。机器值中的 ‘.’ 是助记符，并不出现在真实的内存中。</li>
<li>负数：1+|x|。例如：真值 -0.1101 的机器值表示为 1. 1101。机器值中的 ‘.’ 是助记符，并不出现在真实的内存中。</li>
</ul>
<p>源码的特点：</p>
<ul>
<li>优点：简单，容易变换</li>
<li>缺点：不能直接用来给运算及进行加法操作。运算器只能将两个机器数相加，并不能区分符号位。因此会造成操作。</li>
</ul>
<h4 id="补码表示法"><a href="#补码表示法" class="headerlink" title="补码表示法"></a>补码表示法</h4><p>源码表示法在不考虑溢出的情况下，在进行加法操作时，需要运算器 ALU 能够区分被加数和加数的正负，并进行相应的加减才能得到正确数值。但是实际的 ALU 并不能识别机器数的符号位，它只能将两个机器数进行相加，无论机器数代表的是正数还是负数。因此为了满足 ALU 的计算所需，我们需要为负数的机器数找到一种对应的机器数，该对应的机器数能够在加操作后获得减去原机器数所代表的真数的结果。这就是补码。</p>
<ol>
<li><p>补的概念</p>
<p>一个时钟，我们只考虑他的时针，转一圈 12 个小时之后就又回到原位置，这里的 12 我们称为一个模。因此对于时钟而言 $n_1-n_2&#x3D;n_1+(12-n_2)$。为了表示这个关系，我们假定 $n_3&#x3D;12-n_2$，并称 $+n_3$ 是 $-n_2$ 以12为模的补数。记作 $-n_2 \equiv +n_3 \quad (mod \quad 12)$.</p>
<p>因此，一个负数加上模就得到该负数在该模下的补数。</p>
<p>补的自然形成还依靠于寄存器溢出的位会丢失的特点。</p>
</li>
<li><p>整数的补码</p>
<ol>
<li><p>补数的表示</p>
<ul>
<li>正数：正数的补数是它本身。表示方法为 0, x。</li>
<li>负数：1, $2^{n}+x$。</li>
</ul>
</li>
<li><p>补数的实现</p>
<p>我们要表示一个 n 位2进制数的补数，只需要将其真值加上 $2^{n+1}$ 即可。这里的寄存器位数是 n+1。</p>
<ul>
<li>如果是正数，则 $2^{n+1}$ 会因为溢出寄存器而被丢掉，因此就相当于没有对正数的机器数进行任何改变。</li>
<li>如果是负数，则 $2^{n+1}$ 会减去一个机器数为 真值的绝对值 的数。该真值的绝对值小于 $2^n$，因此相当于等于 $2^n$ + 真值的绝对值。</li>
</ul>
</li>
</ol>
<p>注意，补码并不对源码进行操作，补码是对真值进行运算的。</p>
<p>例如：</p>
<table>
<thead>
<tr>
<th align="center">真值</th>
<th align="center">加上$2^{n+1}$</th>
<th align="center">寄存器溢出舍值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+1010</td>
<td align="center">101010</td>
<td align="center">0,1010</td>
</tr>
<tr>
<td align="center">-1010</td>
<td align="center">010101</td>
<td align="center">1,0101</td>
</tr>
</tbody></table>
<p>补数表示的 +0 和 -0 一致。</p>
</li>
<li><p>纯小数的补码</p>
<ol>
<li><p>补数的表示</p>
<ul>
<li>正数： x</li>
<li>负数： 2+x</li>
</ul>
</li>
<li><p>补数的实现</p>
<p>我们要获得一个小数的补数，只需要对小数加 2 ，然后去除溢出位即可。</p>
</li>
</ol>
</li>
<li><p>求补码的快速方式</p>
<p>对于<strong>负数</strong>而言保持源码的符号位不变，对源码的数值位取反+1，即可得到补码。</p>
</li>
<li><p>举例</p>
<ul>
<li><p>已知$[x]_补&#x3D;0.0001$，求x。</p>
<p>首先，小数点说明x是一个小数，补码的第一位为0，说明是正数，因此$x&#x3D;+0.0001$。</p>
</li>
<li><p>已知$[x]_补&#x3D;1.0001$，求x。</p>
<p>首先，小数点说明x是一个小数，补码的第一位为1，说明是负数，因此$2-x&#x3D;[x]_补$，求得$x&#x3D;-0.1111$.</p>
</li>
<li><p>已知$[x]_补&#x3D;1,1110$，求x。</p>
<p>首先，’,’说明x是一个整数，补码的第一位为1，说明是负数，数值位-1取反后得到$[x]_源&#x3D;1,0010$，所以$x&#x3D;-0010$.</p>
</li>
<li><p>例子</p>
<p><img src="/assets%5Cimage-26.png" alt="Alt text"></p>
<p>注意，在这个例子中，-1按照补码的定义可以算出补码，但是没有源码。</p>
</li>
</ul>
</li>
</ol>
<h4 id="反码表示法"><a href="#反码表示法" class="headerlink" title="反码表示法"></a>反码表示法</h4><ol>
<li>定义<ol>
<li><p>整数</p>
<ul>
<li>正数：0,x</li>
<li>负数：$2^{n}-1+x$</li>
</ul>
</li>
<li><p>小数</p>
<ul>
<li>正数：x</li>
<li>负数：$2-2^{-n}+x$</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ol>
<li><p>整数</p>
<table>
<thead>
<tr>
<th align="center">真值</th>
<th align="center">源码</th>
<th align="center">补码</th>
<th align="center">反码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+x</td>
<td align="center">0, x</td>
<td align="center">0, x</td>
<td align="center">0, x</td>
</tr>
<tr>
<td align="center">-x</td>
<td align="center">1, x</td>
<td align="center">1, !x+ 1</td>
<td align="center">1, !x</td>
</tr>
</tbody></table>
</li>
<li><p>小数</p>
<table>
<thead>
<tr>
<th align="center">真值</th>
<th align="center">源码</th>
<th align="center">补码</th>
<th align="center">反码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+x</td>
<td align="center">x</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="center">-x</td>
<td align="center">1+ x</td>
<td align="center">1+ !x+ 1</td>
<td align="center">1+ !x</td>
</tr>
</tbody></table>
</li>
</ol>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><img src="/assets%5Cimage-27.png" alt="Alt text"></p>
<h3 id="移码表示法"><a href="#移码表示法" class="headerlink" title="移码表示法"></a>移码表示法</h3><ol>
<li>计算公式：$[x]_移&#x3D;2^n+x$，例如 $x&#x3D;10100$，则 $[x]_移&#x3D;1,10100$。</li>
<li>只有整数有移码。</li>
<li>移码和补码只相差一个符号位。</li>
</ol>
<h1 id="数的定点表示和浮点表示"><a href="#数的定点表示和浮点表示" class="headerlink" title="数的定点表示和浮点表示"></a>数的定点表示和浮点表示</h1><ol>
<li>定点表示的定义<br>小数点不在内存中出现，也不以电路硬件的形式进行标识，而是规定小数点的位置。</li>
<li>定点表示的分类<ol>
<li>小数点约定在符号位之后</li>
<li>小数点约定在数值的最后</li>
</ol>
</li>
<li>定点机<ol>
<li>定义：通过约定的方式来确定小数点位置的机器称为定点机。</li>
<li>小数定点机：小数点约定在符号位之后的定点机。</li>
<li>整数定点机：小数点约定在数值位之后的定点机。</li>
<li>小数定点机用来存放小数，整数定点机用来存放整数。</li>
</ol>
</li>
</ol>
<p><img src="/.%5Cassets%5Cimage-28.png" alt="Alt text"></p>
<h2 id="浮点表示"><a href="#浮点表示" class="headerlink" title="浮点表示"></a>浮点表示</h2><p><img src="/assets%5Cimage-29.png" alt="Alt text"></p>
<p>表示的浮点数形式为：$S \times r^j,r&#x3D;2$.</p>
<p>所以，我们需要保存S的符号和j的符号才能确定整个数值的大小。</p>
<h2 id="浮点数的表示范围"><a href="#浮点数的表示范围" class="headerlink" title="浮点数的表示范围"></a>浮点数的表示范围</h2><ol>
<li><p>阶码和尾码都使用原码表示</p>
<p><img src="/assets%5Cimage-35.png" alt="Alt text"></p>
<p>如果阶码大于最大阶码，则会报错，发生上溢；如果阶码小于最小阶码，发生下溢，则当作机器数0处理，因为下溢时本身的数据的绝对值就很小，很接近于0，属于是一种近似。</p>
</li>
</ol>
<h2 id="浮点数的规格化形式"><a href="#浮点数的规格化形式" class="headerlink" title="浮点数的规格化形式"></a>浮点数的规格化形式</h2><p>浮点数规格化是为了让尾数的小数点后紧挨着非零数。这样可以用有限的位数保证最大的精度。</p>
<p>例如以2为数基（就是🙅进制）的小数 0.01 规格化后为 $0.1 \times 2^{-1}$.</p>
<p>其实就是2进制的科学表示法。</p>
<p><img src="/assets%5Cimage-30.png" alt="Alt text"></p>
<p>注意题目中只说写成定点数，但是没有指明用什么码表示。</p>
<p><img src="/assets%5Cimage-31.png"></p>
<h2 id="机器零"><a href="#机器零" class="headerlink" title="机器零"></a>机器零</h2><ol>
<li>浮点数的尾码为0时，浮点数按机器零处理。</li>
<li>浮点数的阶数发生下溢时，浮点数的数值按照机器零处理。阶码的下溢值为$2^{-n}$，其中n为阶码的位数（包括符号位）</li>
</ol>
<p>当阶码和尾码都用补码来表示时，机器零为</p>
<table>
<thead>
<tr>
<th align="center">阶码</th>
<th align="center">尾码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">xx…x</td>
<td align="center">0.0…0</td>
</tr>
<tr>
<td align="center">10…0</td>
<td align="center">xx…x</td>
</tr>
</tbody></table>
<p>当阶码用移码来表示时，机器零为</p>
<table>
<thead>
<tr>
<th align="center">阶码</th>
<th align="center">尾码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">00…0</td>
<td align="center">xx…x</td>
</tr>
</tbody></table>
<h2 id="IEEE-754-标准"><a href="#IEEE-754-标准" class="headerlink" title="IEEE 754 标准"></a>IEEE 754 标准</h2><p>由于规格化表示的第一位小数一定是1，所以就把它隐藏掉，不在内存中储存它，在计算时再给予考虑。</p>
<p>除此之外，还规定了多种不同精度和范围的浮点数：</p>
<p><img src="/assets%5Cimage-32.png" alt="Alt text"></p>
<h1 id="定点计算"><a href="#定点计算" class="headerlink" title="定点计算"></a>定点计算</h1><h2 id="加减法运算"><a href="#加减法运算" class="headerlink" title="加减法运算"></a>加减法运算</h2><ol>
<li><p>加法</p>
<p><img src="/assets%5Cimage-33.png" alt="Alt text"></p>
</li>
<li><p>减法</p>
<p><img src="/assets%5Cimage-34.png" alt="Alt text"></p>
</li>
</ol>
<ul>
<li>在进行加减法运算时符号位也参与运算。结果的符号位随进位自然产生。</li>
<li>在进行加减法运算时，可以采用双符号位，正数的符号位是00，负数的符号位是11.这样如果发生了数据溢出，比如两个正数相加溢出时，符号位为01，则可以知道计算发生了溢出。在浮点数表示中，甚至可以将发生溢出的尾数右移调整为正确值。</li>
</ul>
<h2 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h2><h3 id="算术移位的规则"><a href="#算术移位的规则" class="headerlink" title="算术移位的规则"></a>算术移位的规则</h3><ol>
<li><p>符号位不能变</p>
<p><img src="/assets%5Cimage-36.png" alt="Alt text"></p>
<p><img src="/assets%5Cimage-37.png" alt="Alt text"></p>
<p>例子中的右移两位的结果，和C++中的整数除法表现一致。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">13</span>;</span><br><span class="line"><span class="type">int</span> b=<span class="number">-13</span>;</span><br><span class="line">std::cout&lt;&lt; a/<span class="number">2</span>&lt;&lt; std::endl&lt;&lt; b/<span class="number">2</span>&lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// -6</span></span><br></pre></td></tr></table></figure></li>
<li><p>移位一定要注意不要让左移溢出，溢出后将出错</p>
<ol>
<li>如果两个相加的数都是正数，当机器数相加向符号位进位时，则发生溢出</li>
<li>如果两个相加的数都是负数，当机器数相加没有向符号位进位时，则发生溢出</li>
<li>总而言之，如果两个同符号的数相加，结果机器数没有保证符号位不变，则发生溢出。</li>
<li>当两个数字的符号相同时，若 符号位相加后的进位 $\oplus$ 非符号位相加后的最高位进位 $&#x3D;1$，则发生溢出。</li>
</ol>
</li>
<li><p>算术移位和逻辑移位的区别：算术移位不移动符号位，逻辑移位移动符号位</p>
</li>
</ol>
<h2 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h2><ol>
<li><p>将乘法运算的过程写成计算机容易处理的方式</p>
<p><img src="/assets%5Cimage-38.png" alt="Alt text"></p>
<ol>
<li>让初始<strong>部分积</strong>为 0</li>
<li>乘数B的最后一位乘以A加上部分积，得到新的部分积</li>
<li>乘数B右移一位</li>
<li>重复2、3操作len(B)次</li>
</ol>
<p>上述计算只针对数值部分，机器数的符号位需要单独进行异或处理。</p>
</li>
<li><p>如何处理乘法操作带来的机器数位数扩张</p>
<ol>
<li>乘数每经过计算一位后，会向右移动一位，这样乘数的最左侧就空出一位。</li>
<li>两个数相加，最多向高位进一，他们和的机器数最多扩大一位</li>
<li>用乘数右移后空出的高位保存部分积的低位，并将部分积右移一位，舍掉部分积的低位。</li>
<li>这样，乘数的最低位与被乘数相乘后的结果总能与部分积正确的对齐相加</li>
<li>即解决了位数扩张的问题，右解决了部分积相加过程中的位数对齐问题</li>
</ol>
<p>被乘数是0.1101，乘数是0.1011，他们的计算过程如下：</p>
<p>![Alt text](屏幕截图 2023-11-16 104520.png)</p>
</li>
</ol>
<h3 id="原码乘法的运算"><a href="#原码乘法的运算" class="headerlink" title="原码乘法的运算"></a>原码乘法的运算</h3><p><img src="/assets%5Cimage-40.png" alt="Alt text"></p>
<p>右移时，由于符号位单独计算，我们只需算两个数绝对值的乘机，他们的绝对值的符号位都为0.因此，在实际的移位过程中，我们执行的是逻辑右移，因为原码的右移是补零的，而我们的符号位正好是0。</p>
<p>在实际运算中，我们用移位的次数来判断乘法是否结束。</p>
<h2 id="原码的除法运算"><a href="#原码的除法运算" class="headerlink" title="原码的除法运算"></a>原码的除法运算</h2><p>约定：</p>
<ul>
<li>小数的除法，被除数的绝对值小于除数的绝对值。保证结果仍然是小数。</li>
<li>整数的除法，被除数的绝对值大于除数的绝对值。保证结果仍然是整数。</li>
<li>被除数不能等于0。等于0时无需继续运算。</li>
<li>除数不能为0。否则运算出错。</li>
</ul>
<h3 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h3><p><img src="/assets%5Cimage-44.png" alt="Alt text"></p>
<p>原理：</p>
<ol>
<li>被除数和除数的符号位单独运算，除法运算时只运算他们的绝对值。</li>
<li>结果的符号位 $&#x3D;$ 被除数符号位 $\oplus$ 除数符号位。</li>
<li>将被除数绝对值的补码与负的除数绝对值的补码相加。结果保存在被除数寄存器中。<ol>
<li>如果结果为负，则将被除数的补码与除数的补码相加，还原被除数。并向商寄存器中压入0.</li>
<li>如果结果为正，则向商寄存器中压入1.</li>
</ol>
</li>
<li>将被除数寄存器<strong>逻辑左移</strong>一位。</li>
<li>重复上述过程，直到商寄存器被填满。此时，上寄存器中保存商值，被除数寄存器中保存余数值。</li>
</ol>
<h3 id="不恢复余数法（加减交替法）"><a href="#不恢复余数法（加减交替法）" class="headerlink" title="不恢复余数法（加减交替法）"></a>不恢复余数法（加减交替法）</h3><p>原理：</p>
<ol>
<li>被除数和除数的符号位单独运算，除法运算时只运算他们的绝对值。</li>
<li>结果的符号位 $&#x3D;$ 被除数符号位 $\oplus$ 除数符号位。</li>
<li>将被除数绝对值的补码与负的除数绝对值的补码相加。结果保存在被除数寄存器中。<ol>
<li>如果结果为负<ol>
<li>将被除数的补码左移一位</li>
<li>被除数补码与除数的绝对值的补码相加。并向商寄存器中压入0.</li>
</ol>
</li>
<li>如果结果为正<ol>
<li>将被除数的补码左移一位</li>
<li>被除数补码与负的除数的绝对值的补码相加。并向商寄存器中压入1.</li>
</ol>
</li>
</ol>
</li>
<li>重复上述过程，直到商寄存器被填满。此时，上寄存器中保存商值，被除数寄存器中保存余数值。</li>
</ol>
<h1 id="浮点数的四则运算"><a href="#浮点数的四则运算" class="headerlink" title="浮点数的四则运算"></a>浮点数的四则运算</h1><h2 id="浮点加减运算"><a href="#浮点加减运算" class="headerlink" title="浮点加减运算"></a>浮点加减运算</h2><p>对于两个浮点数：$x&#x3D;S_x \cdot 2^{j_x}$ 和 $y&#x3D;S_y \cdot 2^{j_y}$</p>
<p>它们可以进行加减运算的前提是，他们的阶码部分相同。因此，将两个浮点数进行运算时，需要先将两个浮点数的解码调整一致。</p>
<p>在调整过程中，我们希望将阶数小的移成阶数大的，即阶数小的左移，同时，它对应的尾数应当右移，这样可以保证尾数仍然是小数，即使尾数的数据发生溢出，丢失的也只是尾数的低位，只会影响尾数的精度；相反如果我们将阶数大的移成阶数小的，即阶数大的右移，相对应的尾数左移，则很有可能造成尾数中的 1 在以为的过程中被溢出丢弃。丢失了尾数的最高位将影响这个数据的大小。</p>
<h3 id="规格化数"><a href="#规格化数" class="headerlink" title="规格化数"></a>规格化数</h3><p><img src="/assets%5Cimage-45.png" alt="Alt text"></p>
<p><img src="/assets%5Cimage-46.png" alt="Alt text"></p>
<ol>
<li><p>左归</p>
<p>将尾数左移，使尾数规格化。直到数符与第一位数不同为止。（采用补码表示）</p>
</li>
<li><p>右归</p>
<p>当尾数的绝对值大于1时，需要将尾数进行右移。直到数符与第一位数不同为止。（采用补码表示）</p>
<p>当采用双符号位时，两个正数相加如果向符号位进一了，则需要对尾数进行右归，确保尾数不溢出。</p>
<p>例如：</p>
<p>00.0100 + 00.1100 &#x3D; 01.0000 -&gt; 右归 -&gt; 00.1000;00,0001</p>
</li>
<li><p>例子</p>
<p><img src="/assets%5Cimage-47.png" alt="Alt text"></p>
<p><img src="/assets%5Cimage-48.png" alt="Alt text"></p>
</li>
</ol>
<h3 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h3><p>在尾数进行左移和右移的过程中，可能会出现有意义数的舍去，为了尽可能的保证数的精度，我们需要进行舍入。</p>
<h3 id="规格化数的溢出判断"><a href="#规格化数的溢出判断" class="headerlink" title="规格化数的溢出判断"></a>规格化数的溢出判断</h3><p><img src="/assets%5Cimage-49.png" alt="Alt text"></p>
<h1 id="算数逻辑单元（ALU）"><a href="#算数逻辑单元（ALU）" class="headerlink" title="算数逻辑单元（ALU）"></a>算数逻辑单元（ALU）</h1><p>全加器进行加法运算时，进位的快慢决定了运算的快慢。下面对进位链进行分析。</p>
<h2 id="进位链"><a href="#进位链" class="headerlink" title="进位链"></a>进位链</h2><ol>
<li><p>串行进位链</p>
<p>下一个进位依赖于上一个进位的值。</p>
<p>优点：电路简单</p>
<p>缺点：时间长</p>
</li>
<li><p>并行进位链</p>
<p>每一个进位都依赖于加数和被加数单独计算。</p>
<p>有点：时间短</p>
<p>缺点：电路复杂</p>
</li>
<li><p>单重分组跳跃进位链</p>
<p>将n个全加器分为若干组，每个组内使用并行进位链，组外使用串行进位链。</p>
<p><img src="/assets%5Cimage-50.png" alt="Alt text"></p>
</li>
<li><p>双重分组跳跃进位链</p>
<p>将n个全加器分为若干个大组，每个大组中包含若干个小组。小组中使用并行进位链，大组中使用并行进位链，大组外使用串行进位链。</p>
</li>
</ol>
<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><ul>
<li>指令的格式：操作码 + 地址码 + 寻址方式</li>
<li>指令字长：固定长度和可变字长</li>
</ul>
<h2 id="操作码的扩展技术"><a href="#操作码的扩展技术" class="headerlink" title="操作码的扩展技术"></a>操作码的扩展技术</h2><ol>
<li><p>保留码点</p>
<p>假设我们的默认操作码尾数为4位，则当字的前四位为 0000 到 1110 时，该字的前四位为操作码。 1111 将作为操作码的扩展标志，当字的前四位出现 1111 时，说明该字的操作码至少有8位。八位操作码的范围位 1111 0000 到 1111 1110。以此类推。</p>
<p>当然，我们也可以让4位操作码的范围位 0000 到 1101，令 1110 和 1111 作为扩展标志。这样我们能够扩展出更多的指令。</p>
</li>
</ol>
<h3 id="地址码"><a href="#地址码" class="headerlink" title="地址码"></a>地址码</h3><ol>
<li><p>四地址码</p>
<ul>
<li>形式：op + $A_1$ + $A_2$ + $A_3$ + $A_4$</li>
<li>运作方式：($A_1$) op ($A_2$) -&gt; $A_3$</li>
<li>意义：<ul>
<li>$A_1$：操作数地址</li>
<li>$A_2$：操作数地址</li>
<li>$A_3$：结果保存地址</li>
<li>$A_4$：下一条指令地址</li>
</ul>
</li>
<li>访存次数：4</li>
</ul>
</li>
<li><p>三地址码</p>
<p>实际上，字中不需要保存下一条指令的地址，因为下一条指令的地址被PC寄存器保存。</p>
<p>优势：相比于四地址吗方式，增加了每一个地址的寻址范围。</p>
<p>访存次数：4</p>
</li>
<li><p>俩地址码</p>
<p>运算的结果不在保存在单独的地址中，而是保存在其中一个运算数中。</p>
<p>优势：相比于三地址码方式，增加了每一个地址码的寻址范围。</p>
<p>访存次数：4</p>
<p>另外，如果我们将运算结果保存在寄存器中，那么我们可以减少一次访存次数。</p>
</li>
<li><p>一地址码</p>
<p>运算的操作数中的一个通过ACC寄存器来取，运算结果保存在ACC中，这样我们又可以减少一个地址码，此时的字的内容变成了 op + $A_1$</p>
<p>优势：相比于俩地址码的方式，增加了地址码的寻址范围。且减少了一次访存。</p>
<p>访存次数：2</p>
</li>
<li><p>零地址码</p>
</li>
</ol>
<h3 id="指令的字长"><a href="#指令的字长" class="headerlink" title="指令的字长"></a>指令的字长</h3><h2 id="操作数的类型和操作种类"><a href="#操作数的类型和操作种类" class="headerlink" title="操作数的类型和操作种类"></a>操作数的类型和操作种类</h2><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p>如何找到操作数和下一条指令的地址。</p>
<h4 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h4><p>一条指令有如下的组成部分：op + 寻址特征 + 形式地址 A</p>
<p>寻址特征标识了我们的寻址方式。</p>
<p>我们假设 机器字长 &#x3D; 储存字长 &#x3D; 指令字长</p>
<ol>
<li><p>立即寻址</p>
<p>形式地址 A 就是操作数。该种指令的形式是：op + # + A，A的表示形式为补码。A 是一个立即数。</p>
<p>在指令执行过程中不需要访问存储器。</p>
</li>
<li><p>直接寻址</p>
<p>形式地址就是数据在内存中的地址。该种指令的形式是： op + 寻址特征 + A</p>
<p>在指令执行过程中，需要访问一次存储器。</p>
</li>
<li><p>隐含寻址</p>
<p>某一条指令需要两个操作数，其中一个操作数的地址已经在指令中以直接寻址的方式给出，另外一个操作数的地址隐含在寄存器ACC中。该种指令的形式是：op + 寻址特征 + A。</p>
</li>
<li><p>间接寻址</p>
<p>形式地址中保存的是有效地址。我们需要先访问形式地址的内存，获得有效地址，然后根据有效地址获得操作数。</p>
</li>
<li><p>寄存器直接寻址</p>
<p>形式地址给出寄存器的编号，操作数保存在寄存器中。</p>
</li>
<li><p>寄存器间接寻址</p>
<p>形式地址给出寄存器的编号，操作数的地址保存在寄存器中。</p>
</li>
<li><p>基址寻址</p>
<ol>
<li>采用专有的基址寄存器保存基址，然后基址与形式地址相加是操作数地址。</li>
<li>采用通用寄存器储存基址，然后用基址与形式地址相加得到操作数的地址。</li>
</ol>
</li>
<li><p>变址寻址</p>
<p>和基址寻址类似，不过寄存器中保存的是较小的偏移量。比如数组的元素的编号。</p>
</li>
<li><p>相对寻址</p>
<p>A 中保存的是相对于 PC 的偏移量，真正的操作数的地址保存在 PC+A 中</p>
</li>
<li><p>堆栈寻址</p>
<p>通过栈的基址寄存器和栈的栈顶指针寄存器来实现操作数的访问。</p>
</li>
</ol>
<h2 id="RISC-技术"><a href="#RISC-技术" class="headerlink" title="RISC 技术"></a>RISC 技术</h2><p>计算机的指令集越来越庞大。但是实际上，只有20%左右的指令是被频繁使用的。因此人们希望制作一个指令集，只包含这20%的简单指令和一些必要指令。</p>
<p>指令减少之后，译码变得简单，可以提高指令执行的速度。</p>
<p>精简指令集：RISC</p>
<p>复杂指令集：CISC</p>
<ol>
<li><p>RISC 的特征</p>
<ul>
<li>指令长度固定，指令格式种类少，寻址方式少。</li>
<li>访存只能通过 LOAD&#x2F;STORE</li>
<li>CPU中有多个通用寄存器</li>
<li>采用流水技术，一个时钟周期内完成一条指令。</li>
<li>采用组合逻辑的方式实现控制器，即通过硬件的方式加速指令执行。</li>
</ul>
</li>
<li><p>CISC 的特征</p>
<ul>
<li>指令系统庞大</li>
<li>指令长度不固定，指令格式多，寻址方式多</li>
<li>访存不受限制</li>
<li>CPU中设有专用寄存器</li>
<li>大多数指令需要多个时钟周期完成</li>
<li>采用微程序控制器</li>
</ul>
</li>
</ol>
<h1 id="CPU-的结构和功能"><a href="#CPU-的结构和功能" class="headerlink" title="CPU 的结构和功能"></a>CPU 的结构和功能</h1><h2 id="CPU-的功能"><a href="#CPU-的功能" class="headerlink" title="CPU 的功能"></a>CPU 的功能</h2><ol>
<li><p>控制器功能</p>
<ul>
<li>取指令</li>
<li>分析指令</li>
<li>执行指令，发出各种操作命令</li>
<li>控制程序的输入和结果的输出</li>
<li>管理总线</li>
<li>处理异常和特殊请求</li>
</ul>
</li>
<li><p>运算器功能</p>
<ul>
<li>进行算术运算</li>
<li>进行逻辑运算</li>
<li>进行移位运算</li>
</ul>
</li>
</ol>
<h2 id="CPU-的结构框图"><a href="#CPU-的结构框图" class="headerlink" title="CPU 的结构框图"></a>CPU 的结构框图</h2><p><img src="/assets%5Cimage51.png" alt="Alt text"></p>
<h2 id="CPU-的寄存器"><a href="#CPU-的寄存器" class="headerlink" title="CPU 的寄存器"></a>CPU 的寄存器</h2><p>分类方式：</p>
<ol>
<li><p>用户可见的和不可见的寄存器</p>
<ul>
<li>通用寄存器</li>
<li>数据寄存器</li>
<li>地址寄存器</li>
<li>条件码寄存器</li>
</ul>
</li>
<li><p>控制和状态寄存器</p>
<ul>
<li><p>控制寄存器</p>
<ul>
<li>PC</li>
<li>MAR</li>
<li>M</li>
<li>MDR</li>
<li>IR</li>
</ul>
</li>
<li><p>状态寄存器</p>
<ul>
<li>状态寄存器：存放条件码</li>
<li>PSW寄存器：存放程序状态字，存放程序的现场</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="控制单元-CU-和中断系统"><a href="#控制单元-CU-和中断系统" class="headerlink" title="控制单元 CU 和中断系统"></a>控制单元 CU 和中断系统</h2><ul>
<li>CU 产生全部指令的微操作命令序列</li>
</ul>
<h2 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h2><ol>
<li><p>指令周期</p>
<p>从开始取出一条指令开始，到执行完这条指令所需要的全部时间。</p>
<ol>
<li><p>一个指令周期包括：</p>
<ul>
<li>取址周期：取址和分析</li>
<li>执行周期：取操作数、执行、将执行结果写入内存</li>
</ul>
</li>
<li><p>不同的指令周期的组成可能不同。</p>
<ul>
<li>NOP 指令只有取值周期</li>
</ul>
</li>
<li><p>具有间接寻址的指令周期：</p>
<ul>
<li>取址阶段</li>
<li>间址阶段</li>
<li>执行阶段</li>
</ul>
</li>
<li><p>带有中断周期的指令周期：</p>
<ul>
<li>取址周期</li>
<li>间址周期</li>
<li>执行周期</li>
<li>中断周期</li>
</ul>
</li>
<li><p>指令周期的流程</p>
<p>我们假设指令周期至少包括取值周期和执行周期，则指令周期的流程如下：</p>
<p><img src="/assets%5Cimage-52.png" alt="Alt text"></p>
</li>
<li><p>CPU 工作周期的标志</p>
<table>
<thead>
<tr>
<th align="center">CPU 访存类型</th>
<th align="center">对应的指令周期</th>
<th align="center">CPU工作周期标志</th>
</tr>
</thead>
<tbody><tr>
<td align="center">取指令</td>
<td align="center">取址周期</td>
<td align="center">FE</td>
</tr>
<tr>
<td align="center">取地址</td>
<td align="center">间址周期</td>
<td align="center">IND</td>
</tr>
<tr>
<td align="center">存取操作数</td>
<td align="center">执行周期</td>
<td align="center">EX</td>
</tr>
<tr>
<td align="center">存取程序断点</td>
<td align="center">终端周期</td>
<td align="center">INT</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>指令周期的数据流</p>
<ol>
<li><p>取址周期的数据流</p>
<p>PC $\rightarrow$ MAR $\rightarrow$ 地址总线 $\rightarrow$ 内存 $\leftarrow$ 控制总线 $\leftarrow$ CU</p>
<p>内存 $\rightarrow$ 数据总线 $\rightarrow$ MDR $\rightarrow$ IR</p>
<p>CU $\rightarrow$ PC + 1</p>
</li>
<li><p>间址周期</p>
<p>MDR $\rightarrow$ MAR $\rightarrow$ 地址总线 $\rightarrow$ 内存 $\leftarrow$ 控制总线 $\leftarrow$ CU</p>
<p>内存 $\rightarrow$ 数据总线 $\rightarrow$ MDR</p>
<p>MDR 的形式地址此时就保存了操作数的真实地址</p>
</li>
<li><p>执行周期</p>
</li>
<li><p>中断周期</p>
<p>首先由CU指定断点的保存地址，断点就是此时的PC</p>
<p>CU $\rightarrow$ MAR $\rightarrow$ 地址总线 $\rightarrow$ 内存 $\leftarrow$ 控制总线 $\leftarrow$ CU</p>
<p>将断点保存到内存中</p>
<p>PC $\rightarrow$ MDR $\rightarrow$ 数据总线 $\rightarrow$ 内存</p>
<p>CU 给出中断服务程序的入口地址</p>
<p>CU $\rightarrow$ PC</p>
</li>
</ol>
</li>
</ol>
<h2 id="系统的并行性"><a href="#系统的并行性" class="headerlink" title="系统的并行性"></a>系统的并行性</h2><p><img src="/assets%5Cimage-57.png" alt="Alt text"></p>
<ol>
<li><p>并行的概念</p>
<ul>
<li>并发：同一时间段发生</li>
<li>同时：同一时刻发生</li>
</ul>
</li>
<li><p>并行性的等级</p>
<ul>
<li>过程级：多个指令同时被解释。粗粒度。通过软件实现。</li>
<li>指令级：指令的微操作并行进行。细粒度。通过硬件实现。</li>
</ul>
</li>
<li><p>指令流水的原理</p>
<ul>
<li><p>指令的串行执行：取指令 $\rightarrow$ 执行指令 $\rightarrow$ 取指令 $\rightarrow$ 执行指令 …</p>
<p>串行执行的问题是，当CPU执行指令时，取指令的部分硬件就空闲了；当CPU取指令时，执行指令的部分硬件就空闲了。造成了严重的资源浪费。</p>
</li>
<li><p>指令的二级流水：取指令 $\rightarrow$ 执行指令 &amp; 取指令 $\rightarrow$ 执行指令 …</p>
<p>CPU在执行指令的同时取下一条指令。提升了CPU的利用率。</p>
<p>相比于串行执行，二级流水的速度提升一倍。</p>
</li>
</ul>
</li>
<li><p>提高流水速度</p>
<ul>
<li><p>问题：对于二级流水而言，执行时间要大于取值时间。为了让取址硬件持续工作。</p>
<p>解决办法：我们在取址器和执行器之间加上一个缓冲区。</p>
</li>
<li><p>问题：条件转移指令，必须要等到上一条指令结束才能确定下一条指令的地址造成。时间损失。</p>
<p>解决办法：我们可以采用分支预测。</p>
</li>
</ul>
</li>
</ol>
<h2 id="流水线的性能"><a href="#流水线的性能" class="headerlink" title="流水线的性能"></a>流水线的性能</h2><ol>
<li><p>吞吐率</p>
<ul>
<li>定义：单位时间内，流水线完成的指令或输出的结果的数量。</li>
<li>最大吞吐率：流水线满负荷运转时能够达到的最大吞吐率。</li>
<li>实际吞吐率：实际测出来的吞吐率。实际完成的指令个数除以总时间。</li>
</ul>
<p>假设有 m 段流水线，每一段流水线的执行时间为 $t$ 运行 n 条指令，则：</p>
<ul>
<li>最大吞吐率：$\frac{1}{t}$</li>
<li>实际吞吐率：$\frac{n}{m \times t + (n-1) \times t}$</li>
</ul>
</li>
<li><p>加速比</p>
<ul>
<li>定于：不采用流水线方法的时间比上采用流水线方法的时间。</li>
</ul>
<p>假设有 m 段流水线，每一段流水线的执行时间为 $t$ 运行 n 条指令，则：</p>
<ul>
<li>采用流水线的时间：$m \times t + (n-1) \times t$</li>
<li>不采用流水线的时间：$nm \times t$</li>
<li>加速比：不采用流水线\采用流水线 &#x3D; $\frac{nm \times t}{m \times t + (n-1) \times t}&#x3D;\frac{nm}{m+n-1}$</li>
</ul>
</li>
<li><p>效率</p>
<ul>
<li>流水线的建立时间：第一条指令进入流水线，到它的结果被输出所占的时间。</li>
<li>流水线的排空时间：最后一条指令进入流水线，到最后一条指令的结果被输出所占的时间。</li>
</ul>
<p><img src="/assets%5Cimage-53.png" alt="Alt text"></p>
<p>图中，$S_i$ 是流水线的不同段，1 ~ n 是流水线执行的指令。可以看到，有的时间中，流水线有的段是空载的，即没有被占用，因此就有硬件设备上的浪费。因此我们引入效率指标来衡量流水线的利用率，它的定义如下：</p>
<p>$效率&#x3D;\frac{流水线各段处于工作时间的时空区}{流水线各段的总时空区}$</p>
<p>上图的效率，需要使用小实线正方形的总面积除以虚线大长方形的面积。</p>
</li>
</ol>
<h2 id="流水线的多发技术"><a href="#流水线的多发技术" class="headerlink" title="流水线的多发技术"></a>流水线的多发技术</h2><ol>
<li><p>超标量技术</p>
<ul>
<li>流水线有很多条。</li>
<li>因此每个时钟周期内，可以有多条指令被并发的执行。</li>
</ul>
</li>
<li><p>超流水线技术</p>
<ul>
<li>把一个时钟周期分为若干份</li>
<li>每一份都可以有一个新的指令进入到流水线中</li>
<li>不同的指令处于同一流水段中，相互之间的信号不会叠加</li>
</ul>
</li>
<li><p>超长指令字技术</p>
<ul>
<li>将多条能并行执行的指令组合成一个超长字</li>
<li>这样可以将多个指令一次取出来代替多次的取址操作</li>
</ul>
</li>
</ol>
<h2 id="流水线的结构"><a href="#流水线的结构" class="headerlink" title="流水线的结构"></a>流水线的结构</h2><p><img src="/assets%5Cimage-55.png" alt="Alt text"></p>
<p>锁存的作用：</p>
<ul>
<li>保存前面流水段的操作结果</li>
<li>为下一段流水段提供操作数据</li>
</ul>
<p>浮点数的计算也可以采用流水线来实现：</p>
<p><img src="/assets%5Cimage-56.png" alt="Alt text"></p>
<p>为了尽可能提升流水线的速度。每一段流水段的执行时间应当尽可能地相等。</p>
<h2 id="影响流水线性能的因素"><a href="#影响流水线性能的因素" class="headerlink" title="影响流水线性能的因素"></a>影响流水线性能的因素</h2><ol>
<li><p>结构冲突</p>
<ul>
<li>问题：同一时刻，流水线的不同段，或者不同流水线可能会竞争同一硬件资源，比如竞争储存器。当寻址和取数同时发生时，就会产生这种竞争。</li>
<li>解决方案：<ul>
<li>让冲突的一方停顿，以保证另一方的运行。</li>
<li>将指令与数据分开储存。分成指令储存器和数据储存器。（哈弗结构）</li>
<li>预先取出多条指令。</li>
</ul>
</li>
</ul>
</li>
<li><p>数据冲突</p>
<ul>
<li>问题：多个流水段同时操作一个内存的数据。</li>
</ul>
</li>
</ol>
<h2 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ol>
<li><p>引起中断的因素</p>
<ul>
<li>人为设置，如转管指令</li>
<li>程序事故</li>
<li>硬件故障</li>
<li>I&#x2F;O设备的程序中断</li>
<li>外部事件</li>
</ul>
</li>
</ol>
<h3 id="中断请求标记和中断判优逻辑"><a href="#中断请求标记和中断判优逻辑" class="headerlink" title="中断请求标记和中断判优逻辑"></a>中断请求标记和中断判优逻辑</h3><ol>
<li><p>中断请求标记</p>
<p>为了让系统接收到不同中断源的中断信号，我们为每一个中断源都设置了一个中断请求标记触发器 INTR 。</p>
<p>多个 INTR 组成了一个中断请求标记寄存器。</p>
</li>
<li><p>中断源的判优逻辑</p>
<p>将中断源根据重要性进行分级，为每一个中断源设置一个优先级。</p>
<ol>
<li><p>硬件方式实现</p>
<p>链式排队器，系统在链式排队器中顺序的查询中断请求。</p>
</li>
<li><p>软件方式实现</p>
<p>程序查询，根据中断源优先级，循环的查询各个中断源。</p>
</li>
</ol>
</li>
<li><p>中断服务程序入口地址的查询</p>
<ol>
<li><p>硬件向量法</p>
<p>根据排队器的输出形成中断向量地址，中断向量地址可以保存跳转指令或者中断的入口程序。</p>
</li>
<li><p>软件查询法</p>
<p>通过中断识别程序，循环的查询各个中断源。当查询到中断后跳转到相应的中断服务程序。</p>
</li>
</ol>
</li>
<li><p>中断响应</p>
<ol>
<li><p>相应中断请求的条件</p>
<ul>
<li>允许中断触发器 EINT &#x3D; 1 的时候才能相应中断。</li>
<li>通常在指令结束之后进行中断查询，和处理中断</li>
</ul>
</li>
<li><p>中断隐指令</p>
<p>隐指令并不是一条代码指令，而是一系列硬件操作的集合</p>
<ul>
<li>保护程序断点：保存到特殊地址或栈中。</li>
<li>寻找中断程序的入口地址：硬件向量法、中断识别程序查询法</li>
<li>硬件关中断。</li>
</ul>
</li>
</ol>
</li>
<li><p>保护现场和恢复现场</p>
<ol>
<li><p>保护现场</p>
<ol>
<li>保护断点，包括程序断点地址，由中断隐指令完成。</li>
<li>保存寄存器中的值。</li>
</ol>
</li>
<li><p>恢复现场</p>
</li>
</ol>
</li>
<li><p>多重中断</p>
<p>当执行中断时发生了中断优先级更高的中断，则会中断当前的中断服务程序，去执行优先级更高的中断服务程序。</p>
<p>中断屏蔽技术：通过一个标记位触发器来屏蔽中断标志位的中断请求。被屏蔽的中断请求不会进入排队器。</p>
<p>中断屏蔽器可以改变中断相应的优先级，即：A比B的中断优先级高，但是当二者同时发出中断请求时，可以通过中断屏蔽字让B优先进入排队器。但是B在排队器中的优先级仍然低于A。</p>
<p>中断屏蔽字的设置在开中断之前</p>
</li>
</ol>
<ul>
<li>机器周期：一个指令中占时间最长的微操作。</li>
<li>指令周期包含多个机器周期，一个机器周期包含多个时钟周期（节拍）</li>
<li></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/16/linux/shell/shell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何先生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="北国回忆录">
      <meta itemprop="description" content="东拼西凑、杂七杂八">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 北国回忆录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/16/linux/shell/shell/" class="post-title-link" itemprop="url">linux shell</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-16 12:39:50" itemprop="dateCreated datePublished" datetime="2023-09-16T12:39:50+08:00">2023-09-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-07-30 19:22:12" itemprop="dateModified" datetime="2024-07-30T19:22:12+08:00">2024-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Linux的基础符号知识"><a href="#Linux的基础符号知识" class="headerlink" title="Linux的基础符号知识"></a>Linux的基础符号知识</h1><h3 id="重定向符号"><a href="#重定向符号" class="headerlink" title="重定向符号"></a>重定向符号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt;file.txt &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">cat &gt;&gt;file.txt &lt;&lt;EOF</span></span><br></pre></td></tr></table></figure>
<p>上面两个命令是不一样的，&gt; 代表清空原文件并写入；&gt;&gt; 代表追加。</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p><img src="/2023/09/16/linux/shell/shell/image.png" alt="Alt text"></p>
<ul>
<li>^：字符串的开头</li>
<li>$：字符串的结束</li>
</ul>
<h1 id="常用-Linxu-命令"><a href="#常用-Linxu-命令" class="headerlink" title="常用 Linxu 命令"></a>常用 Linxu 命令</h1><h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p>常用功能：</p>
<ul>
<li>查看文件内容：cat file.txt</li>
<li>合并文件：cat file1.txt file2.txt &gt; file3.txt</li>
<li>创建文件并写入内容：cat &gt;file.txt，回车后即可写入内容，Ctrl+C 退出写入模式。注意，只有当输入行被回车键入时才会写入文件。</li>
<li>追加内容到文件结尾：cat &gt;&gt;file.txt &lt;&lt;EOF，回车后即可写入内容，内容完成后回车，输入 EOF 再次回车，完成对文件的追加。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hxm@hxm:/mnt/e/C++/shell$ <span class="built_in">cat</span> &gt;&gt;file.txt &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&gt; I am ok.</span></span><br><span class="line"><span class="string">&gt; EOF</span></span><br><span class="line">hxm@hxm:/mnt/e/C++/shell$ <span class="built_in">cat</span> file.txt</span><br><span class="line">I am ok.</span><br></pre></td></tr></table></figure></li>
<li>清空文件内容：cat &#x2F;dev&#x2F;null &gt;file.txt</li>
<li>向文件中追加  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hxm@hxm:/mnt/e/C++/shell$ <span class="built_in">cat</span> file.txt</span><br><span class="line">hxm@hxm:/mnt/e/C++/shell$ <span class="built_in">echo</span> xiaohong | <span class="built_in">cat</span> &gt;&gt; file.txt</span><br><span class="line">hxm@hxm:/mnt/e/C++/shell$ <span class="built_in">cat</span> file.txt</span><br><span class="line">xiaohong</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><p>可以将文字显示在命令行中，也可以通过重定向符号写入文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello              <span class="comment"># 输出文本</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hello&#x27;</span>            <span class="comment"># 输出文本</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;hello\tworld&quot;</span>  <span class="comment"># 使用 -e 可以识别转义符</span></span><br><span class="line"><span class="built_in">echo</span> hello &gt;&gt;file.txt   <span class="comment"># 向文件中换行追加，文件不存在将创建文件。</span></span><br></pre></td></tr></table></figure>

<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep 参数 模式 文件</span><br></pre></td></tr></table></figure>

<p>一些常用命令：</p>
<ul>
<li>-v：显示不匹配的行，显示不包含匹配文本的所有行  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hxm@hxm:/mnt/e/C++/shell$ <span class="built_in">cat</span> file.txt</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">world</span><br><span class="line">hxm@hxm:/mnt/e/C++/shell$ <span class="built_in">cat</span> file.txt | grep -v hello</span><br><span class="line">world</span><br><span class="line">world</span><br></pre></td></tr></table></figure></li>
<li>-n：显示匹配的行及行号  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hxm@hxm:/mnt/e/C++/shell$ <span class="built_in">cat</span> file.txt</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">world</span><br><span class="line">hxm@hxm:/mnt/e/C++/shell$ <span class="built_in">cat</span> file.txt | grep -n hello</span><br><span class="line">1:hello</span><br></pre></td></tr></table></figure></li>
<li>-i：不区分大小写  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hxm@hxm:/mnt/e/C++/shell$ <span class="built_in">cat</span> file.txt</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">world</span><br><span class="line">hxm@hxm:/mnt/e/C++/shell$ <span class="built_in">cat</span> file.txt | grep -i HELLO</span><br><span class="line">hello</span><br></pre></td></tr></table></figure></li>
<li>-c：统计匹配的行数，不是匹配的次数  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hxm@hxm:/mnt/e/C++/shell$ cat file.txt</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">world</span><br><span class="line">hxm@hxm:/mnt/e/C++/shell$ cat file.txt | grep -c world</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li>-E：使用扩展的 egrep 命令，支持正则表达式  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hxm@hxm:/mnt/e/C++/shell$ <span class="built_in">cat</span> file.txt</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">world</span><br><span class="line">hxm@hxm:/mnt/e/C++/shell$ <span class="built_in">cat</span> file.txt | grep -E <span class="string">&quot;hello|world&quot;</span></span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">world</span><br></pre></td></tr></table></figure></li>
<li>–color&#x3D;auto：过滤指定字符串并添加颜色</li>
<li>-w：以单词为单位进行过滤</li>
<li>-o：只输出匹配内容</li>
</ul>
<h2 id="sed-流编辑器"><a href="#sed-流编辑器" class="headerlink" title="sed 流编辑器"></a>sed 流编辑器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [选项] [内置命令字符] [文件]</span><br></pre></td></tr></table></figure>
<p>选项：</p>
<ul>
<li>-n：取消默认输出</li>
<li>-i：将修改写入到文件</li>
<li>-e：允许多次编辑</li>
<li>-r：支持扩展正则表达式</li>
</ul>
<p>命令符：</p>
<ul>
<li>a：追加文本</li>
<li>d：删除匹配行的文本</li>
<li>i：在指定行前插入文本</li>
<li>p：打印匹配行内容</li>
<li>g：使替换具有全局性</li>
<li>s：替换字符串</li>
</ul>
<p>测试用例：</p>
<ul>
<li>打印文件内容  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hxm@hxm:/mnt/e/C++/shell$ <span class="built_in">cat</span> file.txt</span><br><span class="line">xiaoming</span><br><span class="line">xiaohong</span><br><span class="line">zhangsan</span><br><span class="line">lisi</span><br><span class="line">hxm@hxm:/mnt/e/C++/shell$ sed -n <span class="string">&#x27;p&#x27;</span> file.txt</span><br><span class="line">xiaoming</span><br><span class="line">xiaohong</span><br><span class="line">zhangsan</span><br><span class="line">lisi</span><br></pre></td></tr></table></figure></li>
<li>打印指定行内容（范围）  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hxm@hxm:/mnt/e/C++/shell$ sed -n <span class="string">&#x27;2,3p&#x27;</span> file.txt</span><br><span class="line">xiaohong</span><br><span class="line">zhangsan</span><br></pre></td></tr></table></figure></li>
<li>打印包含指定字符串的行  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hxm@hxm:/mnt/e/C++/shell$ sed -n <span class="string">&#x27;/xiao/p&#x27;</span> file.txt</span><br><span class="line">xiaoming</span><br><span class="line">xiaohong</span><br></pre></td></tr></table></figure></li>
<li>删除包含指定字符串的行，但不写入文件  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hxm@hxm:/mnt/e/C++/shell$ sed <span class="string">&#x27;/xiao/d&#x27;</span> file.txt</span><br><span class="line">zhangsan</span><br><span class="line">lisi</span><br><span class="line">hxm@hxm:/mnt/e/C++/shell$ <span class="built_in">cat</span> file.txt</span><br><span class="line">xiaoming</span><br><span class="line">xiaohong</span><br><span class="line">zhangsan</span><br><span class="line">lisi</span><br></pre></td></tr></table></figure></li>
<li>删除包含指定字符串的行，且写入文件  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hxm@hxm:/mnt/e/C++/shell$ sed -i <span class="string">&#x27;/xiao/d&#x27;</span> file.txt</span><br><span class="line">hxm@hxm:/mnt/e/C++/shell$ <span class="built_in">cat</span> file.txt</span><br><span class="line">zhangsan</span><br><span class="line">lisi</span><br></pre></td></tr></table></figure></li>
<li>替换字符串  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hxm@hxm:/mnt/e/C++/shell$ sed <span class="string">&#x27;s/xiao/da/g&#x27;</span> file.txt</span><br><span class="line">dahong</span><br><span class="line">daming</span><br><span class="line">zhangsan</span><br><span class="line">lisi</span><br></pre></td></tr></table></figure></li>
<li>多次修改  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hxm@hxm:/mnt/e/C++/shell$ sed -e <span class="string">&#x27;s/xiao/da/g&#x27;</span> -e <span class="string">&#x27;s/zhang/he/g&#x27;</span> file.txt</span><br><span class="line">dahong</span><br><span class="line">daming</span><br><span class="line">hesan</span><br><span class="line">lisi</span><br></pre></td></tr></table></figure></li>
<li>向指定行后面插入文本  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hxm@hxm:/mnt/e/C++/shell$ sed -n -e <span class="string">&#x27;2a lihua&#x27;</span> -e <span class="string">&#x27;p&#x27;</span> file.txt</span><br><span class="line">xiaohong</span><br><span class="line">xiaoming</span><br><span class="line">lihua</span><br><span class="line">zhangsan</span><br><span class="line">lisi</span><br></pre></td></tr></table></figure></li>
<li>向指定行的上面插入文本  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hxm@hxm:/mnt/e/C++/shell$ sed -n -e <span class="string">&#x27;2i lihua&#x27;</span> -e <span class="string">&#x27;p&#x27;</span> file.txt</span><br><span class="line">xiaohong</span><br><span class="line">lihua</span><br><span class="line">xiaoming</span><br><span class="line">zhangsan</span><br><span class="line">lisi</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk [option] <span class="string">&#x27;pattern&#123;action&#125;&#x27;</span> file...</span><br></pre></td></tr></table></figure>
<p>option 参数选项</p>
<ul>
<li>-F：指定字段分隔符</li>
<li>-v：定义或修改一个 awk 内部变量</li>
</ul>
<p>常见变量</p>
<ul>
<li>S0：当前整行记录</li>
<li>Sn：当前记录的第 n 列，由 FS 或 -F 指定分隔符</li>
<li>NF：当前记录中列的个数</li>
<li>S(NF-n)：倒数第 n+1 列</li>
<li>NR：行号</li>
</ul>
<p>测试用例</p>
<ul>
<li>打印指定行的内容  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hxm@hxm:/mnt/e/C++/shell$ awk <span class="string">&#x27;NR&gt;1&amp;&amp;NR&lt;4&#x27;</span> file.txt</span><br><span class="line">xiaoming</span><br><span class="line">zhangsan</span><br></pre></td></tr></table></figure></li>
<li>找出包含指定字符串的行  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hxm@hxm:/mnt/e/C++/shell$ awk <span class="string">&#x27;/xiao/&#x27;</span> file.txt</span><br><span class="line">xiaohong</span><br><span class="line">xiaoming</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h2><p>用以重复的执行命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab [ -u usr ] file</span><br><span class="line">crontab [ -u usr ] &#123;-l | -r | -e&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>-u：用来指定用户，缺省时默认是执行命令的用户。只有 root 用户可以指定其他用户。</li>
<li>-e：执行文字编辑器来设定时程表</li>
<li>-r：删除目前的时程表</li>
<li>-l：列出当前的时程表</li>
</ul>
<h2 id="执行周期的设置"><a href="#执行周期的设置" class="headerlink" title="执行周期的设置"></a>执行周期的设置</h2><p><img src="/2023/09/16/linux/shell/shell/image-1.png" alt="Alt text"></p>
<h1 id="Shebang-的作用"><a href="#Shebang-的作用" class="headerlink" title="Shebang 的作用"></a>Shebang 的作用</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/sh</span></span><br></pre></td></tr></table></figure>
<p>上述代码是一个 Shebang，它用来指定 .&#x2F;程序名 时需要使用的解释器。常见的 Shebang 有以下几种：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#! /bin/sh</span><br><span class="line">#! /usr/bin/python</span><br><span class="line">#! /usr/bin/env</span><br></pre></td></tr></table></figure>

<h1 id="shell-进程与变量"><a href="#shell-进程与变量" class="headerlink" title="shell 进程与变量"></a>shell 进程与变量</h1><p>执行 shell 脚本的方式有很多：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./main.sh       <span class="comment"># 创建新shell子进程，并在子进程中运行</span></span><br><span class="line">bash main.sh    <span class="comment"># 同上</span></span><br><span class="line"><span class="built_in">source</span> main.sh  <span class="comment"># 在当前shell环境下运行</span></span><br><span class="line">. main.sh       <span class="comment"># 同上</span></span><br></pre></td></tr></table></figure>

<p>测试用例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">hxm@hxm:/mnt/e/C++/shell$ a=5</span><br><span class="line">hxm@hxm:/mnt/e/C++/shell$ <span class="built_in">cat</span> main.sh</span><br><span class="line"><span class="comment">#! /usr/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"></span><br><span class="line">hxm@hxm:/mnt/e/C++/shell$ bash main.sh</span><br><span class="line"></span><br><span class="line">hxm@hxm:/mnt/e/C++/shell$ ./main.sh</span><br><span class="line"></span><br><span class="line">hxm@hxm:/mnt/e/C++/shell$ sh main.sh</span><br><span class="line"></span><br><span class="line">hxm@hxm:/mnt/e/C++/shell$ <span class="built_in">source</span> main.sh</span><br><span class="line">5</span><br><span class="line">hxm@hxm:/mnt/e/C++/shell$ . main.sh</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>在当前 shell 中定义了变量 a ，只有使用 source 和 . 执行脚本时才能访问到 a 的值。</p>
<p>使用 bash 命令可以开辟新的子进程 shell</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">hxm@hxm:/mnt/e/C++/shell$ ps -f</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">hxm      18437 18436  0 12:42 pts/5    00:00:00 -bash</span><br><span class="line">hxm      18674 18437  0 13:00 pts/5    00:00:00 ps -f</span><br><span class="line">hxm@hxm:/mnt/e/C++/shell$ bash</span><br><span class="line">hxm@hxm:/mnt/e/C++/shell$ ps -f</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">hxm      18437 18436  0 12:42 pts/5    00:00:00 -bash</span><br><span class="line">hxm      18678 18437  0 13:00 pts/5    00:00:00 bash</span><br><span class="line">hxm      18684 18678  0 13:00 pts/5    00:00:00 ps -f</span><br><span class="line">hxm@hxm:/mnt/e/C++/shell$ bash</span><br><span class="line">hxm@hxm:/mnt/e/C++/shell$ ps -f</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">hxm      18437 18436  0 12:42 pts/5    00:00:00 -bash</span><br><span class="line">hxm      18678 18437  0 13:00 pts/5    00:00:00 bash</span><br><span class="line">hxm      18685 18678  0 13:00 pts/5    00:00:00 bash</span><br><span class="line">hxm      18691 18685  0 13:00 pts/5    00:00:00 ps -f</span><br><span class="line">hxm@hxm:/mnt/e/C++/shell$ <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">hxm@hxm:/mnt/e/C++/shell$ ps -f</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">hxm      18437 18436  0 12:42 pts/5    00:00:00 -bash</span><br><span class="line">hxm      18678 18437  0 13:00 pts/5    00:00:00 bash</span><br><span class="line">hxm      18692 18678  0 13:01 pts/5    00:00:00 ps -f</span><br><span class="line">hxm@hxm:/mnt/e/C++/shell$ <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">hxm@hxm:/mnt/e/C++/shell$ ps -f</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">hxm      18437 18436  0 12:42 pts/5    00:00:00 -bash</span><br><span class="line">hxm      18696 18437  0 13:01 pts/5    00:00:00 ps -f</span><br></pre></td></tr></table></figure>

<h1 id="变量和类型"><a href="#变量和类型" class="headerlink" title="变量和类型"></a>变量和类型</h1><h2 id="普通变量"><a href="#普通变量" class="headerlink" title="普通变量"></a>普通变量</h2><p>a&#x3D;5<br>定义了一个普通变量，只能在当前shell中访问。</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>export a&#x3D;5<br>定义了一个环境变量，shell 和它的子 shell 都可以访问环境变量。</p>
<p><img src="/2023/09/16/linux/shell/shell/image-2.png" alt="Alt text"></p>
<h1 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h1><p>双引号和无引号都会解析引用的变量；而单引号不会解析。</p>
<p>测试用例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">hxm@hxm:/mnt/e/C++/shell$ cat main.sh</span><br><span class="line">#! /usr/bin/sh</span><br><span class="line">a=100-</span><br><span class="line">b=&#x27;200-$a&#x27;</span><br><span class="line">c=300-$a</span><br><span class="line">d=&quot;400-$a&quot;</span><br><span class="line">echo $a</span><br><span class="line">echo $b</span><br><span class="line">echo $c</span><br><span class="line">echo $d</span><br><span class="line">hxm@hxm:/mnt/e/C++/shell$ bash main.sh</span><br><span class="line">100-</span><br><span class="line">200-$a</span><br><span class="line">300-100-</span><br><span class="line">400-100-</span><br></pre></td></tr></table></figure>
<h1 id="将命令的结果赋值给变量"><a href="#将命令的结果赋值给变量" class="headerlink" title="将命令的结果赋值给变量"></a>将命令的结果赋值给变量</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=`ls`</span><br><span class="line">a=$(ls)</span><br></pre></td></tr></table></figure>
<h1 id="的作用"><a href="#的作用" class="headerlink" title="{}的作用"></a>{}的作用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=100</span><br><span class="line">echo a_xxx</span><br><span class="line"></span><br><span class="line">echo &#123;a&#125;_xxx</span><br><span class="line">100_xxx</span><br></pre></td></tr></table></figure>
<h1 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h1><p><img src="/2023/09/16/linux/shell/shell/image-3.png" alt="Alt text"></p>
<h1 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /usr/bin/sh</span></span><br><span class="line"></span><br><span class="line">file_name=$(<span class="built_in">pwd</span>)<span class="string">&#x27;/&#x27;</span>due.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$file_name</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> &lt; <span class="variable">$file_name</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> -r line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$line</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h1 id="文件安全"><a href="#文件安全" class="headerlink" title="文件安全"></a>文件安全</h1><p><img src="/2023/09/16/linux/shell/shell/image.png" alt="Alt text"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">何先生</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
