<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="东拼西凑、杂七杂八">
<meta property="og:type" content="website">
<meta property="og:title" content="北国回忆录">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="北国回忆录">
<meta property="og:description" content="东拼西凑、杂七杂八">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="何先生">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>北国回忆录</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <script src="https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js"></script>
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">北国回忆录</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">北国的冬日尚有余温</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">何先生</p>
  <div class="site-description" itemprop="description">东拼西凑、杂七杂八</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Torch-HXM" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Torch-HXM" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hxm_htjt@163.com" title="E-Mail → mailto:hxm_htjt@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/10/opengl/%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何先生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="北国回忆录">
      <meta itemprop="description" content="东拼西凑、杂七杂八">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 北国回忆录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/10/opengl/%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3/" class="post-title-link" itemprop="url">创建窗口</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-04-10 11:01:05" itemprop="dateCreated datePublished" datetime="2024-04-10T11:01:05+08:00">2024-04-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-07-30 19:06:39" itemprop="dateModified" datetime="2024-07-30T19:06:39+08:00">2024-07-30</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="初始化-GLFW-配置需要使用的-OpenGL-版本并启用核心开发模式"><a href="#初始化-GLFW-配置需要使用的-OpenGL-版本并启用核心开发模式" class="headerlink" title="初始化 GLFW 配置需要使用的 OpenGL 版本并启用核心开发模式"></a>初始化 GLFW 配置需要使用的 OpenGL 版本并启用核心开发模式</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span>      <span class="comment">// glad 头文件必须放在所有头文件之前</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 GLFW</span></span><br><span class="line">    <span class="built_in">glfwInit</span>();</span><br><span class="line">    <span class="comment">// glfwWindowHint 的第一个参数代表需要配置的选项，第二个参数是配置的值</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);                  <span class="comment">// 设置 OpenGL 的主版本为 3</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);                  <span class="comment">// 设置 OpenGL 的子版本为 3。这样我们就会使用 OpenGL 3.3 版本</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);  <span class="comment">// 使用 OpenGL 的核心开发模式</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hint n. 暗示，提示</span></span><br></pre></td></tr></table></figure>

<h1 id="创建窗口并配置上下文"><a href="#创建窗口并配置上下文" class="headerlink" title="创建窗口并配置上下文"></a>创建窗口并配置上下文</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;opengl test window&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">// 创建窗口，前三个参数依次是 宽、高、窗口名称</span></span><br><span class="line"><span class="keyword">if</span>(window==<span class="literal">NULL</span>)&#123;</span><br><span class="line">	std::cout&lt;&lt; <span class="string">&quot;Failed to create window with glfw.\n&quot;</span>;</span><br><span class="line">	<span class="built_in">glfwTerminate</span>();<span class="comment">// 如果窗口创建失败，则结束 GLFW</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);<span class="comment">// 通知 GLFW 我们将使用该窗口。也被称为设置窗口上下文。</span></span><br></pre></td></tr></table></figure>

<h1 id="解决窗口缩放问题"><a href="#解决窗口缩放问题" class="headerlink" title="解决窗口缩放问题"></a>解决窗口缩放问题</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">frameBufferSizeCallback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>&#123;&#125;<span class="comment">// 设置窗口缩放的回调函数</span></span><br><span class="line"><span class="built_in">glfwSetFramebufferSizeCallback</span>(window, frameBufferSizeCallback);<span class="comment">// 将回调函数注册</span></span><br></pre></td></tr></table></figure>

<h1 id="初始化-glad"><a href="#初始化-glad" class="headerlink" title="初始化 glad"></a>初始化 glad</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))&#123;<span class="comment">// 在使用任何 OpenGL 函数之前，必须加载并初始化他们的管理库 glad</span></span><br><span class="line">	std::cout&lt;&lt; <span class="string">&quot;Failed to initalize glad.\n&quot;</span>;      <span class="comment">// 所以，在使用函数之前，判断 glad 是否被成功加载并初始化</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="设置渲染窗口并让渲染窗口随-GLFW-窗口一同缩放"><a href="#设置渲染窗口并让渲染窗口随-GLFW-窗口一同缩放" class="headerlink" title="设置渲染窗口并让渲染窗口随 GLFW 窗口一同缩放"></a>设置渲染窗口并让渲染窗口随 GLFW 窗口一同缩放</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置渲染窗口的尺寸。注意 GLFW 的窗口是整体的显示窗口，我们也可以将渲染窗口设置的比 GLFW 窗口小，这样我们就可以在窗口剩余部分显示其他数据。</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>); <span class="comment">// 前两个参数为渲染窗口左下角的坐标，后两个参数为渲染窗口的宽和高</span></span><br><span class="line"><span class="comment">// 在回调函数中重新设置渲染窗口的大小和位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">frameBufferSizeCallback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>&#123;<span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);&#125;</span><br></pre></td></tr></table></figure>

<h1 id="让窗口持续存在"><a href="#让窗口持续存在" class="headerlink" title="让窗口持续存在"></a>让窗口持续存在</h1><p>我们之前所写的程序编译后执行会什么都看不见，其实它只生成了一帧窗口，然后马上就消失掉了。所以我们看不见。因此需要让窗口被持续渲染。这个循环称为主循环。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))&#123;     <span class="comment">// 检查窗口是否需要被关闭</span></span><br><span class="line">	<span class="built_in">glfwSwapBuffers</span>(window);           <span class="comment">// 交换颜色缓冲区，负责更新每一帧的颜色</span></span><br><span class="line">	<span class="built_in">glfwPollEvents</span>();                  <span class="comment">// 监听用户的交互事件，鼠标、键盘输入等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h1><p>最后，释放掉所有的窗口和资源</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glfwTerminate</span>();                          <span class="comment">// 删除之前配置的所有资源</span></span><br></pre></td></tr></table></figure>

<p>编译运行后会出现一个黑色的窗口。此时，如果你调整窗口的大小，将窗口拉大，会发现窗口中出现黑色条纹。这是因为我们并没有在每一帧中重新设置窗口的颜色缓冲区，它每一帧交换的都是旧的颜色缓冲区。为了更新每一帧的颜色缓冲区，我们需要了解窗口主循环的一般结构。</p>
<h1 id="窗口主循环的一般结构"><a href="#窗口主循环的一般结构" class="headerlink" title="窗口主循环的一般结构"></a>窗口主循环的一般结构</h1><p>为了让主循环中的代码在窗口每一次被渲染前执行，我们需要有如下的主循环结构。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))&#123;</span><br><span class="line">	<span class="comment">// 检查输入</span></span><br><span class="line">	<span class="built_in">checkInput</span>(window);</span><br><span class="line">	<span class="comment">// 渲染指令</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 更新窗口</span></span><br><span class="line">	<span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">	<span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个简单的 checkInput 代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkInput</span><span class="params">(GLFWwindow* window)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE)==GLFW_PRESS)&#123;</span><br><span class="line">        <span class="comment">// 事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它能够让你在按下键盘的 ESC 键时做出相应的反应。</p>
<h1 id="简单的渲染——清空缓冲区"><a href="#简单的渲染——清空缓冲区" class="headerlink" title="简单的渲染——清空缓冲区"></a>简单的渲染——清空缓冲区</h1><p>上一节中，我们发现我们的窗口在放大时会出现渲染不完全的情况，我们说是由于它一直在使用旧的颜色缓冲区，颜色缓冲区没有得到更新。那么这里，我们尝试更新每一帧的颜色缓冲区。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))&#123;           <span class="comment">// 检查窗口是否需要被关闭</span></span><br><span class="line">	<span class="comment">// 检查输入</span></span><br><span class="line">	<span class="built_in">checkInput</span>(window);</span><br><span class="line">	<span class="comment">// 渲染</span></span><br><span class="line">	<span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);    <span class="comment">// 设置清空缓冲区所用的颜色</span></span><br><span class="line">	<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);            <span class="comment">// 清空颜色缓冲区。它的参数代表清空谁的缓冲区，对象包括 颜色、深度、模板</span></span><br><span class="line">	<span class="comment">// 更新</span></span><br><span class="line">	<span class="built_in">glfwSwapBuffers</span>(window);                 <span class="comment">// 交换颜色缓冲区，负责更新每一帧的颜色</span></span><br><span class="line">	<span class="built_in">glfwPollEvents</span>();                        <span class="comment">// 监听用户的交互事件，鼠标、键盘输入等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后执行，拉大窗口不再出现问题。</p>
<h1 id="完整程序"><a href="#完整程序" class="headerlink" title="完整程序"></a>完整程序</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span>      <span class="comment">// glad 头文件必须放在所有头文件之前</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">frameBufferSizeCallback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkInput</span><span class="params">(GLFWwindow* window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 GLFW</span></span><br><span class="line">    <span class="built_in">glfwInit</span>();</span><br><span class="line">    <span class="comment">// glfwWindowHint 的第一个参数代表需要配置的选项，第二个参数是配置的值</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);                  <span class="comment">// 设置 OpenGL 的主版本为 3</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);                  <span class="comment">// 设置 OpenGL 的子版本为 3。这样我们就会使用 OpenGL 3.3 版本</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);  <span class="comment">// 使用 OpenGL 的核心开发模式</span></span><br><span class="line"></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;opengl test window&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);  <span class="comment">// 创建窗口，前三个参数依次是 宽、高、窗口名称</span></span><br><span class="line">    <span class="keyword">if</span>(window==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        std::cout&lt;&lt; <span class="string">&quot;Failed to create window with glfw.\n&quot;</span>;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();                                                                <span class="comment">// 如果窗口创建失败，则结束 GLFW</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);                                 <span class="comment">// 通知 GLFW 我们将使用该窗口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))&#123;        <span class="comment">// 在使用任何 OpenGL 函数之前，必须加载并初始化他们的管理库 glad</span></span><br><span class="line">        std::cout&lt;&lt; <span class="string">&quot;Failed to initalize glad.\n&quot;</span>;                  <span class="comment">// 所以，在使用函数之前，判断 glad 是否被成功加载并初始化</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置渲染窗口的尺寸。注意 GLFW 的窗口是整体的显示窗口，我们也可以将渲染窗口设置的比 GLFW 窗口小，这样我们就可以在窗口剩余部分显示其他数据。</span></span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>); <span class="comment">// 前两个参数为渲染窗口左下角的坐标，后两个参数为渲染窗口的宽和高</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSetFramebufferSizeCallback</span>(window, frameBufferSizeCallback);<span class="comment">// 将回调函数注册</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))&#123;                          <span class="comment">// 检查窗口是否需要被关闭</span></span><br><span class="line">        <span class="comment">// 检查输入</span></span><br><span class="line">        <span class="built_in">checkInput</span>(window);</span><br><span class="line">        <span class="comment">// 渲染</span></span><br><span class="line">        <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);                       <span class="comment">// 设置清空缓冲区所用的颜色</span></span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);                               <span class="comment">// 清空颜色缓冲区。它的参数代表清空谁的缓冲区，对象包括 颜色、深度、模板</span></span><br><span class="line">        <span class="comment">// 更新</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);                                    <span class="comment">// 交换颜色缓冲区，负责更新每一帧的颜色</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();                                           <span class="comment">// 监听用户的交互事件，鼠标、键盘输入等</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();                                                <span class="comment">// 删除之前配置的所有资源</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hint n. 暗示，提示</span></span><br><span class="line"><span class="comment">// g++ -o out main.cpp lib/glad.c -lglfw -lGL -lm -lXrandr -lXi -lX11 -lXxf86vm -lpthread -ldl -lXinerama -lXcursor</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">frameBufferSizeCallback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>&#123;<span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);&#125;<span class="comment">// 设置回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkInput</span><span class="params">(GLFWwindow* window)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE)==GLFW_PRESS)&#123;</span><br><span class="line">        <span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参考链接</strong>：<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/01%20Getting%20started/03%20Hello%20Window/">你好，窗口</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/10/cmake/cmake%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何先生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="北国回忆录">
      <meta itemprop="description" content="东拼西凑、杂七杂八">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 北国回忆录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/10/cmake/cmake%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">cmake基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2024-04-10 10:26:34 / Modified: 10:28:15" itemprop="dateCreated datePublished" datetime="2024-04-10T10:26:34+08:00">2024-04-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38410730/article/details/103741579">configure_file 指令</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/06/hexo/hexo%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何先生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="北国回忆录">
      <meta itemprop="description" content="东拼西凑、杂七杂八">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 北国回忆录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/06/hexo/hexo%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">进程间交换数据的方式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-04-06 19:21:12" itemprop="dateCreated datePublished" datetime="2024-04-06T19:21:12+08:00">2024-04-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-04-09 18:54:26" itemprop="dateModified" datetime="2024-04-09T18:54:26+08:00">2024-04-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="为-next-添加代码折叠"><a href="#为-next-添加代码折叠" class="headerlink" title="为 next 添加代码折叠"></a>为 next 添加代码折叠</h4><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/75fd3df29258">链接</a></p>
<h4 id="is-not-defined"><a href="#is-not-defined" class="headerlink" title="$ is not defined"></a>$ is not defined</h4><p>在 theme\theme_name\layout\_layout.njk 的 body 标签下加入</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/06/linux/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E9%97%B4%E4%BA%A4%E6%8D%A2%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何先生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="北国回忆录">
      <meta itemprop="description" content="东拼西凑、杂七杂八">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 北国回忆录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/06/linux/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E9%97%B4%E4%BA%A4%E6%8D%A2%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">进程间交换数据的方式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-04-06 19:21:12" itemprop="dateCreated datePublished" datetime="2024-04-06T19:21:12+08:00">2024-04-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-07-30 19:20:29" itemprop="dateModified" datetime="2024-07-30T19:20:29+08:00">2024-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="进程间的管道通信"><a href="#进程间的管道通信" class="headerlink" title="进程间的管道通信"></a>进程间的管道通信</h2><!-- ### 信号

信号是最简单的进程间的通信方式。它的工作流程如下：

1. 进程 A 需要预先知道 进程 B 的 PID，这样，进程 A 才能够向进程 B 发送信号。

2. 进程 B 接收到信号后，做出相应的反应。

通过信号进行进程间的通信有很大的局限性。因为信号只能传递动作指令而不能传递数据。在 Linux 系统中，信号的种类是有限的，可以通过命令`kill -l`来查询。由于本篇文章主要研究进程间的数据交换，所以不对信号进行详细介绍。 -->

<h3 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h3><p>管道是两个进程之间的共享文件，数据能够在管道中单向传输。匿名管道由于无法被显示指定（因为它没有名字，所以只能在创建它的程序中以变量的形式用文件描述符指定）所以只能在具有公共祖先的进程之间使用（因为公共祖先的进程之间可以共享这个文件描述符）。这是匿名管道的局限之一。</p>
<p>虽然管道是一个文件，但是它具有独特的特点：</p>
<ol>
<li>不支持文件指针的移动，所以只能读取当前位置。不能读取文件的任意位置。</li>
<li>管道像一个队列，输入的数据遵循先进先出。</li>
<li>数据被读取后就被管道删除掉。</li>
<li>若管道为空，则 read 读取操作会被阻塞或返回 0 （取决于管道的模式）。</li>
<li>若试图向一个没有读进程的管道写入数据，会收到 SIGPIPE 信号。若没有在写进程中捕捉该信号，则会造成写进程终止。</li>
</ol>
<h3 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h3><p>命名管道可以通过管道名称指定，因此可以在两个不相关进程之间使用，只要他们提前约定好管道名称即可。命名管道的写入读出特性同匿名管道。</p>
<p>此外，匿名管道在读写进程结束后自动删除。而命名管道需要手动删除。</p>
<h2 id="进程间的通信方式实现"><a href="#进程间的通信方式实现" class="headerlink" title="进程间的通信方式实现"></a>进程间的通信方式实现</h2><h3 id="匿名管道-1"><a href="#匿名管道-1" class="headerlink" title="匿名管道"></a>匿名管道</h3><h4 id="C-C-相关-API"><a href="#C-C-相关-API" class="headerlink" title="C\C++ 相关 API"></a>C\C++ 相关 API</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>         <span class="comment">// read、write、pipe、fork 函数所需</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>      <span class="comment">// ssize_t、pid_t 所需</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span>       <span class="comment">// wait 所需</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * filedes 表示两个文件描述符</span></span><br><span class="line"><span class="comment"> * filedes[0] 指向管道的读端</span></span><br><span class="line"><span class="comment"> * filedes[1] 指向管道的写端</span></span><br><span class="line"><span class="comment"> * 管道默认以阻塞模式打开。可以通过 fcuntl() 修改管道的阻塞属性</span></span><br><span class="line"><span class="comment"> * 创建成功返回 0 ，失败返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(<span class="type">int</span> filedes[<span class="number">2</span>])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * fd   读取文件的文件描述符</span></span><br><span class="line"><span class="comment"> * buf  读取数据的储存区</span></span><br><span class="line"><span class="comment"> * count读取的字节数</span></span><br><span class="line"><span class="comment"> * 成功时返回读取到的字节数，失败时返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* buf, <span class="type">size_t</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * fd   写入文件的文件描述符</span></span><br><span class="line"><span class="comment"> * buf  需要被写入的储存区指针</span></span><br><span class="line"><span class="comment"> * count需要写入的字节数</span></span><br><span class="line"><span class="comment"> * 成功时返回写入的字节数，失败时返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span>* buf, <span class="type">size_t</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建一个子进程</span></span><br><span class="line"><span class="comment"> * 若创建成功，则父进程中该函数返回子进程的 PID，子进程中该函数返回0</span></span><br><span class="line"><span class="comment"> * 若创建失败，则调用该函数在调用进程中返回 -1.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">fork</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 阻塞自身，并等待子进程结束</span></span><br><span class="line"><span class="comment"> * 子进程的结束状态由 status 返回</span></span><br><span class="line"><span class="comment"> * 执行成功返回子进程 pid，失败返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">wait</span><span class="params">(<span class="type">int</span>* status)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="C-C-例程——父子进程间通信"><a href="#C-C-例程——父子进程间通信" class="headerlink" title="C\C++ 例程——父子进程间通信"></a>C\C++ 例程——父子进程间通信</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">char</span> msg[] = <span class="string">&quot;test for pipe&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pipe</span>(fd)==<span class="number">-1</span>)&#123;               <span class="comment">// 创建管道</span></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;匿名管道创建失败&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid = fork();                   <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;                      </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;子进程创建失败&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;                <span class="comment">// 如果当前进程是子进程</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">1</span>]);               <span class="comment">// 关闭写描述符</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process ready to read ...\n&quot;</span>);</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">read</span>(fd[<span class="number">0</span>], buf, <span class="built_in">sizeof</span>(buf));        <span class="comment">// 等待读取管道上的数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child get: %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]);               <span class="comment">// 关闭读描述符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]);                   <span class="comment">// 关闭读描述符</span></span><br><span class="line">        <span class="built_in">write</span>(fd[<span class="number">1</span>], msg, <span class="built_in">strlen</span>(msg)); <span class="comment">// 将数据写入管道</span></span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);                     <span class="comment">// 等待子进程退出</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">1</span>]);                   <span class="comment">// 关闭写描述符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="python-例程——父子进程间通信"><a href="#python-例程——父子进程间通信" class="headerlink" title="python 例程——父子进程间通信"></a>python 例程——父子进程间通信</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">r, w = os.pipe()    <span class="comment"># 创建管道</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    pid = os.fork() <span class="comment"># 创建子进程</span></span><br><span class="line"><span class="keyword">except</span> OSError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span> :       <span class="comment"># 当前进程为子进程时</span></span><br><span class="line">    os.close(w)     <span class="comment"># 关闭写描述符</span></span><br><span class="line">    content = os.read(r, <span class="number">200</span>)   <span class="comment"># 等待读取内容</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;child get: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(content))</span><br><span class="line">    os.close(r)</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:               <span class="comment"># 当前进程为父进程时</span></span><br><span class="line">    os.close(r)     <span class="comment"># 关闭读描述符</span></span><br><span class="line">    write_bytes = os.write(w, <span class="string">&quot;test for pipe&quot;</span>)  <span class="comment"># 写入内容</span></span><br><span class="line">    pid, status = os.wait()                     <span class="comment"># 等待子进程退出</span></span><br><span class="line">    os.close(w)                                 <span class="comment"># 关闭写描述符</span></span><br><span class="line">    exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="命名管道-1"><a href="#命名管道-1" class="headerlink" title="命名管道"></a>命名管道</h3><h4 id="C-C-相关-API-1"><a href="#C-C-相关-API-1" class="headerlink" title="C\C++ 相关 API"></a>C\C++ 相关 API</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>   <span class="comment">// mkfifo 所需</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>  <span class="comment">// mkfifo 所需</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>      <span class="comment">// open 所需</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * filename 管道绝对路径</span></span><br><span class="line"><span class="comment"> * mode     管道文件权限（三位数字权限）</span></span><br><span class="line"><span class="comment"> * 默认创建管道，如果路径下管当文件已存在，则发出 EEXIST 错误。因此一般搭配 access 函数来判断管道是否存在</span></span><br><span class="line"><span class="comment"> * 管道创建成功返回 0， 失败返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename, <span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * pathname 被测试文件的路径</span></span><br><span class="line"><span class="comment"> * mode     测试权限</span></span><br><span class="line"><span class="comment"> * mode==R_OK   测试读权限</span></span><br><span class="line"><span class="comment"> * mode==W_OK   测试写权限</span></span><br><span class="line"><span class="comment"> * mode==X_OK   测试执行权限</span></span><br><span class="line"><span class="comment"> * mode==F_OK   测试文件是否存在</span></span><br><span class="line"><span class="comment"> * 测试成功返回 0，失败返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">int</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * patchname    文件绝对路径</span></span><br><span class="line"><span class="comment"> * flags        打开方式（读、写...）</span></span><br><span class="line"><span class="comment"> * mode         当文件不存在时，open 会创建文件，使用 mode 设置文件权限</span></span><br><span class="line"><span class="comment"> * 执行成功返回文件描述符，失败返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="例程——两个-C-C-进程间通信"><a href="#例程——两个-C-C-进程间通信" class="headerlink" title="例程——两个 C\C++ 进程间通信"></a>例程——两个 C\C++ 进程间通信</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 进程 A，消息发送端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> pipe_path[] = <span class="string">&quot;/home/torch/code/linux-c++/chat/anonymity/pipe.fifo&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建管道</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">access</span>(pipe_path, F_OK)==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">mkfifo</span>(pipe_path, <span class="number">0664</span>)==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;命名管道文件创建失败：&quot;</span>);</span><br><span class="line">            <span class="built_in">fflush</span>(stdout);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道创建完成\n&quot;</span>);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 像匿名管道一样使用所创建的管道文件</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(pipe_path, O_WRONLY);     <span class="comment">// 以写入的方式打开管道</span></span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;管道文件打开失败：&quot;</span>);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[] = <span class="string">&quot;test for pipe&quot;</span>;</span><br><span class="line">    <span class="type">ssize_t</span> write_num = <span class="built_in">write</span>(fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);  <span class="comment">// 把 &#x27;\0&#x27; 也写入管道</span></span><br><span class="line">    <span class="keyword">if</span>(write_num==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;写入数据失败：&quot;</span>);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;写入 %lu 字节：%s\n&quot;</span>, write_num, buf);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 进程 B，数据读取端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> pipe_path[] = <span class="string">&quot;/home/torch/code/linux-c++/chat/anonymity/pipe.fifo&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建管道</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">access</span>(pipe_path, F_OK)==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">mkfifo</span>(pipe_path, <span class="number">0664</span>)==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;命名管道文件创建失败：&quot;</span>);</span><br><span class="line">            <span class="built_in">fflush</span>(stdout);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道创建完成\n&quot;</span>);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 像匿名管道一样使用所创建的管道文件</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(pipe_path, O_RDONLY);     <span class="comment">// 以写入的方式打开管道</span></span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;管道文件打开失败：&quot;</span>);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">50</span>];</span><br><span class="line">    <span class="type">ssize_t</span> read_num = <span class="built_in">read</span>(fd, buf, <span class="built_in">sizeof</span>(buf));  <span class="comment">// 管道没有数据时，会阻塞</span></span><br><span class="line">    <span class="keyword">if</span>(read_num==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;读取数据失败：&quot;</span>);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;读取 %lu 字节：%s\n&quot;</span>, read_num, buf);</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进程结束后，pipe.fifo 仍然存在</p>
<h4 id="例程——两个-python-进程间通信"><a href="#例程——两个-python-进程间通信" class="headerlink" title="例程——两个 python 进程间通信"></a>例程——两个 python 进程间通信</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A 进程 写入端</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">pipe_path = <span class="string">&quot;/home/torch/code/linux-c++/chat/anonymity/pipe.fifo&quot;</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">not</span> os.access(pipe_path, os.F_OK)):</span><br><span class="line">    os.mkfifo(pipe_path, <span class="number">664</span>)</span><br><span class="line"></span><br><span class="line">fd = os.<span class="built_in">open</span>(pipe_path, os.O_WRONLY)</span><br><span class="line"><span class="keyword">if</span>(fd == -<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;打开管道失败&quot;</span>)</span><br><span class="line">    exit(-<span class="number">1</span>)</span><br><span class="line">write_num = os.write(fd, <span class="string">&quot;test for pipe&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(write_num==-<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;写入管道失败&quot;</span>)</span><br><span class="line">    exit(-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;写入了 &#123;&#125; 字节：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(write_num, <span class="string">&quot;test for pipe&quot;</span>))</span><br><span class="line">os.close(fd)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># B 进程 读取端</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">pipe_path = <span class="string">&quot;/home/torch/code/linux-c++/chat/anonymity/pipe.fifo&quot;</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">not</span> os.access(pipe_path, os.F_OK)):</span><br><span class="line">    os.mkfifo(pipe_path, <span class="number">664</span>)</span><br><span class="line"></span><br><span class="line">fd = os.<span class="built_in">open</span>(pipe_path, os.O_RDONLY)</span><br><span class="line"><span class="keyword">if</span>(fd == -<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;打开管道失败&quot;</span>)</span><br><span class="line">    exit(-<span class="number">1</span>)</span><br><span class="line">buf = os.read(fd, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;读取了 &#123;&#125; 字节：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(buf), buf.decode()))</span><br><span class="line">os.close(fd)</span><br></pre></td></tr></table></figure>

<h4 id="例程——python-进程与-C-C-进程通信"><a href="#例程——python-进程与-C-C-进程通信" class="headerlink" title="例程——python 进程与 C\C++ 进程通信"></a>例程——python 进程与 C\C++ 进程通信</h4><p><a href="#%E4%BE%8B%E7%A8%8B%E4%B8%A4%E4%B8%AA-cc-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1">A 发送数据进程</a><br><a href="#%E4%BE%8B%E7%A8%8B%E4%B8%A4%E4%B8%AA-python-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1">B 接收数据进程</a></p>
<h4 id="传递复杂的数据——numpy-数组"><a href="#传递复杂的数据——numpy-数组" class="headerlink" title="传递复杂的数据——numpy 数组"></a>传递复杂的数据——numpy 数组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A 进程 写入numpy数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">pipe_path = <span class="string">&quot;/home/torch/code/linux-c++/chat/anonymity/pipe.fifo&quot;</span></span><br><span class="line">array = np.ones((<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">array_list = array.tolist()                                     <span class="comment"># 需先转为 python 内置类型</span></span><br><span class="line">data = json.dumps(array_list, ensure_ascii=<span class="literal">False</span>, indent=<span class="number">4</span>)     <span class="comment"># 转为 json 串</span></span><br><span class="line">data = data+<span class="string">&#x27;\0&#x27;</span>                                                <span class="comment"># 增加字符串结尾</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">not</span> os.access(pipe_path, os.F_OK)):</span><br><span class="line">    os.mkfifo(pipe_path, <span class="number">664</span>)</span><br><span class="line"></span><br><span class="line">fd = os.<span class="built_in">open</span>(pipe_path, os.O_WRONLY)</span><br><span class="line"><span class="keyword">if</span>(fd == -<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;打开管道失败&quot;</span>)</span><br><span class="line">    exit(-<span class="number">1</span>)</span><br><span class="line">write_num = os.write(fd, data.encode())</span><br><span class="line"><span class="keyword">if</span>(write_num==-<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;写入管道失败&quot;</span>)</span><br><span class="line">    exit(-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;写入了 &#123;&#125; 字节：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(write_num, data))</span><br><span class="line">os.close(fd)</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * B 进程，读取并解析 numpy 数组</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/06/opengl/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何先生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="北国回忆录">
      <meta itemprop="description" content="东拼西凑、杂七杂八">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 北国回忆录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/06/opengl/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">环境配置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-04-06 18:21:44" itemprop="dateCreated datePublished" datetime="2024-04-06T18:21:44+08:00">2024-04-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-04-10 10:54:49" itemprop="dateModified" datetime="2024-04-10T10:54:49+08:00">2024-04-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">所有代码和过程都已经过测试</span><br><span class="line">测试环境：Ubuntu WSL 18.04</span><br></pre></td></tr></table></figure>

<h3 id="安装-GLFW"><a href="#安装-GLFW" class="headerlink" title="安装 GLFW"></a>安装 GLFW</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 GLFW</span></span><br><span class="line">sudo apt-get install libglfw3-dev</span><br></pre></td></tr></table></figure>

<h3 id="安装-glad"><a href="#安装-glad" class="headerlink" title="安装 glad"></a>安装 glad</h3><h4 id="查看-OpenGL-版本"><a href="#查看-OpenGL-版本" class="headerlink" title="查看 OpenGL 版本"></a>查看 OpenGL 版本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install mesa-utils</span><br><span class="line">DISPLAY=:0 glxgears -info | grep GL_VERSION</span><br></pre></td></tr></table></figure>

<blockquote>
<p>GL_VERSION    &#x3D; 3.1 Mesa 20.0.8</p>
</blockquote>
<p>版本是 3.1</p>
<h4 id="下载-glad-压缩包"><a href="#下载-glad-压缩包" class="headerlink" title="下载 glad 压缩包"></a>下载 glad 压缩包</h4><p><a target="_blank" rel="noopener" href="https://glad.dav1d.de/">下载地址</a></p>
<p>在 API 部分选择自己的版本，然后点击网页右下角的 GENERATE 进入下载页面。在下载页面中下载 glad.zip</p>
<p><img src="/2024/04/06/opengl/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image.png" alt="image"></p>
<h4 id="解压压缩包，安装库文件"><a href="#解压压缩包，安装库文件" class="headerlink" title="解压压缩包，安装库文件"></a>解压压缩包，安装库文件</h4><p>进入下载目录执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> glad &amp;&amp; unzip glad.zip -d glad &amp;&amp; <span class="built_in">cd</span> glad/include</span><br><span class="line">sudo <span class="built_in">mv</span> glad/ /usr/local/include</span><br><span class="line">sudo <span class="built_in">mv</span> KHR/ /usr/local/include</span><br></pre></td></tr></table></figure>

<p>另外，在 glad&#x2F;src 目录下的 glad.c 文件需要放在你的工程文件夹下，或者你也可以在工程文件夹下创建一个 lib 文件夹来存放它。它需要和我们的主程序一起被编译。</p>
<h3 id="测试和注意事项"><a href="#测试和注意事项" class="headerlink" title="测试和注意事项"></a>测试和注意事项</h3><h4 id="工程文件夹目录结构"><a href="#工程文件夹目录结构" class="headerlink" title="工程文件夹目录结构"></a>工程文件夹目录结构</h4><p>├── build<br>├── include<br>│   └── glad.c<br>├── CMakeLists.txt<br>├── main.cpp</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span>      <span class="comment">// glad 头文件必须放在所有头文件之前</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CMakeLists"><a href="#CMakeLists" class="headerlink" title="CMakeLists"></a>CMakeLists</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="comment"># specify the C++ standard</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># set the project name</span></span><br><span class="line"><span class="keyword">project</span>(depthViewer)</span><br><span class="line"><span class="comment"># add the executable</span></span><br><span class="line"><span class="keyword">set</span>(SRC_LIST src/main.cpp <span class="keyword">include</span>/glad.c)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="comment"># 链接库</span></span><br><span class="line"><span class="keyword">set</span>(LIB_LINKS glfw GL Xrandr Xi X11 Xxf86vm pthread dl Xinerama Xcursor)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;LIB_LINKS&#125;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p><strong>glad 头文件必须放在所有 OpenGL 头文件之前，否则会报错！</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/25/linux/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%882%EF%BC%89-%E7%AE%A1%E9%81%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何先生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="北国回忆录">
      <meta itemprop="description" content="东拼西凑、杂七杂八">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 北国回忆录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/25/linux/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%882%EF%BC%89-%E7%AE%A1%E9%81%93/" class="post-title-link" itemprop="url">Linux多进程编程-进程间通信（2）-管道</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-25 16:45:52" itemprop="dateCreated datePublished" datetime="2023-09-25T16:45:52+08:00">2023-09-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-07-30 19:20:33" itemprop="dateModified" datetime="2024-07-30T19:20:33+08:00">2024-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="什么是管道"><a href="#什么是管道" class="headerlink" title="什么是管道"></a>什么是管道</h3><p>管道是进程间的一种通信方式，它是一个文件，更像一个队列。写进程将数据写入管道，只能写在管道的末尾；读进程读取管道数据，只能从当前位置读取，不能改变文件偏移量。管道中的数据严格执行先进先出。</p>
<h3 id="管道的特点"><a href="#管道的特点" class="headerlink" title="管道的特点"></a>管道的特点</h3><ul>
<li>进程通过read和write函数操作管道。</li>
<li>所有读取操作只能从管道文件的当前位置开始读，不支持文件指针（文件偏移量）的移动。</li>
<li>所有的写操作只能写在管道文件的末尾。</li>
<li>对于没有写进程的管道，读进程在调用read函数后会返回0.</li>
<li>如果管道中没有数据，但有写进程，则read函数会被阻塞。也可以通过fcuntl函数设置管道，让该情况下的read函数立刻返回。</li>
<li>对于没有读进程的管道，写进程会收到SIGPIPE信号，默认情况下，如果没有在程序中捕获该信号，则会导致程序终止。</li>
<li>默认情况下，写操作会导致进程阻塞。</li>
</ul>
<h3 id="管道的局限性"><a href="#管道的局限性" class="headerlink" title="管道的局限性"></a>管道的局限性</h3><ul>
<li>读进程不能写入数据</li>
<li>数据一旦被读便不再存在于管道</li>
<li>数据只能从写进程流向读进程</li>
<li>只有具有公共祖先的进程才可以使用管道</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param filedes[2]   文件描述符数组指针。其中filedes[0]指向管道的读端，filedes[1]指向管道的写端</span></span><br><span class="line"><span class="comment"> * @return 执行成功时返回0， 失败时返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(<span class="type">int</span> filedes[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<p>在两个文件描述符之间创建管道之后，可以通过 read(filedes[0]) 和 write(filedes[1]) 进行读写通信。但要注意，当管道中没有东西可以被读取时，read(filedes[0]) 将会被阻塞，管道的读取段进程将暂停；当管道满时，write(filedes[1]) 将会被阻塞，管道写入段进程将暂停。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>管道常用于父进程与子进程之间的通信，因为父进程在获得管道的读端和写端文件描述符后会被子进程继承，它们具有使用管道通信的先天优势。父进程与子进程进行管道通信的步骤如下：</p>
<ul>
<li>父进程调用 pipe 创建管道，得到管道读端和写端文件描述符</li>
<li>父进程fork出子进程，子进程继承管道的文件描述符</li>
<li>父进程关闭读端描述符，子进程关闭写端描述符。父进程与子进程之间实现管道通信</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> p[] = <span class="string">&quot;test for pipe\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pipe</span>(fd)==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sys_err</span>(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sys_err</span>(<span class="string">&quot;fork err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">1</span>]);                               <span class="comment">// 关闭子进程的写端</span></span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;child process wait to read:\n&quot;</span>;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">read</span>(fd[<span class="number">0</span>], buf, <span class="built_in">sizeof</span>(buf));    <span class="comment">// 等待父进程写入</span></span><br><span class="line">        <span class="built_in">write</span>(STDOUT_FILENO, buf, len);             <span class="comment">// 将读取到的内容写入标准输出</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]);                               <span class="comment">// 关闭读端</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]);                               <span class="comment">// 关闭父进程读端</span></span><br><span class="line">        <span class="built_in">write</span>(fd[<span class="number">1</span>], p, <span class="built_in">strlen</span>(p));                 <span class="comment">// 写入管道</span></span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);                                 <span class="comment">// 等待进程组中的任一进程退出，该进程组中只有唯一子进程</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">1</span>]);                               <span class="comment">// 关闭写端</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cerr&lt;&lt; str&lt;&lt; endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>child process wait to read:<br> test for pipe</p>
</blockquote>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>如果所有指向管道写端的文件描述符都关闭了，而仍然有进程从管道中读取，那么，当管道中没有数据后，read 函数会返回0。</li>
<li>如果所有指向管道写端的文件描述符没有被完全关闭，但不再写入数据，而仍然有进程从管道中读取，那么，当管道中没有数据后，read 函数会被阻塞。</li>
<li>如果所有指向管道读端的文件描述符都关闭了，而仍然有进程向管道中写入，则该进程会收到SIGPIPE信号，默认情况下，进程会被终止。SIGPIPE信号的行为可以自定义。</li>
<li>如果所有指向管道读端的文件描述符没有被完全关闭，当管道被写满时，write 会被阻塞。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/21/linux/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%881%EF%BC%89-%E4%BF%A1%E5%8F%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何先生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="北国回忆录">
      <meta itemprop="description" content="东拼西凑、杂七杂八">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 北国回忆录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/21/linux/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%881%EF%BC%89-%E4%BF%A1%E5%8F%B7/" class="post-title-link" itemprop="url">Linux多进程编程-进程间通信（1）-信号</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-21 15:48:27" itemprop="dateCreated datePublished" datetime="2023-09-21T15:48:27+08:00">2023-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-07-30 19:18:20" itemprop="dateModified" datetime="2024-07-30T19:18:20+08:00">2024-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="信号通信的原理"><a href="#信号通信的原理" class="headerlink" title="信号通信的原理"></a>信号通信的原理</h3><h4 id="信号一览"><a href="#信号一览" class="headerlink" title="信号一览"></a>信号一览</h4><p>我们希望让程序A与程序B通过信号进行沟通，则需要两处设定</p>
<ul>
<li>A程序向B程序发送信号</li>
<li>B程序自定义信号的处理方式</li>
</ul>
<p>这样程序B就能够对程序A发送而来的信号进行解析了。程序A与程序B之间用来沟通的信号必须是Linux系统中预先设定的信号，否则无法被捕获。linux系统中有62种信号，可以通过以下命令查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -l</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">信号</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">SIGHUP</td>
<td align="left">在用户终端链接结束时发出</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">SIGINT</td>
<td align="left">程序终止信号，在用户输入Ctrl+C时发出</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">SIGQUIT</td>
<td align="left">与SIFINT类似，但是程序终止时会产生core文件</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">SIGILL</td>
<td align="left">程序出错，执行了非法指令所产生的信号</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">SIGTRAP</td>
<td align="left">由断点指令和其他trap指令产生，由debugger使用</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">SIGABRT</td>
<td align="left">调用about函数生成的信号</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">SIGBUS</td>
<td align="left">非法地址，包裹内存地址对齐出错</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">SIGFPE</td>
<td align="left">发生致命的算术运算错误时发出</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">SIGKILL</td>
<td align="left">用来立即结束程序的运行。<strong>本信号不能被阻塞、处理和忽略</strong></td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">SIGUSR1</td>
<td align="left">留给用户使用</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">SIGSEGV</td>
<td align="left">试图访问未分配给自己的内存，或试图向没有写权限的内存地址写数据</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">SIGUSR2</td>
<td align="left">留给用户使用</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">SIGPIPE</td>
<td align="left">管道破裂</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">SIGALRM</td>
<td align="left">时钟信号，计算实际时间或时钟时间，alarm函数使用该信号</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">SIGTERM</td>
<td align="left">程序结束信号，与SIGKILL不同，该信号可以被阻塞、处理</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left">SIGSTKFLT</td>
<td align="left">Linux专用，数学协处理器的栈异常</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left">SIGCHLD</td>
<td align="left">子进程结束时，父进程会收到这个信号</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left">SIGCONT</td>
<td align="left">让一个停止的进程继续执行</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left">SIGSTOP</td>
<td align="left">停止进程，<strong>本信号不能被阻塞、处理和忽略</strong></td>
</tr>
<tr>
<td align="left">20</td>
<td align="left">SIGTSTP</td>
<td align="left">停止进程，可以被处理和忽略</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left">SIGTTIN</td>
<td align="left">当后台作业要从用户终端读取数据时，该作业中所有进程都会收到该信号。默认时这些进程会停止执行</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left">SIGTTOU</td>
<td align="left">类似于SIFTTIN，但在写终端（或修改终端模式）时收到</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left">SIGURG</td>
<td align="left">有“紧急数据”或带外数据到达socket时产生</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left">SIGXCPU</td>
<td align="left">超过CPU时间资源限制</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left">SIGXFSZ</td>
<td align="left">进程企图扩大文件，以至于超过文件大小资源限制</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left">SIGVTALRM</td>
<td align="left">虚拟时钟信号，类似于SIGALRM，但计算的是该进程占用CPU的时间</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left">SIGPROF</td>
<td align="left">类似于SIGALRM和SIGVTALRM，但计算的是该进程占用CPU的时间和系统调用时间</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left">SIGWINCH</td>
<td align="left">窗口大小改变时发出</td>
</tr>
<tr>
<td align="left">29</td>
<td align="left">SIGIO</td>
<td align="left">文件描述符准备就绪，可以开始输入\输出操作</td>
</tr>
<tr>
<td align="left">30</td>
<td align="left">SIGPWR</td>
<td align="left">电源失败</td>
</tr>
<tr>
<td align="left">31</td>
<td align="left">SIGSYS</td>
<td align="left">非法系统调用</td>
</tr>
</tbody></table>
<p>以上31种信号是传统UNIX信号，是不可靠信号（非实时），不支持排队，可能造成信号丢失。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">信号</th>
<th align="left">序号</th>
<th align="left">信号</th>
<th align="left">序号</th>
<th align="left">信号</th>
<th align="left">序号</th>
<th align="left">信号</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">SIGRTMIN</td>
<td align="left">11</td>
<td align="left">SIGRTMIN+10</td>
<td align="left">21</td>
<td align="left">SIGRTMAX-10</td>
<td align="left">31</td>
<td align="left">SIGRTMAX</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">SIGRTMIN+1</td>
<td align="left">12</td>
<td align="left">SIGRTMIN+11</td>
<td align="left">22</td>
<td align="left">SIGRTMAX-9</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">SIGRTMIN+2</td>
<td align="left">13</td>
<td align="left">SIGRTMIN+12</td>
<td align="left">23</td>
<td align="left">SIGRTMAX-8</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">SIGRTMIN+3</td>
<td align="left">14</td>
<td align="left">SIGRTMIN+13</td>
<td align="left">24</td>
<td align="left">SIGRTMAX-7</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">SIGRTMIN+4</td>
<td align="left">15</td>
<td align="left">SIGRTMIN+14</td>
<td align="left">25</td>
<td align="left">SIGRTMAX-6</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">SIGRTMIN+5</td>
<td align="left">16</td>
<td align="left">SIGRTMIN+15</td>
<td align="left">26</td>
<td align="left">SIGRTMAX-5</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">SIGRTMIN+6</td>
<td align="left">17</td>
<td align="left">SIGRTMAX-14</td>
<td align="left">27</td>
<td align="left">SIGRTMAX-4</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">SIGRTMIN+7</td>
<td align="left">18</td>
<td align="left">SIGRTMAX-13</td>
<td align="left">28</td>
<td align="left">SIGRTMAX-3</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">SIGRTMIN+8</td>
<td align="left">19</td>
<td align="left">SIGRTMAX-12</td>
<td align="left">29</td>
<td align="left">SIGRTMAX-2</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">SIGRTMIN+9</td>
<td align="left">20</td>
<td align="left">SIGRTMAX-11</td>
<td align="left">30</td>
<td align="left">SIGRTMAX-1</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>以上31种信号后来扩充的信号，是可靠信号（实时），支持排队，不会丢失。</p>
<h3 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h3><p>在C&#x2F;C++程序中，可以通过kill命令向指定PID的程序发送信号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>  # 包含pid_t类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span>     # 包含kill函数</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param pid   信号接收者标识</span></span><br><span class="line"><span class="comment"> * @param sig   信号</span></span><br><span class="line"><span class="comment"> * @return      执行成功返回0，否则返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure>
<p>其中信号接收者标识pid有四种情况</p>
<table>
<thead>
<tr>
<th align="center">pid</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&gt;0</td>
<td align="center">此时的pid为进程号</td>
</tr>
<tr>
<td align="center">&#x3D;0</td>
<td align="center">信号将送往所有与调用kill()函数同使用组的进程</td>
</tr>
<tr>
<td align="center">&#x3D;-1</td>
<td align="center">信号将依据调用kill()函数进程的权限发送给所有能够被发送的进程（init除外）</td>
</tr>
<tr>
<td align="center">&lt;-1</td>
<td align="center">信号将送往以-pid为组标识的进程</td>
</tr>
</tbody></table>
<blockquote>
<p>相关阅读-进程的组标识：进程组长的pid号</p>
</blockquote>
<h3 id="设置信号的处理方式"><a href="#设置信号的处理方式" class="headerlink" title="设置信号的处理方式"></a>设置信号的处理方式</h3><p>设置信号的处理方式后，程序接收到信号后会对信号进行中断反应。信号处理方式的设置并不会阻碍程序的运行。</p>
<h4 id="复杂的sigaction"><a href="#复杂的sigaction" class="headerlink" title="复杂的sigaction"></a>复杂的sigaction</h4><p>sigaction()函数可以用来设置信号（SIGKILL和SIGSTOP除外）的处理方式以及在处理过程中对其他信号的屏蔽行为。该函数的形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param signum    需要设置处理方式的信号，可以指定除SIGKILL和SIGSTOP以外的所有信号</span></span><br><span class="line"><span class="comment"> * @param act       对信号处理方式进行设置的结构体指针</span></span><br><span class="line"><span class="comment"> * @param oldact    原来对信号的处理方式</span></span><br><span class="line"><span class="comment"> * @return          执行成功返回0，否则返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br></pre></td></tr></table></figure>

<p>结构体struct sigaction的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span>&#123;</span></span><br><span class="line">    <span class="type">void</span>        (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">    <span class="type">void</span>        (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">    <span class="type">sigset_t</span>    sa_mask;</span><br><span class="line">    <span class="type">int</span>         sa_flags;</span><br><span class="line">    <span class="type">void</span>        (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在该结构体中，sa_handler和sa_sigaction都指向一个信号处理函数，用来自定义信号处理方式，具体使用哪一个由参数sa_flags决定。需要注意的是，sa_handler和sa_sigaction由于存放在联合体中而不能同时设定。sa_restorer被弃用。sa_mask用来指定在信号处理期间需要屏蔽的信号。sa_flags用于指定信号的处理行为，具体如下：</p>
<table>
<thead>
<tr>
<th align="center">sa_flags</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SA_RESTART</td>
<td align="center">使被信号打断的系统调用自动重新发起</td>
</tr>
<tr>
<td align="center">SA_NOCLDSTOP</td>
<td align="center">使父进程在他的子进程暂停或继续运行时不会收到SIGCHLD信号</td>
</tr>
<tr>
<td align="center">SA_NOCLDWAIT</td>
<td align="center">使父进程在它的子进程退出时不会收到SIGCHLD信号</td>
</tr>
<tr>
<td align="center">SA_NODEFER</td>
<td align="center">使信号屏蔽无效</td>
</tr>
<tr>
<td align="center">SA_RESETHAND</td>
<td align="center">信号处理之后重新设置为默认的处理方式</td>
</tr>
<tr>
<td align="center">SA_SIGINFO</td>
<td align="center">使用sa_sigaction而非sa_handler</td>
</tr>
</tbody></table>
<p>我们看下面的例程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">sig_usr</span><span class="params">(<span class="type">int</span> signum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> sa_usr;</span><br><span class="line">    sa_usr.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sa_usr.sa_handler = sig_usr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sigaction</span>(SIGUSR1, &amp;sa_usr, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">sigaction</span>(SIGUSR2, &amp;sa_usr, <span class="literal">NULL</span>);</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;My PID is &quot;</span>&lt;&lt; <span class="built_in">getpid</span>()&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((n = <span class="built_in">read</span>(STDIN_FILENO, buf, <span class="number">511</span>))==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                    cout&lt;&lt; <span class="string">&quot;此调用被信号中断。\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            buf[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            cout&lt;&lt; buf&lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">sig_usr</span><span class="params">(<span class="type">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(signum == SIGUSR1)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;SIGUSR1 received\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(signum == SIGUSR2)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;SIGUSR2 received\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;signal &quot;</span>&lt;&lt; signum&lt;&lt; <span class="string">&quot; received\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例程中，我们设置了 SIGUSR1 和 SIGUSR2 的处理方式，并让程序不断读取标准输入文件的内容。由于进程对信号的处理是中断式的，所以当进程接收到 SIGUSR1 或 SIGUSR2 信号后，读取操作会被中断，当 read 函数因为被中断而读取失败时，将返回-1，并将 EINTR 错误写入到 errno 中。</p>
<p>将程序编译执行，并开启另一个终端向该进程发送信号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -USR1 pid</span><br><span class="line"><span class="built_in">kill</span> -USR2 pid</span><br></pre></td></tr></table></figure>
<blockquote>
<p>My PID is 236<br>  SIGUSR1 received<br>  此调用被信号中断。<br>  SIGUSR2 received<br>  此调用被信号中断。        </p>
</blockquote>
<p>若不想主进程被信号中断而出错，则需要让进程被打断的操作自动重新发起。在程序中需要修改 sa_usr.sa_flags &#x3D; SA_RESTART; 编译并运行程序，在另一个终端中向该进程发送信号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -USR1 pid</span><br><span class="line"><span class="built_in">kill</span> -USR2 pid</span><br></pre></td></tr></table></figure>
<blockquote>
<p>My PID is 210<br>  SIGUSR1 received<br>  SIGUSR2 received      </p>
</blockquote>
<p>可以看到，读取操作将不会因为中断而失败。</p>
<h4 id="简单的signal"><a href="#简单的signal" class="headerlink" title="简单的signal"></a>简单的signal</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param signum    需要设置处理方式的信号</span></span><br><span class="line"><span class="comment"> * @param handler   处理信号的回调函数</span></span><br><span class="line"><span class="comment"> * @return          执行成功返回0，否则返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">void</span>* handler)</span></span>;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/21/linux/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何先生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="北国回忆录">
      <meta itemprop="description" content="东拼西凑、杂七杂八">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 北国回忆录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/21/linux/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/" class="post-title-link" itemprop="url">Linux多进程编程-守护进程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-21 13:20:18" itemprop="dateCreated datePublished" datetime="2023-09-21T13:20:18+08:00">2023-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-07-30 19:18:10" itemprop="dateModified" datetime="2024-07-30T19:18:10+08:00">2024-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="守护进程的特点"><a href="#守护进程的特点" class="headerlink" title="守护进程的特点"></a>守护进程的特点</h2><h4 id="具有超级用户权限"><a href="#具有超级用户权限" class="headerlink" title="具有超级用户权限"></a>具有超级用户权限</h4><h4 id="父进程是init进程"><a href="#父进程是init进程" class="headerlink" title="父进程是init进程"></a>父进程是init进程</h4><h4 id="不使用控制终端"><a href="#不使用控制终端" class="headerlink" title="不使用控制终端"></a>不使用控制终端</h4><h4 id="是各自进程组和会话过程的唯一进程"><a href="#是各自进程组和会话过程的唯一进程" class="headerlink" title="是各自进程组和会话过程的唯一进程"></a>是各自进程组和会话过程的唯一进程</h4><h2 id="编写守护进程的基本步骤"><a href="#编写守护进程的基本步骤" class="headerlink" title="编写守护进程的基本步骤"></a>编写守护进程的基本步骤</h2><h3 id="创建子进程，退出父进程"><a href="#创建子进程，退出父进程" class="headerlink" title="创建子进程，退出父进程"></a>创建子进程，退出父进程</h3><ul>
<li>父进程先于子进程退出会变为孤儿进程</li>
<li>孤儿进程会被init进程收养——<a href="#%E7%88%B6%E8%BF%9B%E7%A8%8B%E6%98%AFinit%E8%BF%9B%E7%A8%8B">父进程是init进程</a></li>
</ul>
<h3 id="在子进程中创建新对话"><a href="#在子进程中创建新对话" class="headerlink" title="在子进程中创建新对话"></a>在子进程中创建新对话</h3><ul>
<li>setsid函数用于创建新会话，并担任该会话的组长——<a href="#%E6%98%AF%E5%90%84%E8%87%AA%E8%BF%9B%E7%A8%8B%E7%BB%84%E5%92%8C%E4%BC%9A%E8%AF%9D%E8%BF%87%E7%A8%8B%E7%9A%84%E5%94%AF%E4%B8%80%E8%BF%9B%E7%A8%8B">是各自进程组和会话过程的唯一进程</a></li>
<li>setsid函数让进程摆脱原会话、原进程组和原控制终端的控制——<a href="#%E4%B8%8D%E4%BD%BF%E7%94%A8%E6%8E%A7%E5%88%B6%E7%BB%88%E7%AB%AF">不使用控制终端</a></li>
<li>setsid函数使进程完全独立出来</li>
</ul>
<h3 id="改变当前目录为根目录"><a href="#改变当前目录为根目录" class="headerlink" title="改变当前目录为根目录"></a>改变当前目录为根目录</h3><p>试想，如果我们的守护进程的工作目录是在一个U盘里，那当我们要弹出U盘时，由于守护进程的存在我们会失败。因此，守护进程的工作目录需要修改为非移动设备上，比如我们的根目录。</p>
<ul>
<li>chdir函数可以更改进程的工作路径</li>
</ul>
<h3 id="重新设置文件权限掩码"><a href="#重新设置文件权限掩码" class="headerlink" title="重新设置文件权限掩码"></a>重新设置文件权限掩码</h3><ul>
<li>子进程会继承原父进程的文件权限掩码</li>
<li>给子进程使用文件带来麻烦</li>
<li>函数umask(0)重设文件权限掩码</li>
</ul>
<blockquote>
<p>umask(0)所获得的权限是将0取反在与创建文件时的权限相与。相当于保留了文件的创建时权限。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">权限</th>
<th align="center">八进制值</th>
<th align="center">二进制值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">—</td>
<td align="center">0</td>
<td align="center">000</td>
<td align="center">没有权限</td>
</tr>
<tr>
<td align="center">–x</td>
<td align="center">1</td>
<td align="center">001</td>
<td align="center">只有执行权限</td>
</tr>
<tr>
<td align="center">-w-</td>
<td align="center">2</td>
<td align="center">010</td>
<td align="center">只有写权限</td>
</tr>
<tr>
<td align="center">-wx</td>
<td align="center">3</td>
<td align="center">011</td>
<td align="center">写入和执行权限</td>
</tr>
<tr>
<td align="center">r–</td>
<td align="center">4</td>
<td align="center">100</td>
<td align="center">只有阅读权限</td>
</tr>
<tr>
<td align="center">r-x</td>
<td align="center">5</td>
<td align="center">101</td>
<td align="center">读取和执行权限</td>
</tr>
<tr>
<td align="center">rw-</td>
<td align="center">6</td>
<td align="center">110</td>
<td align="center">读写权限</td>
</tr>
<tr>
<td align="center">rwx</td>
<td align="center">7</td>
<td align="center">111</td>
<td align="center">执行所有三项操作的权限，即读取、写入和执行</td>
</tr>
</tbody></table>
<h3 id="关闭文件描述符"><a href="#关闭文件描述符" class="headerlink" title="关闭文件描述符"></a>关闭文件描述符</h3><ul>
<li>子进程会继承父进程已打开的文件，但这些文件可能不再使用，但依旧占据系统资源</li>
<li>比如标准输入输出和错误文件0,1,2，守护进程永远无法输出内容到屏幕，这三个文件失去作用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MAXFILE;i++) <span class="built_in">close</span>(i);    <span class="comment">//关闭文件描述符, MAXFILE是系统能够提供的文件描述符的最大值</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>相关阅读：子进程能否访问父进程上锁的文件？<br>在操作系统中，Fork会创建一个与父进程几乎相同的子进程。这意味着子进程继承了父进程的许多属性，例如打开的文件描述符和虚拟内存。然而，在Fork后，子进程和父进程是两个完全独立的进程，它们共享的只有一个初始状态。因此，子进程不能继承父进程的锁。如果父进程在Fork之前持有一个锁，它会继续持有该锁，但是在子进程中，锁的状态将被重置。在子进程中，锁不再处于锁定状态，因此需要重新获取锁才能访问共享资源。此外，锁的互斥量被存储在内存中，子进程会得到它自己的内存副本，这意味着子进程和父进程中的锁不会是相同的锁。<br>因此，子进程需要重新获取锁才能访问共享资源。如果在父进程中的锁是一个进程之间共享的锁（例如POSIX 有名信号量），则可以再次打开该锁，使得父子进程都可以使用这个锁，但必须小心以避免锁的竞争条件。</p>
</blockquote>
<h3 id="让守护进程能够被退出"><a href="#让守护进程能够被退出" class="headerlink" title="让守护进程能够被退出"></a>让守护进程能够被退出</h3><ul>
<li>使用kill命令来终止守护进程</li>
<li>kill命令会向进程发送signal信号，我们需要让守护进程能够接收信号<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">signal</span>(SIGTERM, sigterm_handler);   <span class="comment">// SIGTERM是kill命令发出的信号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigterm_handler</span><span class="params">(<span class="type">int</span> arg)</span></span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>相关阅读：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_55752775/article/details/130853402">Linux中的信号</a></p>
</blockquote>
<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>         <span class="comment">// 包含 exit</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>         <span class="comment">// 包含 strlen</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>          <span class="comment">// 包含 open</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>      <span class="comment">// 包含 pid_t</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>         <span class="comment">// 包含 read, write, close, usleep, setsid, chdir</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span>         <span class="comment">// 包含 signal, SIGTERM</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>       <span class="comment">// 包含 umask</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILE 1024        <span class="comment">// 使用ulimit -n命令查看</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> _running = <span class="number">1</span>;     <span class="comment">// volatile告诉编译器，_running随时可能被更改。_running标志着我们守护进程的运行状态，1代表在运行，0代表需要终止。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigterm_handler</span><span class="params">(<span class="type">int</span> arg)</span></span>&#123;</span><br><span class="line">    _running = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pc;</span><br><span class="line">    <span class="type">int</span> fd, len;</span><br><span class="line">    <span class="type">char</span>* buf = <span class="string">&quot;This is a Dameon.\n&quot;</span>;</span><br><span class="line">    len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    pc = fork();                        <span class="comment">// **创建子进程**</span></span><br><span class="line">    <span class="keyword">if</span>(pc&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;ERROR: create process failed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pc&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;PID: %d\n&quot;</span>, pc);        <span class="comment">// 输出子进程PID</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);                        <span class="comment">// **退出父进程**</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setsid</span>();                           <span class="comment">// **创建新会话**</span></span><br><span class="line">    <span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>);                         <span class="comment">// **将工作目录转移到根目录**</span></span><br><span class="line">    <span class="built_in">umask</span>(<span class="number">0</span>);                           <span class="comment">// **重置文件权限掩码**</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;MAXFILE;i++) <span class="built_in">close</span>(i);<span class="comment">// **关闭所有文件描述符**   //这里没有关闭标准输入输出和错误，方便我们debug。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, sigterm_handler);   <span class="comment">// **处理kill事件**</span></span><br><span class="line">    <span class="keyword">while</span>(_running)&#123;</span><br><span class="line">        fd = <span class="built_in">open</span>(<span class="string">&quot;/home/torch/code/linux-c++/clion/dameon.log&quot;</span>, O_CREAT|O_WRONLY|O_APPEND);    <span class="comment">// 文件不存在时创建，仅写入，追加</span></span><br><span class="line">        <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);                                                <span class="comment">// 文件打开失败</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">write</span>(fd, buf, len);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">10</span>*<span class="number">1000</span>);                                            <span class="comment">// 10ms延时</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将代码编译后用sudo权限执行——<a href="#%E5%85%B7%E6%9C%89%E8%B6%85%E7%BA%A7%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90">具有超级用户权限</a></p>
<blockquote>
<p>PID: 9259</p>
</blockquote>
<p>可以通过ps axj命令查看守护进程，可以找到我们的进程就在其中。可以使用sudo kill 9259杀死我们的进程。使用管理员权限打开dameon.log文件，可以看到里面的内容。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/20/linux/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B-%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何先生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="北国回忆录">
      <meta itemprop="description" content="东拼西凑、杂七杂八">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 北国回忆录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/20/linux/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B-%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B/" class="post-title-link" itemprop="url">Linux多进程编程-创建进程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-20 15:31:11" itemprop="dateCreated datePublished" datetime="2023-09-20T15:31:11+08:00">2023-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-07-30 19:18:24" itemprop="dateModified" datetime="2024-07-30T19:18:24+08:00">2024-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="进程的基础操作"><a href="#进程的基础操作" class="headerlink" title="进程的基础操作"></a>进程的基础操作</h2><h3 id="获得当前进程的PID"><a href="#获得当前进程的PID" class="headerlink" title="获得当前进程的PID"></a>获得当前进程的PID</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程的PID是：%d\n&quot;</span>, pid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>进程的PID是：4830</p>
</blockquote>
<h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><ol>
<li>函数<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>该函数用于创建子进程，子进程被创建后复制父进程的程序内容和变量内容（但不共享变量内存，不继承文件锁），包括该fork函数。如果进程创建成功，在父进程中，fork函数的返回值为子进程的PID；在子进程中fork函数的返回值为0。看起来就像是fork有两个返回值一样。如果进程创建失败，子进程没有产生，父进程中的fork函数返回-1。</p>
<ol start="2">
<li>示例代码</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;                          <span class="comment">// 用以记录进程的PID</span></span><br><span class="line">    <span class="type">int</span> counter = <span class="number">0</span>;                    <span class="comment">// 用以证明子进程复制了父进程的程序，但并不是内存共享</span></span><br><span class="line"></span><br><span class="line">    pid = fork();                       <span class="comment">// 创建子进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;                          <span class="comment">// 进程创建失败</span></span><br><span class="line">        cerr&lt;&lt; <span class="string">&quot;进程创建失败！&quot;</span>&lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;                    <span class="comment">// 该进程为子进程</span></span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;我是子进程，PID：&quot;</span>&lt;&lt; <span class="built_in">getpid</span>()&lt;&lt; endl;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;                               <span class="comment">// 该进程为父进程</span></span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;我是父进程，PID：&quot;</span>&lt;&lt; <span class="built_in">getpid</span>()&lt;&lt; <span class="string">&quot;  我获得的子进程PID为：&quot;</span>&lt;&lt; pid&lt;&lt; endl;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;子进程中的counter：&quot;</span>&lt;&lt; counter&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;父进程中的counter：&quot;</span>&lt;&lt; counter&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我是父进程，PID：7825  我获得的子进程PID为：7826<br>父进程中的counter：1<br>我是子进程，PID：7826<br>子进程中的counter：1    </p>
</blockquote>
<ol start="3">
<li>分析</li>
</ol>
<p>可以看到，在父进程中我们所获得的子进程的PID和在子进程中所获得的PID是一致的(7826)。同时，子进程虽然在创建时拷贝了父进程的变量，但是，由于子进程与父进程之间不存在内存共享，所以在子进程和父进程中分别修改counter并不能互相影响。<strong>另外，子进程和父进程的执行并没有先后顺序，一切都取决于操作系统的调度策略。</strong></p>
<h3 id="如何控制父进程与子进程的时序关系？"><a href="#如何控制父进程与子进程的时序关系？" class="headerlink" title="如何控制父进程与子进程的时序关系？"></a>如何控制父进程与子进程的时序关系？</h3><p>很多时候，我们希望子进程先行结束，然后再结束父进程。这样做有三点好处：</p>
<ul>
<li>能够确保交给子进程的任务在父进程结束之前完满完成。</li>
<li>同时也可以避免父进程先行结束，子进程成为孤儿进程。</li>
<li>在父进程中回收子进程的task_struct，以免子进程成为僵尸进程。</li>
</ul>
<p>在C\C++中，我们通过wait()或waitpid()函数来实现这一目的。wait()和waitpid()函数都能够阻塞调用他们的进程，直到接收到子进程的状态才会结束阻塞。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description     阻塞父进程，等待任意一个子进程退出，停止阻塞并回收子进程资源</span></span><br><span class="line"><span class="comment"> * @param status    存放子进程的结束状态</span></span><br><span class="line"><span class="comment"> * @return          执行成功返回子进程的PID，失败返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span>* status)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description     高配版wait，函数的行为由pid和options参数决定</span></span><br><span class="line"><span class="comment"> * @param pid       子进程的PID号</span></span><br><span class="line"><span class="comment"> * @param status    存放子进程的结束状态</span></span><br><span class="line"><span class="comment"> * @param options   函数控制选项</span></span><br><span class="line"><span class="comment"> * @return          由options的设定决定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span>* status, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure>

<p>在waitpid()函数中，参数pid有以下几种状态：</p>
<table>
<thead>
<tr>
<th align="center">pid</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&gt;0</td>
<td align="center">需要等待的子进程的PID号</td>
</tr>
<tr>
<td align="center">&#x3D;0</td>
<td align="center">等待与当前进程相同组的任何子进程进程</td>
</tr>
<tr>
<td align="center">&#x3D;-1</td>
<td align="center">等待任何子进程，与 wait() 相似</td>
</tr>
<tr>
<td align="center">&lt;-1</td>
<td align="center">等待进程组识别码为-pid的任何子进程</td>
</tr>
</tbody></table>
<p>options参数设定与函数行为的对应关系如下：</p>
<table>
<thead>
<tr>
<th align="center">options</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">WNOHANG</td>
<td align="center"><strong>非阻塞</strong>形式：若pid表示的子进程没有结束，则不予等待，返回0；若结束，则返回该子进程进程PID。发生错误返回-1。</td>
</tr>
<tr>
<td align="center">WUNTRACED</td>
<td align="center">若pid表示的子进程进入暂停状态，则立即返回子进程PID；若子进程处于结束状态，则不予理会。发生错误返回-1。</td>
</tr>
</tbody></table>
<h3 id="替换进程"><a href="#替换进程" class="headerlink" title="替换进程"></a>替换进程</h3><ol>
<li>函数<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* arg, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">const</span> <span class="type">char</span>* arg, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* arg, ..., <span class="type">char</span>* <span class="type">const</span> envp[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">char</span>* <span class="type">const</span> arg[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">char</span>* <span class="type">const</span> arg[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">char</span>* <span class="type">const</span> arg[], <span class="type">char</span>* <span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>exec函数族同样可以创建进程，与fork不同的是，exec创建的进程会取代父进程，甚至会占有父进程的PID，实打实的进程界的“鬼上身”。exec函数族中常用的两个函数分别是execl和execlp，下面将通过实例详细介绍。</p>
<ul>
<li>execl</li>
</ul>
<p>execl的第一个参数是执行文件的路径，第二个参数是该执行文件所需的输入（执行文件传参），和我们main(int argc, char** argv)中的argv部分一样，执行文件传参的第一个参数argv[0]一般是文件名（可以是任何字符，一般设置为文件名或命令名）。从第二个参数argv[1]起才是真正能够在执行文件中发挥作用的参数。当argv中出现NULL时则认为传参结束。一般情况下，执行文件都需要一个argv[0]文件名参数，也就是说argv至少需要一个非null参数（就是我们说的文件名），否则不能正确执行。<br>函数执行成功时无返回值，执行失败时返回-1.</p>
<p><strong>$ 执行一个不需要传参的执行文件</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="built_in">execl</span>(<span class="string">&quot;/bin/pwd&quot;</span>, <span class="string">&quot;pwd&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;==========================&quot;</span>&lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x2F;home&#x2F;torch&#x2F;code&#x2F;linux-c++&#x2F;clion&#x2F;cmake-build-debug</p>
</blockquote>
<p>在这个例子中，我们执行了pwd命令，他是一个不需要参数的命令，因此我们的argv[0]为命令名，并没有实际作用，但必须要有；argv[1]为NULL，表示传参结束。另外，程序并没有输出一串”&#x3D;”号，说明程序被替换为了pwd命令，原来的程序已经不存在了。</p>
<p><strong>$ 执行一个需要传参的执行文件</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="built_in">execl</span>(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls -al&quot;</span>, <span class="string">&quot;-al&quot;</span>, <span class="string">&quot;/etc/passwd&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x2F;home&#x2F;torch&#x2F;code&#x2F;linux-c++&#x2F;clion&#x2F;cmake-build-debug</p>
</blockquote>
<p>在这个例子中，我们执行了ls -al &#x2F;etc&#x2F;passwd命令，所以我们的argv[0]为”ls -al”并没有实际作用，但必须要有；argv[1]为”-al”，argv[2]为”&#x2F;etc&#x2F;passwd”，argv[3]为NULL，表示传参结束。</p>
<p><strong>$ 如果argv没有任何参数会发生什么？</strong></p>
<p>我们首先写一个被执行程序，并把他编译为test.out，然后执行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * file name: test.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;argc: &quot;</span>&lt;&lt; argc&lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;argc;i++)&#123;</span><br><span class="line">        cout&lt;&lt; argv[i]&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>argc: 1<br>.&#x2F;test.out</p>
</blockquote>
<p>系统自动传递了一个文件名参数给我们的程序，因此检测到一个参数，参数为文件名。</p>
<p>我们再写一个程序通过execl函数执行我们的test.out</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="built_in">execl</span>(<span class="string">&quot;./test.out&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>argc：1    </p>
</blockquote>
<p>可以看到，当我们不传递任何参数给执行文件时，编译时会给我们警告，并且函数会自动传递一个空字符参数给我们的执行文件。我们对程序进行修改：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="built_in">execl</span>(<span class="string">&quot;./test.out&quot;</span>, <span class="string">&quot;test.out&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>argc：1<br>test.out</p>
</blockquote>
<p>此时编译器不再发出警告，test.out获得了我们传递给他的”test.out”字符串。</p>
<ul>
<li>execlp</li>
</ul>
<p>execlp的第一个参数是环境变量中的文件名，第二个参数和execl一致。相比于execl，execlp专门用来执行已经加入到环境变量中的程序。</p>
<p><strong>$ 示例</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="built_in">execlp</span>(<span class="string">&quot;pwd&quot;</span>, <span class="string">&quot;pwd&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>&#x2F;home&#x2F;torch&#x2F;code&#x2F;linux-c++&#x2F;clion&#x2F;cmake-build-debug</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/19/linux/linux%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/Linux%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B-C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何先生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="北国回忆录">
      <meta itemprop="description" content="东拼西凑、杂七杂八">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 北国回忆录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/19/linux/linux%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/Linux%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B-C++/" class="post-title-link" itemprop="url">Linux文件编程-C++</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-19 15:57:48" itemprop="dateCreated datePublished" datetime="2023-09-19T15:57:48+08:00">2023-09-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-07-30 19:20:21" itemprop="dateModified" datetime="2024-07-30T19:20:21+08:00">2024-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="流的概念"><a href="#流的概念" class="headerlink" title="流的概念"></a>流的概念</h2><p>在C++语言中，数据的输入和输出（I&#x2F;O）包括对标准输入设备（键盘）和标准输出设备（显示器）、外存磁盘文件、内存中指定字符串储存空间进行输入和输出三个方面，分别简称为标准I&#x2F;O，文件I&#x2F;O，串I&#x2F;O。C++将写入文件和读取文件抽象的说为<strong>文件流</strong>，三种I&#x2F;O对应着三种文件流，分别是标准I&#x2F;O流，文件I&#x2F;O流和字符串I&#x2F;O流。</p>
<table>
<thead>
<tr>
<th align="center">流</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">标准I&#x2F;O流</td>
<td align="center">内存与标准输入输出设备之间的信息传递</td>
</tr>
<tr>
<td align="center">文件I&#x2F;O流</td>
<td align="center">内存与外部文件之间的信息传递</td>
</tr>
<tr>
<td align="center">字符串I&#x2F;O流</td>
<td align="center">内存变量与表示字符串流的数组之间的传递</td>
</tr>
</tbody></table>
<h2 id="流的类库"><a href="#流的类库" class="headerlink" title="流的类库"></a>流的类库</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">头文件’&lt;fstream&gt;‘所提供的文件流</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ifstream</td>
<td align="center">输入文件流，用于从文件读取信息</td>
</tr>
<tr>
<td align="center">ofstream</td>
<td align="center">输出文件流，用于创建文件和向文件写入信息</td>
</tr>
<tr>
<td align="center">fstream</td>
<td align="center">文件流，包含输入文件流和输出文件流的功能</td>
</tr>
</tbody></table>
<blockquote>
<p>虽然fstream看起来很全能，但是实际应用中并不好用。ifstream和ofstream再打开文件时如果文件不存在则会创建文件，而fstream当文件不存在时虽然不报错，但是后续对文件的操作无法生效。</p>
</blockquote>
<h2 id="流操作"><a href="#流操作" class="headerlink" title="流操作"></a>流操作</h2><blockquote>
<p>所有代码都是示意代码，并不能运行。</p>
</blockquote>
<h3 id="基础文件I-O"><a href="#基础文件I-O" class="headerlink" title="基础文件I&#x2F;O"></a>基础文件I&#x2F;O</h3><p>这里我们以ifstream为例，ofstream具有相同的成员函数和操作方式。</p>
<ul>
<li><p>打开文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种打开文件的方式——构造函数</span></span><br><span class="line"><span class="function">ifstream <span class="title">infile</span><span class="params">(file_name, open_mode)</span></span>;</span><br><span class="line"><span class="comment">// 第二种打开文件的方式——成员函数</span></span><br><span class="line">ifstream infile;</span><br><span class="line">infile.<span class="built_in">open</span>(file_name, open_mode);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">open_mode[^1]</th>
<th align="center">速记</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ios::out</td>
<td align="center">output (输出)</td>
<td align="center">指定文件的打开方式为写入，一般为必要参数，但在使用 ofstream 对象时，为默认参数</td>
</tr>
<tr>
<td align="center">ios::app</td>
<td align="center">append (添加)</td>
<td align="center">当打开文件用于写入时，会在已有数据之后写入，不覆盖原有内容。使用此种打开方式，每次写入都会置于文件末尾，即便之前更改了位置。</td>
</tr>
<tr>
<td align="center">ios::trunc</td>
<td align="center">truncate (截断)</td>
<td align="center">当打开文件时，如果文件存在内容则清空文件内容</td>
</tr>
<tr>
<td align="center">ios::ate</td>
<td align="center">at end (在结束处)</td>
<td align="center">以写入方式打开文件，并将文件指针置于末尾。与 ios::app不同之处为，如果改变了指针位置，写入不一定会在文件末尾</td>
</tr>
</tbody></table>
</li>
<li><p>判断文件是否打开成功</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ifstream infile;</span><br><span class="line">infile.<span class="built_in">open</span>(file_name, open_mode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">if</span>(infile) &#123;<span class="comment">/*文件打开成功*/</span>&#125;;</span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">if</span>(infile.<span class="built_in">is_open</span>()) &#123;<span class="comment">/*文件打开成功*/</span>&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>关闭文件</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ifstream infile;</span><br><span class="line"></span><br><span class="line">infile.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>读取文件</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>       <span class="comment">// getline函数需要包含头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ifstream infile;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取一行内容，遇到\n停止，读取成功返回true，遇到文件结尾返回false</span></span><br><span class="line"><span class="built_in">getline</span>(infile, <span class="type">char</span>* c);</span><br><span class="line"><span class="comment">// 读取一个字符，读取成功返回true，遇到文件结尾返回false</span></span><br><span class="line">infile.<span class="built_in">get</span>(<span class="type">char</span> c);</span><br><span class="line"><span class="comment">// 读取内容直到分隔符（空格、换行...）</span></span><br><span class="line">infile&gt;&gt; <span class="type">char</span>* c;</span><br></pre></td></tr></table></figure>

<ul>
<li>写入文件</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ofstream outfile;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入字符串c中的全部内容</span></span><br><span class="line">outfile&lt;&lt; <span class="type">char</span>* c;</span><br><span class="line"><span class="comment">// 写入一个字符</span></span><br><span class="line">outfile.<span class="built_in">put</span>(<span class="type">char</span> c);</span><br></pre></td></tr></table></figure>

<ul>
<li>获取文件偏移量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ofstream outfile;</span><br><span class="line">ifstream infile;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ofstream和ifstream的获取文件偏移的方法不可混用</span></span><br><span class="line"><span class="comment">// 两个函数都返回所处位置处的字符在文件中的编号位置</span></span><br><span class="line">outfile.<span class="built_in">tellp</span>();</span><br><span class="line">infile.<span class="built_in">tellg</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>设置文件偏移量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ofstream outfile;</span><br><span class="line">ifstream infile;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ofstream和ifstream的设置文件偏移的方法不可混用</span></span><br><span class="line">outfile.<span class="built_in">seekp</span>(streampos pos);                       <span class="comment">// pos为字符在文件中的编号位置</span></span><br><span class="line">outfile.<span class="built_in">seekp</span>(streamoff off, ios::seek_dir dir);    <span class="comment">// dir为起始搜索位置，off为相对于dir向文件末尾的偏移量</span></span><br><span class="line"></span><br><span class="line">outfile.<span class="built_in">seekp</span>(streampos pos);                       <span class="comment">// pos为字符在文件中的编号位置</span></span><br><span class="line">outfile.<span class="built_in">seekp</span>(streamoff off, ios::seek_dir dir);    <span class="comment">// dir为起始搜索位置，off为相对于dir向文件末尾的偏移量</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">dir</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ios::beg</td>
<td align="center">文件流的起始位置（默认值）</td>
</tr>
<tr>
<td align="center">ios::cur</td>
<td align="center">文件流的当前位置</td>
</tr>
<tr>
<td align="center">ios::end</td>
<td align="center">文件流的结束位置</td>
</tr>
</tbody></table>
<blockquote>
<p>由于ios是ifstream和ofstream的一个父类，所以也可以使用ifstream::beg等来使用这些枚举</p>
</blockquote>
<ul>
<li>文件状态判断</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ifstream infile;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写的过程中出错则返回true</span></span><br><span class="line">infile.<span class="built_in">bad</span>();</span><br><span class="line"><span class="comment">// 包含bad的情况，另外，读入的数据与容器格式不符时也会报错，例如想读入一个整数却得到一个字母</span></span><br><span class="line">infile.<span class="built_in">fail</span>();</span><br><span class="line"><span class="comment">// 文件达到末尾时返回true</span></span><br><span class="line">infile.<span class="built_in">eof</span>();</span><br><span class="line"><span class="comment">// 文件没有读写和格式不符错误，且没有达到文件末尾。即fail和eof都是false时，该函数为true</span></span><br><span class="line">infile.<span class="built_in">good</span>();</span><br></pre></td></tr></table></figure>

<h3 id="更精细的文件I-O"><a href="#更精细的文件I-O" class="headerlink" title="更精细的文件I&#x2F;O"></a>更精细的文件I&#x2F;O</h3><ul>
<li>获得文件的大小</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ifstream infile;</span><br><span class="line"></span><br><span class="line">infile.<span class="built_in">seekg</span>(<span class="number">0</span>, infile.end);</span><br><span class="line"><span class="type">int</span> file_length = infile.<span class="built_in">tellg</span>();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如若想获得某一部分的大小，则可以该部分内容的起始位置和终止位置的序号相减。</p>
</blockquote>
<ul>
<li>将文件读入内存</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ifstream infile;</span><br><span class="line"></span><br><span class="line">infile.<span class="built_in">seekg</span>(<span class="number">0</span>, infile.end);</span><br><span class="line"><span class="type">int</span> file_length = infile.<span class="built_in">tellg</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[file_length];</span><br><span class="line">infile.<span class="built_in">read</span>(buffer, file_length);</span><br><span class="line"><span class="keyword">delete</span>[] buffer;</span><br></pre></td></tr></table></figure>

<ul>
<li>将内存写入文件</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先将内容读入到内存中</span></span><br><span class="line">ifstream infile;</span><br><span class="line"></span><br><span class="line">infile.<span class="built_in">seekg</span>(<span class="number">0</span>, infile.end);</span><br><span class="line"><span class="type">int</span> file_length = infile.<span class="built_in">tellg</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[file_length];</span><br><span class="line">infile.<span class="built_in">read</span>(buffer, file_length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再将内容写入到文件中</span></span><br><span class="line">ofstream outfile;</span><br><span class="line">outfile.<span class="built_in">write</span>(buffer, file_length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] buffer;</span><br></pre></td></tr></table></figure>


<p>[^1]:<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44488341/article/details/131466397">【C++】标准库 - 文件的读写 ifstream, ofstream, fstream</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">何先生</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
